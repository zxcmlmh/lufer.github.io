<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="系统架构设计师教程(施工中)"><meta name="keywords" content="读书笔记"><meta name="author" content="Lufer"><meta name="copyright" content="Lufer"><title>系统架构设计师教程(施工中) | Lufer</title><link rel="shortcut icon" href="https://s2.ax1x.com/2019/08/07/eI1NJH.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e2cd7e52254704223bd3b9c0461bc06e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script src="https://www.googletagmanager.com/gtag/js?id=G-T5L2KPFS29"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-T5L2KPFS29');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"D3K0O2R6F2","apiKey":"4e808ae377111360493e99d31970584c","indexName":"BLOG_LUFER","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text"> 第一章 计算机组成与体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-text"> 1.1 计算机系统组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#111-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text"> 1.1.1 计算机硬件的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text"> 1.1.2 计算机系统结构的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text"> 1.存储程序的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-flynn%E5%88%86%E7%B1%BB"><span class="toc-text"> 2. Flynn分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 1.1.3 复杂指令集系统与精简指令集系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-cisc"><span class="toc-text"> 1. CISC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-risc"><span class="toc-text"> 2. RISC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-%E6%80%BB%E7%BA%BF"><span class="toc-text"> 1.1.4 总线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 1.2 存储器系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 1.2.1 主存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 1.随机存取存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 2.只读存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%86%85%E5%AD%98%E7%BC%96%E5%9D%80%E6%96%B9%E6%B3%95"><span class="toc-text"> 3.内存编址方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 1.2.2 辅助存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A3%81%E5%B8%A6%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 1．磁带存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AC%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 2．硬盘存储器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123-cache%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text"> 1.2.3 Cache存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1cache%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text"> 1．Cache基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text"> 2. 映射机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text"> 3. 替换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text"> 4．写操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text"> 1.3 流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#131-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%91%A8%E6%9C%9F"><span class="toc-text"> 1.3.1 流水线周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#132-%E8%AE%A1%E7%AE%97%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-text"> 1.3.2 计算流水线执行时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%90%9E%E5%90%90%E7%8E%87"><span class="toc-text"> 1.3.3 流水线的吞吐率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%8A%A0%E9%80%9F%E6%AF%94"><span class="toc-text"> 1.3.4 流水线的加速比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 第二章 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-text"> 2.1 操作系统的类型与结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#211-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 2.1.1 操作系统的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#212-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text"> 2.1.2 操作系统的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text"> 2.2 操作系统基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text"> 2.2.1 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text"> 1. 进程的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 2．进程的状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81"><span class="toc-text"> 3．挂起状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-text"> 4．进程互斥与同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%89%8D%E8%B6%8B%E5%9B%BE"><span class="toc-text"> 5. 前趋图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-text"> 6．进程调度与死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text"> 2.2.2 存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text"> 1. 页式存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text"> 2．段式存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text"> 3．段页式存储管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#223-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-text"> 2.2.3 设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text"> 1. 数据传输控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%99%9A%E8%AE%BE%E5%A4%87%E4%B8%8Espooling%E6%8A%80%E6%9C%AF"><span class="toc-text"> 2. 虚设备与SPOOLING技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#224-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text"> 2.2.4 文件管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-text"> 第六章 开发方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text"> 6.1 软件生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.2 软件开发模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.2.1 瀑布模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text"> 1. 瀑布模型的核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%80%91%E5%B8%83v%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2．瀑布V模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text"> 3．瀑布模型的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622-%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.2.2 演化模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623-%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.2.3 螺旋模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#624-%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.2.4 增量模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#625-%E6%9E%84%E4%BB%B6%E7%BB%84%E8%A3%85%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.2.5  构件组装模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B"><span class="toc-text"> 6.3 统一过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631-up%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.3.1 UP的二维模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632-up%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text"> 6.3.2 UP的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#633-up%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text"> 6.3.3 UP的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#634-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%9C%A8up%E4%B8%AD%E7%9A%84%E6%B4%BB%E5%8A%A8"><span class="toc-text"> 6.3.4 架构设计师在UP中的活动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="toc-text"> 6.4 敏捷方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#641-%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B"><span class="toc-text"> 6.4.1 极限编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9B%9B%E5%A4%A7%E4%BB%B7%E5%80%BC%E8%A7%82"><span class="toc-text"> 1．四大价值观</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8D%81%E4%BA%8C%E4%B8%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text"> 2．十二个最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#642-%E7%89%B9%E5%BE%81%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-text"> 6.4.2 特征驱动开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1fdd%E8%A7%92%E8%89%B2%E5%AE%9A%E4%B9%89"><span class="toc-text"> 1．FDD角色定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%A0%B8%E5%BF%83%E8%BF%87%E7%A8%8B"><span class="toc-text"> 2．核心过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text"> 3．最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#643-scrum"><span class="toc-text"> 6.4.3 Scrum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1scrum-%E7%9A%84%E4%BA%94%E4%B8%AA%E6%B4%BB%E5%8A%A8"><span class="toc-text"> 1．Scrum 的五个活动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2scrum-%E7%9A%84-5-%E5%A4%A7%E4%BB%B7%E5%80%BC%E8%A7%82"><span class="toc-text"> 2．Scrum 的 5 大价值观</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#644-%E6%B0%B4%E6%99%B6%E6%96%B9%E6%B3%95"><span class="toc-text"> 6.4.4 水晶方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#645-%E5%85%B6%E4%BB%96%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="toc-text"> 6.4.5 其他敏捷方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E8%BD%AF%E4%BB%B6%E9%87%8D%E7%94%A8"><span class="toc-text"> 6.5 软件重用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-%E8%BD%AF%E4%BB%B6%E9%87%8D%E7%94%A8"><span class="toc-text"> 6.5.1 软件重用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-%E6%9E%84%E4%BB%B6%E6%8A%80%E6%9C%AF"><span class="toc-text"> 6.5.2 构件技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 6.6 基于架构的软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#661-absd-%E6%96%B9%E6%B3%95%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text"> 6.6.1 ABSD 方法与生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-text"> 1. 抽象功能需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%A8%E4%BE%8B"><span class="toc-text"> 2. 用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%B4%A8%E9%87%8F%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82"><span class="toc-text"> 3．抽象的质量和业务需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%9E%B6%E6%9E%84%E9%80%89%E9%A1%B9"><span class="toc-text"> 4．架构选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E8%B4%A8%E9%87%8F%E5%9C%BA%E6%99%AF"><span class="toc-text"> 5．质量场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E7%BA%A6%E6%9D%9F"><span class="toc-text"> 6．约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#662-%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 6.6.2 基于架构的软件开发模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82"><span class="toc-text"> 1．架构需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 2．架构设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3%E5%8C%96"><span class="toc-text"> 3．架构文档化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%9E%B6%E6%9E%84%E5%A4%8D%E5%AE%A1"><span class="toc-text"> 4．架构复审</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 5．架构实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96"><span class="toc-text"> 6．架构演化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text"> 6.7 形式化方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92"><span class="toc-text"> 第七章 系统规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8F%90%E5%87%BA%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-text"> 7.1 项目的提出与选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#711-%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AB%8B%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%A8%E6%9C%BA"><span class="toc-text"> 7.1.1 项目的立项目标和动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#712-%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%80%89%E6%8B%A9%E5%92%8C%E7%A1%AE%E5%AE%9A"><span class="toc-text"> 7.1.2 项目的选择和确定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%80%89%E6%8B%A9%E6%9C%89%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E7%9A%84%E4%BA%A7%E5%93%81%E9%A1%B9%E7%9B%AE%E6%88%96%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91"><span class="toc-text"> 1．选择有核心价值的产品&#x2F;项目或开发方向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%AF%84%E4%BC%B0%E9%A1%B9%E7%9B%AE%E9%A3%8E%E9%99%A9-%E6%94%B6%E7%9B%8A%E5%92%8C%E4%BB%A3%E4%BB%B7"><span class="toc-text"> 2．评估项目风险、收益和代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E8%AF%84%E4%BC%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E6%96%BD%E6%96%B9%E5%BC%8F"><span class="toc-text"> 3．评估项目的多种实施方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%B9%B3%E8%A1%A1%E5%9C%B0%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-text"> 4．平衡地选择适合的方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#713-%E9%A1%B9%E7%9B%AE%E6%8F%90%E5%87%BA%E5%92%8C%E9%80%89%E6%8B%A9%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text"> 7.1.3 项目提出和选择的结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%8E%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90"><span class="toc-text"> 7.2 可行性研究与效益分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text"> 7.2.1 可行性研究的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%BB%8F%E6%B5%8E%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-text"> 1．经济可行性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%8A%80%E6%9C%AF%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-text"> 2．技术可行性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%B3%95%E5%BE%8B%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-text"> 3．法律可行性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%89%A7%E8%A1%8C%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-text"> 4．执行可行性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%96%B9%E6%A1%88%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text"> 5．方案的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722-%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90"><span class="toc-text"> 7.2.2 成本效益分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%A1%B9%E7%9B%AE%E5%8F%AF%E8%83%BD%E6%B6%89%E5%8F%8A%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text"> 1．项目可能涉及的成本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%A1%B9%E7%9B%AE%E5%8F%AF%E8%83%BD%E6%B6%89%E5%8F%8A%E7%9A%84%E6%94%B6%E7%9B%8A"><span class="toc-text"> 2．项目可能涉及的收益</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%8C%87%E6%A0%87%E5%92%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-text"> 3．效益分析的若干指标和进一步的分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#723-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A"><span class="toc-text"> 7.2.3 可行性分析报告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E6%96%B9%E6%A1%88%E7%9A%84%E5%88%B6%E8%AE%A2%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-text"> 7.3 方案的制订和改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#731-%E7%A1%AE%E5%AE%9A%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-text"> 7.3.1 确定软件架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#732-%E7%A1%AE%E5%AE%9A%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E9%94%AE%E6%80%A7%E8%A6%81%E7%B4%A0%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%AE%B5%E5%85%B3%E9%94%AE%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%B4%A0"><span class="toc-text"> 7.3.2 确定实现的各种关键性要素和实现手段关键性的实现要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#733-%E5%BD%92%E7%BB%93%E7%9B%AE%E6%A0%87%E5%88%B0%E6%9C%80%E9%80%82%E5%90%88%E7%9A%84%E8%AE%A1%E7%AE%97%E4%BD%93%E7%B3%BB"><span class="toc-text"> 7.3.3 归结目标到最适合的计算体系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%96%B0%E6%97%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E6%AF%94%E8%BE%83"><span class="toc-text"> 7.4 新旧系统的分析和比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#741-%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95"><span class="toc-text"> 7.4.1 遗留系统的评价方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%90%AF%E5%8A%A8%E8%AF%84%E4%BB%B7"><span class="toc-text"> 1．启动评价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%95%86%E4%B8%9A%E4%BB%B7%E5%80%BC%E8%AF%84%E4%BB%B7"><span class="toc-text"> 2．商业价值评价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83%E8%AF%84%E4%BB%B7"><span class="toc-text"> 3．外部环境评价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%AF%84%E4%BB%B7"><span class="toc-text"> 4．应用软件评价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%88%86%E6%9E%90%E8%AF%84%E4%BB%B7%E7%BB%93%E6%9E%9C%E8%AF%84%E4%BB%B7"><span class="toc-text"> 5．分析评价结果评价</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#742-%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text"> 7.4.2 遗留系统的演化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text"> 1．淘汰策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%A7%E6%89%BF%E7%AD%96%E7%95%A5"><span class="toc-text"> 2．继承策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%94%B9%E9%80%A0%E7%AD%96%E7%95%A5"><span class="toc-text"> 3．改造策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E9%9B%86%E6%88%90%E7%AD%96%E7%95%A5"><span class="toc-text"> 4．集成策略</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text"> 第八章 系统分析与设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BD%92%E7%BB%93%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 8.1 定义问题与归结模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#811-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text"> 8.1.1 问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9C%A8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89%E4%B8%8A%E8%BE%BE%E6%88%90%E5%85%B1%E8%AF%86"><span class="toc-text"> 1．在问题定义上达成共识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%90%86%E8%A7%A3%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text"> 2．理解问题的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A1%AE%E5%AE%9A%E9%A1%B9%E7%9B%AE%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%92%8C%E7%94%A8%E6%88%B7"><span class="toc-text"> 3．确定项目干系人和用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="toc-text"> 4．定义系统的边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E7%A1%AE%E5%AE%9A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-text"> 5．确定系统实现的约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#812-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-text"> 8.1.2 问题定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%9B%AE%E6%A0%87"><span class="toc-text"> 1．目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-text"> 2．功能需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%9D%9E%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-text"> 3．非功能需求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.2 需求分析与软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#821-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="toc-text"> 8.2.1 需求分析的任务与过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%9C%80%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text"> 1．需求的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B"><span class="toc-text"> 2．需求工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text"> 3．需求分析方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#822-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.2.2 如何进行系统设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#823-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%B4%BB%E5%8A%A8"><span class="toc-text"> 8.2.3 软件设计的任务与活动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text"> 1.软件设计的两个阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%B8%BB%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-text"> 2．主要的设计方法比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.3 结构化分析与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#831-%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90"><span class="toc-text"> 8.3.1 结构化分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-text"> 1．结构化分析的工作步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE"><span class="toc-text"> 2．数据流图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%BB%86%E5%8C%96%E8%AE%B0%E5%BD%95-dfd-%E9%83%A8%E4%BB%B6"><span class="toc-text"> 3.细化记录 DFD 部件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#832-%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.3.2 结构化设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-text"> 1．概要设计与详细设计的主要任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text"> 2．结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%92%8C%E7%9B%92%E5%9B%BE"><span class="toc-text"> 3．程序流程图和盒图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4pad-%E5%92%8C-pdl"><span class="toc-text"> 4．PAD 和 PDL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#833-%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.3.3 模块设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BF%A1%E6%81%AF%E9%9A%90%E8%94%BD%E5%8E%9F%E5%88%99"><span class="toc-text"> 1．信息隐蔽原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%A8%A1%E5%9D%97%E7%8B%AC%E7%AB%8B%E6%80%A7%E5%8E%9F%E5%88%99"><span class="toc-text"> 2．模块独立性原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.4 面向对象的分析与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#841-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text"> 8.4.1 面向对象的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-text"> 1．对象和类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B3%9B%E5%8C%96"><span class="toc-text"> 2．继承与泛化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%A4%9A%E6%80%81%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-text"> 3．多态与重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text"> 4．模板类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%B6%88%E6%81%AF%E5%92%8C%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1"><span class="toc-text"> 5．消息和消息通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#842-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-text"> 8.4.2 面向对象分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1ooaood-%E6%96%B9%E6%B3%95"><span class="toc-text"> 1．OOA&#x2F;OOD 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2booch-%E6%96%B9%E6%B3%95"><span class="toc-text"> 2．Booch 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3omt-%E6%96%B9%E6%B3%95"><span class="toc-text"> 3．OMT 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4oose-%E6%96%B9%E6%B3%95"><span class="toc-text"> 4.OOSE 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#843-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80"><span class="toc-text"> 8.4.3 统一建模语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1uml-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text"> 1．UML 是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2uml-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text"> 2．UML 的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="toc-text"> 3．用例图基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%B1%BB%E5%9B%BE%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="toc-text"> 4．类图和对象图基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E4%BA%A4%E4%BA%92%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="toc-text"> 5．交互图基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E7%8A%B6%E6%80%81%E5%9B%BE%E5%9F%BA%E7%A1%80%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-text"> 6．状态图基础状态图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E6%B4%BB%E5%8A%A8%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="toc-text"> 7．活动图基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E6%9E%84%E4%BB%B6%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="toc-text"> 8．构件图基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E9%83%A8%E7%BD%B2%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="toc-text"> 9．部署图基础</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.5 用户界面设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#851-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text"> 8.5.1 用户界面设计的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#852-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-text"> 8.5.2 用户界面设计过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.6 工作流设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#861-%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-text"> 8.6.1 工作流设计概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#862-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 8.6.2 工作流管理系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E7%AE%80%E5%8D%95%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.7 简单分布式计算机应用系统的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 8.8 系统运行环境的集成与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 1．集中式系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 2．分布式系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3cs-%E7%BB%93%E6%9E%84"><span class="toc-text"> 3．C&#x2F;S 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%A4%9A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text"> 4．多层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5internet-intranet-%E5%92%8C-extranet"><span class="toc-text"> 5.Internet、Intranet 和 Extranet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%B8%A1%E8%AE%A1%E5%88%92"><span class="toc-text"> 8.9 系统过渡计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%9B%B4%E6%8E%A5%E8%BF%87%E6%B8%A1"><span class="toc-text"> 1．直接过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%B9%B6%E8%A1%8C%E8%BF%87%E6%B8%A1"><span class="toc-text"> 2．并行过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%98%B6%E6%AE%B5%E8%BF%87%E6%B8%A1"><span class="toc-text"> 3．阶段过渡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 第九章 软件架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-text"> 9.1 软件架构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#911-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 9.1.1 软件架构的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#912-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text"> 9.1.2 软件架构的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#913-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 9.1.3 架构的模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text"> 9.2 架构需求与软件质量属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text"> 9.2.1 软件质量属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E8%BF%90%E8%A1%8C%E6%9C%9F%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text"> 1．运行期质量属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%BC%80%E5%8F%91%E6%9C%9F%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text"> 2.开发期质量属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922-6%E4%B8%AA%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 9.2.2 6个质量属性及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%8F%AF%E7%94%A8%E6%80%A7%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%88%98%E6%9C%AF"><span class="toc-text"> 1．可用性及其实现战术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text"> 1. 可用性的描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%AF%E7%94%A8%E6%80%A7%E6%88%98%E6%9C%AF"><span class="toc-text"> 2. 可用性战术</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%88%98%E6%9C%AF"><span class="toc-text"> 2．可修改性及其实现战术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text"> 1. 可修改性的描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7%E6%88%98%E6%9C%AF"><span class="toc-text"> 2. 可修改性战术</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%80%A7%E8%83%BD%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%88%98%E6%9C%AF"><span class="toc-text"> 3．性能及其实现战术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text"> 1. 性能的描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%80%A7%E8%83%BD%E6%88%98%E6%9C%AF"><span class="toc-text"> 2. 性能战术</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%88%98%E6%9C%AF"><span class="toc-text"> 4．安全性及其实现战术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text"> 1. 安全性的描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E6%80%A7%E6%88%98%E6%9C%AF"><span class="toc-text"> 2. 安全性战术</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%88%98%E6%9C%AF"><span class="toc-text"> 5．可测试性及其实现战术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text"> 1. 可测试性的描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7%E6%88%98%E6%9C%AF"><span class="toc-text"> 2. 可测试性战术</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E6%98%93%E7%94%A8%E6%80%A7%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%88%98%E6%9C%AF"><span class="toc-text"> 6．易用性及其实现战术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%98%93%E7%94%A8%E6%80%A7%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text"> 1. 易用性的描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%98%93%E7%94%A8%E6%80%A7%E6%88%98%E6%9C%AF"><span class="toc-text"> 2. 易用性战术</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-text"> 9.3 软件架构风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#931-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%88%86%E7%B1%BB"><span class="toc-text"> 9.3.1 软件架构风格分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#932-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC"><span class="toc-text"> 9.3.2 数据流风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%B9%E5%A4%84%E7%90%86%E5%BA%8F%E5%88%97"><span class="toc-text"> 1. 批处理序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%A1%E9%81%93%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text"> 2. 管道和过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%B9%E5%A4%84%E7%90%86%E5%BA%8F%E5%88%97%E9%A3%8E%E6%A0%BC%E4%B8%8E%E7%AE%A1%E9%81%93%E8%BF%87%E6%BB%A4%E5%99%A8%E9%A3%8E%E6%A0%BC%E5%AF%B9%E6%AF%94"><span class="toc-text"> 3. 批处理序列风格与管道过滤器风格对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#933-%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC"><span class="toc-text"> 9.3.3 调用&#x2F;返回风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-text"> 1. 主程序&#x2F;子程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC"><span class="toc-text"> 2. 面向对象风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-text"> 3. 层次结构风格</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/08/07/eI1UWd.jpg"></div><div class="author-info__name text-center">Lufer</div><div class="author-info__description text-center">新的一天开始啦</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">17</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">大佬们</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yuque.com/grace-gu">Grace</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://1ogisk.cn/">Logik</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://legume.ltd">豆哥</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://esportnosave.cn/">EsportsNoSave</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Lufer</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">系统架构设计师教程(施工中)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">94.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 277 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="第一章-计算机组成与体系结构"><a class="markdownIt-Anchor" href="#第一章-计算机组成与体系结构"></a> 第一章 计算机组成与体系结构</h1>
<h2 id="11-计算机系统组成"><a class="markdownIt-Anchor" href="#11-计算机系统组成"></a> 1.1 计算机系统组成</h2>
<h3 id="111-计算机硬件的组成"><a class="markdownIt-Anchor" href="#111-计算机硬件的组成"></a> 1.1.1 计算机硬件的组成</h3>
<p>  计算机系统由<code>运算器</code>，<code>控制器</code>，<code>存储器</code>，<code>输入设备</code>，<code>输出设备</code>五部分组成。</p>
<ol>
<li>控制器<br />
  控制器是分析和执行指令的部件，也是统一指挥并控制计算机各部件协调工作的中心部件，所依据的是机器指令。<br />
  控制器的组成包含：
<ul>
<li>程序计数器<code>PC</code>：存储P下一条要执行指令的地址。</li>
<li>指令寄存器<code>IR</code>：存储即将执行的指令。</li>
<li>指令译码器<code>ID</code>：对指令中的操作码字段进行分析解释。</li>
<li>时序部件：提供时序控制信号。</li>
</ul>
</li>
<li>运算器<br />
  运算器也称为算术逻辑单元（ArithmeticandLogicUnit，ALU），其主要功能是在控制器的控制下完成各种算术运算和逻辑运算。<br />
  运算器的组成包含：
<ul>
<li>算术逻辑单元<code>ALU</code>：数据的算术运算和逻辑运算。</li>
<li>累加寄存器<code>AC</code>：通用寄存器，为ALU提供一个工作区，用于暂存数据。</li>
<li>数据缓冲寄存器<code>DR</code>：写内存时，暂存指令或数据。</li>
<li>状态条件寄存器<code>PSW</code>：存状态标志与控制标志（争议点：也有将其归为控制器的）。</li>
</ul>
</li>
<li>主存储器<br />
  主存储器也称为内存储器（通常简称为“内存”或“主存”）。存储现场操作的信息与中间结果，包括机器指令和数据。</li>
<li>辅助存储器<br />
  辅助存储器也称为外存储器，通常简称为外存或辅存。存储需要长期保存的各种信息。</li>
<li>输入设备<br />
  输入设备的任务是把人们编好的程序和原始数据送到计算机中去,并且将它们转换成计算机内部所能识别和接受的信息方式。按输入信息的形态可分为字符（包括汉字）输入、图形输入、图像输入及语音输入等。目前，常见的输入设备有键盘、鼠标、扫描仪等。</li>
<li>输出设备<br />
  输出设备的任务是将计算机的处理结果以人或其他设备所能接受的 形式送出计算机。目前，最常用的输出设备是打印机和显示器。有些设备既可以是输入设备，同时也可以是输出设备，例如，辅助存储器、自动控制和检测系统中使用的数模转换装置等。</li>
</ol>
<h3 id="112-计算机系统结构的分类"><a class="markdownIt-Anchor" href="#112-计算机系统结构的分类"></a> 1.1.2 计算机系统结构的分类</h3>
<h4 id="1存储程序的概念"><a class="markdownIt-Anchor" href="#1存储程序的概念"></a> 1.存储程序的概念</h4>
<p>  “存储程序”由冯·诺依曼提出，是计算机的系统架构，符合存储程序概念的计算机统称为冯·诺依曼型计算机。它的基本含义有以下三点：</p>
<ul>
<li>计算机由运算器、存储器、控制器、输入设备、输出设备5部分组成。</li>
<li>计算机内部由二进制来表示指令和数据。</li>
<li>将编好的程序和数据事先存入存储器中，然后再启动计算机工作。</li>
</ul>
<h4 id="2-flynn分类"><a class="markdownIt-Anchor" href="#2-flynn分类"></a> 2. Flynn分类</h4>
<p>  1966年，Michael.J.Flynn提出根据<code>指令流</code>、<code>数据流</code>的多倍性特征对计算机系统进行分类（通常称为 Flynn 分类法）。</p>
<ul>
<li>指令流：指机器执行的指令序列</li>
<li>数据流：指由指令流调用的数据序列，包括输入数据和中间结果，但不包括输出数据。</li>
</ul>
<p>  Flynn根据不同的指令流-数据流组织方式，把计算机系统分成以下四类：</p>
<ol>
<li>单指令流单数据流（Single Instruction stream and Single Data stream，<code>SISD</code>）<br />
  SISD其实就是传统的顺序执行的单处理器计算机，其指令部件每次只对一条指令进行译码，并只对一个操作部件分配数据。</li>
<li>单指令流多数据流（Single Instruction stream and Multiple Data stream，<code>SIMD</code>）<br />
  SIMD以并行处理机（矩阵处理机）为代表，并行处理机包括多个重复的处理单元，由单一指令部件控制，按照同一指令流的要求为它们分配各自所需的不同数据。</li>
<li>多指令流单数据流（Multiple Instruction stream and Single Data stream，<code>MISD</code>）<br />
  MISD具有多个处理单元，按多条不同指令的要求对同一数据流及其中间结果进行不同的处理。一个处理单元的输出又作为另一个处理单元的输入。这类系统实际上很少见到。有文献把流水线看作多个指令部件，称流水线计算机是 MISD。</li>
<li>多指令流多数据流（Multiple Instruction stream and Multiple Data stream，<code>MIMD</code>）<br />
  MIMD是指能实现作业、任务、指令等各级全面并行的多机系统。如多核处理器、多处理机等。</li>
</ol>
<h3 id="113-复杂指令集系统与精简指令集系统"><a class="markdownIt-Anchor" href="#113-复杂指令集系统与精简指令集系统"></a> 1.1.3 复杂指令集系统与精简指令集系统</h3>
<p>  一个处理器支持的指令和指令的字节级编码成为其指令集体系结构，有CISC和RISC两种发展途径。</p>
<h4 id="1-cisc"><a class="markdownIt-Anchor" href="#1-cisc"></a> 1. CISC</h4>
<p>  CISC(Complex Instruction Set Computer)全称是复杂指令系统计算机，它的基本思想是进一步增强其原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能。<code>目前使用的绝大多数计算机都属于CISC类型</code>。</p>
<p>  CSIC的特点如下：</p>
<ol>
<li>指令数量众多<br />
  指令系统拥有大量的指令，通常有 100～250 条。</li>
<li>指令使用频率相差悬殊<br />
  最常使用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。而大部分复杂指令却很少使用。</li>
<li>支持多种寻址方式<br />
  支持的寻址方式通常为 5～20 种。</li>
<li>变长的指令<br />
  指令长度不是固定的，变长的指令增加指令译码电路的复杂性。</li>
<li>指令可以对主存单元中的数据直接进行处理<br />
  典型的 CISC 通常都有指令能够直接对主存单元中的数据进行处理，<code>但其执行速度较慢</code>。</li>
<li>以微程序控制为主<br />
  CISC的指令系统很复杂，难以用硬布线逻辑（组合逻辑）电路实现控制器，通常采用微程序控制。</li>
</ol>
<h4 id="2-risc"><a class="markdownIt-Anchor" href="#2-risc"></a> 2. RISC</h4>
<p>  RISC(Reduced Instruction Set Computer)全称是精简指令系统计算机。它的基本思想是通过减少指令总数和简化指令功能降低硬件设计的复杂度，使指令能单周期运行，并通过优化编译提高指令的执行速度，采用硬布线逻辑优化编译程序。</p>
<p>  RISC的特点如下：</p>
<ol>
<li>指令数量少<br />
  优先选取使用频率最高的一些简单指令和一些常用指令，避免使用复杂指令。只提供了LOAD（从存储器中读数）和STORE（把数据写入存储器）两条指令对存储器操作，其余所有的操作都在 CPU 的寄存器之间进行。</li>
<li>指令的寻址方式少<br />
  通常只支持寄存器寻址方式、立即数寻址方式和相对寻址方式。</li>
<li>指令长度固定，指令格式种类少<br />
  因为 RISC 指令数量少、格式少、相对简单，其指令长度固定，指令之间各字段的划分比较一致，译码相对容易。</li>
<li>以硬布线逻辑控制为主<br />
  为了提高操作的执行速度，通常采用硬布线逻辑（组合逻辑）来构建控制器。</li>
<li>单周期指令执行<br />
  因为简化了指令系统，很容易利用流水线技术，使得大部分指令都能在一个机器周期内完成。少数指令可能会需要多周期，例如LOAD/STORE 指令因为需要访问存储器，其执行时间就会长一些。</li>
<li>优化的编译器<br />
  RISC的精简指令集使编译工作简单化。因为指令长度固定、格式少、寻址方式少，编译时不必在具有相似功能的许多指令中进行选择，也不必为寻址方式的选择而费心，同时易于实现优化，从而可以生成高效率执行的机器代码。</li>
<li>CPU中的通用寄存器数量多<br />
  一般在32个以上，有的可达上千个。</li>
</ol>
<h3 id="114-总线"><a class="markdownIt-Anchor" href="#114-总线"></a> 1.1.4 总线</h3>
<p>  总线是一组能为多个部件分时共享的公共信息传送线路。共享是指总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组公共线路传送；分时是指同一时刻只允许有一个部件向总线发送信息，如果出现两个或两个以上部件同时向总线发送信息，势必导致信号冲突。当然，在同一时刻，允许多个部件同时从总线上接收相同的信息。<br />
  按总线相对于 CPU 或其他芯片的位置可分为<code>内部总线</code>和<code>外部总线</code>两种。在 CPU 内部，寄存器之间和算术逻辑部件ALU与控制部件之间传输数据所用的总线称为内部总线；外部总线是指CPU与内存RAM、ROM和输入/输出设备接口之间进行通信的通路。由于CPU通过总线实现程序取指令、内存/外设的数据交换，在 CPU 与外设一定的情况下，<code>总线速度是制约计算机整体性能的最大因素</code>。<br />
  按总线功能来划分，又可分为<code>地址总线</code>、<code>数据总线</code>、<code>控制总线</code>三类，人们通常所说的总线都包括这三个组成部分，地址总线用来传送地址信息，数据总线用来传送数据信息，控制总线用来传送各种控制信号。</p>
<h2 id="12-存储器系统"><a class="markdownIt-Anchor" href="#12-存储器系统"></a> 1.2 存储器系统</h2>
<p>  传统的存储器系统一般分为<code>高速缓冲存储器（Cache）</code>、<code>主存</code>、<code>辅存</code>三级。主存可由CPU直接访问，存取速度快，但容量较小，一般用来存放当前正在执行的程序和数据。辅存设置在主机外部，它的存储容量大，价格较低，但存取速度较慢，一般用来存放暂时不参与运行的程序和数据，CPU 不可以直接访问辅存，辅存中的程序和数据在需要时才传送到主存，因此它是主存的补充和后援。当 CPU 速度很高时，为了使访问存储器的速度能与 CPU 的速度相匹配，又在主存和 CPU 间增设了一级 Cache。Cache 的存取速度比主存更快，但容量更小，用来存放当前最急需处理的程序和数据，以便快速地向 CPU 提供指令和数据。因此，计算机采用多级存储器体系，确保能够获得尽可能高的存取速率，同时保持较低的成本。<br />
  存储器中数据常用的存取方式有<code>顺序存取</code>、<code>直接存取</code>、<code>随机存取</code>和<code>相联存取</code>四种。</p>
<ol>
<li>顺序存取<br />
  存储器的数据以记录的形式进行组织。对数据的访问必须按特定的线性顺序进行。磁带存储器采用顺序存取的方式。</li>
<li>直接存取<br />
  与顺序存取相似，直接存取也使用一个共享的读写装置对所有的数据进行访问。但是，每个数据块都拥有唯一的地址标识，读写装置可以直接移动到目的数据块所在位置进行访问。存取时间也是可变的。磁盘存储器采用直接存取的方式。</li>
<li>随机存取<br />
  存储器的每一个可寻址单元都具有自己唯一的地址和读写装置，系统可以在相同的时间内对任意一个存储单元的数据进行访问，而与先前的访问序列无关。主存储器采用随机存取的方式。</li>
<li>相联存取<br />
  相联存取也是一种随机存取的形式，但是选择某一单元进行读写是取决于其内容而不是其地址。与普通的随机存取方式一样，每个单元都有自己的读写装置，读写时间也是一个常数。使用相联存取方式，可以对所有的存储单元的特定位进行比较，选择符合条件的单元进行访问。为了提高地址映射的速度，Cache 采取相联存取的方式。</li>
</ol>
<h3 id="121-主存储器"><a class="markdownIt-Anchor" href="#121-主存储器"></a> 1.2.1 主存储器</h3>
<p>  主存用来存放计算机运行期间所需要的程序和数据，CPU可直接随机地进行读/写。主存具有一定容量，存取速度较高。由于CPU要频繁地访问主存，所以主存的性能在很大程度上影响了整个计算机系统的性能。根据工艺和技术不同，主存可分为<code>随机存取存储器</code>和<code>只读存储器</code>。</p>
<h4 id="1随机存取存储器"><a class="markdownIt-Anchor" href="#1随机存取存储器"></a> 1.随机存取存储器</h4>
<p>  随机存取存储器（Random Access Memory，RAM）既可以写入也可以读出，但断电后信息无法保存，因此只能用于暂存数据。RAM又可分为DRAM（Dynamic RAM，动态RAM）和SRAM（Static RAM，静态RAM）两种，DRAM 的信息会随时间逐渐消失，因此需要定时对其进行刷新维持信息不丢失；SRAM 在不断电的情况下信息能够一直保持而不会丢失。DRAM 的密度大于 SRAM 且更加便宜，但 SRAM 速度快，电路简单（不需要刷新电路），然而容量小，价格高。</p>
<h4 id="2只读存储器"><a class="markdownIt-Anchor" href="#2只读存储器"></a> 2.只读存储器</h4>
<p>  只读存储器（Read Only Memory，ROM）可以看作 RAM 的一种特殊形式，其特点是存储器的内容只能随机读出而不能写入。这类存储器常用来存放那些不需要改变的信息。由于信息一旦写入存储器就固定不变了，即使断电，写入的内容也不会丢失，所以又称为固定存储器。ROM 一般用于存放系统程序 BIOS（Basic Input Output System，基本输入输出系统）。</p>
<h4 id="3内存编址方法"><a class="markdownIt-Anchor" href="#3内存编址方法"></a> 3.内存编址方法</h4>
<p>  在计算机系统中，存储器中每个单元的位数是相同且固定的，称为存储器编址单位。不同的计算机，存储器编址的方式不同，主要有字编址和字节编址。<br />
  内存一般以字节（8 位）为单位，或者以字为单位（字的长度可大可小，例如 16 位或者 32 位等，在这类试题中，一般会给出字的大小）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，内存地址从 AC000H 到 C7FFFH</span><br><span class="line">则共有C7FFFFH-AC000H+1&#x3D;1C000H 个地址单元</span><br><span class="line"></span><br><span class="line">转换为10进制则有 </span><br><span class="line"> 12*16^3+1*16^4</span><br><span class="line">&#x3D;12*2^12+1*2^16</span><br><span class="line">&#x3D;12*2^2KB+1*2^6KB</span><br><span class="line">&#x3D;112KB</span><br><span class="line"></span><br><span class="line">如果该内存地址按字（16bit）编址，则共有 112KB*16 位。</span><br><span class="line">假设该内存由 28 片存储器芯片构成，已知构成此内存的芯片每片有 16KB 个存储单元，则该芯片每个存储单元存储</span><br><span class="line">（112KB*16）&#x2F;（28*16KB）&#x3D;4 位。</span><br></pre></td></tr></table></figure>
<h3 id="122-辅助存储器"><a class="markdownIt-Anchor" href="#122-辅助存储器"></a> 1.2.2 辅助存储器</h3>
<h4 id="1磁带存储器"><a class="markdownIt-Anchor" href="#1磁带存储器"></a> 1．磁带存储器</h4>
<p>  磁带存储器是一种顺序存取的设备，其特点包括：存取时间较长，但存储容量大，便于携带，价格便宜。磁带应用的场景越来越少，目前主要用于资料的归档保存。</p>
<h4 id="2硬盘存储器"><a class="markdownIt-Anchor" href="#2硬盘存储器"></a> 2．硬盘存储器</h4>
<p>  在硬盘中，信息分布呈以下层次：<code>记录面</code>、<code>圆柱面</code>、<code>磁道</code>和<code>扇区</code>，如图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rg5IJJ"><img src="https://s3.ax1x.com/2020/12/24/rg5IJJ.png" alt="硬盘信息分布示意图" /></a></p>
<p>  一台硬盘驱动器中有多个磁盘片，每个盘片有两个记录面，每个记录面对应一个磁头，所以<code>记录面号就是磁头号</code>，如图中（a）所示。<br />
  所有的磁头安装在一个公用的传动设备或支架上，磁头一致地沿盘面径向移动，<code>单个磁头不能单独地移动</code>。在记录面上，一条条磁道形成一组同心圆，最外圈的磁道为 0 号，往内则磁道号逐步增加，如图中（b）所示。通常将一条磁道划分为若干个段，每个段称为一个扇区或扇段，每个扇区存放一个定长信息块（例如，512 个字节）。一条磁道划分多少扇区，每个扇区可存放多少字节，一般由操作系统决定。磁道上的扇区编号从 1 开始，不像磁头或柱面编号从 0开始。<br />
  在一个盘组中，各记录面上相同编号（位置）的各磁道构成一个柱面，如图中（c）所示。若每个磁盘片有 m 个磁道，则该硬盘共有 m 个柱面。引入柱面的概念是为了提高硬盘的存储速度。当主机要存入一个较大的文件时，若一条磁道存不完，就需要存放在几条磁道上。这时，应首先将一个文件尽可能地存放在同一柱面中。如果仍存放不完，再存入相邻的柱面内。<br />
  在磁盘上进行信息的读写时，首先需要定位到目标磁道，这个过程称之为<code>寻道</code>，寻道所消耗的时间称为<code>寻道时间</code>。定位到目标磁道后，需要定位到目标扇区，此过程通过旋转盘片完成，平均旋转<code>半圈</code>可到目标位置。故磁盘访问时间为：<code>磁盘访问时间（存取时间） = 寻道时间+旋转延迟时间</code></p>
<h3 id="123-cache存储器"><a class="markdownIt-Anchor" href="#123-cache存储器"></a> 1.2.3 Cache存储器</h3>
<p>  Cache 通常采用相联存储器（ContentAddressable Memory，CAM）。CAM 是一种基于数据内容进行访问的存储设备。当对其写入数据时，CAM 能够自动选择一个未用的空单元进行存储；当要读出数据时，不是给出其存储单元的地址，而是直接给出该数据或者该数据的一部分内容，CAM 对所有存储单元中的数据同时进行比较，并标记符合条件的所有数据以供读取。由于比较是同时、并行进行的，所以，这种基于数据内容进行读写的机制，其速度比基于地址进行读写的方式要快很多。</p>
<h4 id="1cache基本原理"><a class="markdownIt-Anchor" href="#1cache基本原理"></a> 1．Cache基本原理</h4>
<p>  使用 Cache 改善系统性能的依据是程序的<code>局部性原理</code>。<br />
  局部性原理是指程序在执行时呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分。相应地，它所访问的存储空间也仅局限于某个区域。<br />
  根据程序的局部性原理，可以把目前常用或将要用到的信息预先放在 Cache 中。当CPU 需要读取数据时，首先在 Cache 中查找是否有所需内容，如果有，则直接从 Cache 中读取；若没有，再从内存中读取该数据，然后同时送往 CPU 和 Cache。如果 CPU 需要访问的内容大多都能在 Cache 中找到（称为<code>访问命中</code>），则可以大大提高系统性能。<br />
  如果以 h 代表对 Cache 的访问命中率（“1-h”称为失效率，或者称为未命中率），t1 表示 cache 的周期时间，t2 表示内存的周期时间，以读操作为例，使用“Cache+主存储器”的系统的平均周期为 t3。则：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mn>3</mn><mo>=</mo><mi>t</mi><mn>1</mn><mo>∗</mo><mi>h</mi><mo>+</mo><mi>t</mi><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t3=t1*h+t2*(1-h)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></span></p>
<p>  系统的平均存储周期与命中率有很密切的关系，命中率的提高即使很小也能导致性能上的较大改善。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设某计算机主存的读&#x2F;写时间为 l00ns，有一个指令和数据合一的Cache</span><br><span class="line">已知该Cache的读&#x2F;写时间为 10ns，取指令的命中率为 98%，取数的命中率为 95%</span><br><span class="line">在执行某类程序时，约有 1&#x2F;5 指令需要存&#x2F;取一个操作数。</span><br><span class="line">假设指令流水线在任何时候都不阻塞，则设置 Cache 后，每条指令的平均访存时间约为：</span><br><span class="line">(2%*100ns+98%*10ns)+1&#x2F;5*(5%*100ns+95%*10ns)&#x3D;14.7ns</span><br></pre></td></tr></table></figure>
<h4 id="2-映射机制"><a class="markdownIt-Anchor" href="#2-映射机制"></a> 2. 映射机制</h4>
<p>  当 CPU 发出访存请求后，存储器地址先被送到 Cache 控制器以确定所需数据是否已在 Cache 中，若命中则直接对 Cache 进行访问。这个过程称为 Cache 的地址映射（映像）。<br />
  在 Cache 的地址映射中，主存和 Cache 将均分成容量相同的块（页）。常见的映射方法有<code>直接映射</code>、<code>全相联映射</code>和<code>组相联映射</code>。</p>
<ul>
<li>直接映射</li>
</ul>
<p>  直接映射以随机存取存储器作为 Cache 存储器，硬件电路较简单。在进行映射时，主存地址被分成三个部分，从高到低依次为：区号、页号以及页内地址，如图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rgq5Bn"><img src="https://s3.ax1x.com/2020/12/24/rgq5Bn.png" alt="直接映射方式的主存地址" /></a></p>
<p>  在本例中，内存容量为 1GB，Cache 容量为 8MB，页面的大小为 512KB。直接映射中先分区，再分页。一个区的大小就是 Cache 容量的大小，所以一共分：1GB/8MB=128 个区，区号7位。每个区分：8MB/512KB=16个页，所以页号为 4 位。<br />
  在直接映射方式中，每个主存页只能复制到某一固定的 Cache 页中，如下图所示。直接映射方式的映射规律是：主存中每个区的第 0 页，只能进入到 Cache 的第 0 页。即：若当前时刻 Cache 中 0 号页已被占据，而 1-15 号页空闲，现在要将 1 区第 0 页（即内存的 16 页）调入 Cache 是会发生冲突的。所以直接映射的块冲突率非常高。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rgLwCT"><img src="https://s3.ax1x.com/2020/12/24/rgLwCT.png" alt="直接映射方式" /></a></p>
<p>  由于每个区的 N 号页，都必须进入到 Cache 的 N 号页，所以只需要记录区号即可。</p>
<ul>
<li>全相联映射</li>
</ul>
<p>  全相联映射使用相联存储器组成Cache存储器。在全相联映射方式中，主存的每一页可以映射到Cache的任一页。如果淘汰Cache中某一页的内容，则可调入任一主存页的内容，因而较直接映射方式灵活。<br />
  在全相联映射方式中，主存地址分为两个部分，分别为地址部分（主存页标记）和数据部分（页内地址）。数据部分用于存放数据，而地址部分则存放该数据的存储器地址。如图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rgjuU1"><img src="https://s3.ax1x.com/2020/12/24/rgjuU1.png" alt="主存储示例" /></a></p>
<p>  当进行映射时，在我们给定的例子中，当程序访存时，则高 11 位给出主存页号，低19 位给出页内地址。因为每个 Cache 页可映射到 2048 个主存页中的任一页，所以每页的Cache 标记也需要 11 位，以表明它现在所映射的主存页号。因此，Cache 标记信息位数增加，比较逻辑成本随之增加。<br />
  在全相联映射方式中，主存地址不能直接提取 Cache 页号，而是需要将主存页标记与Cache 各页的标记逐个比较，直到找到标记符合的页（访问 Cache 命中），或者全部比较完后仍无符合的标记（访问 Cache 失败）。因此<code>这种映射方式速度很慢，失掉了高速缓存的作用，这是全相联映射方式的最大缺点</code>。如果让主存页标记与各 Cache 标记同时比较，则成本又太高。全相联映射方式因比较器电路难于设计和实现，只适用于小容量 Cache。</p>
<ul>
<li>组相联映射</li>
</ul>
<p>  组相联映射（页组映射）介于直接映射和全相联映射之间，是这两种映射的一种折衷方案。全相联映射方式以页为单位，可自由映射，没有固定的对应关系。直接映射方式中，主存分组，主存组内的各页与 Cache 的页之间采取的是固定的映射关系，但各组均可映射到Cache 中。在组相联映射方式中，主存与 Cache 都分组，主存中一个组内的页数与 Cache 的分组数相同，如图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rgjLI1"><img src="https://s3.ax1x.com/2020/12/24/rgjLI1.png" alt="组相连映射方式" /></a></p>
<p>  在上图给出的例子中，主存分 128 个区，每个区 8 个组，每个组 2 个页。组相联映射方式的主存地址组织如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rgvGWV"><img src="https://s3.ax1x.com/2020/12/24/rgvGWV.png" alt="组相联映射主存地址示例" /></a></p>
<p>  组相联映射的规则是：主存中的组与 Cache 的组形成直接映射关系，而每个组内的页是全相联映射关系。如主存 1 区 0 页，他在 0 组中，所以只能进入 Cache 的 0 组中，至于进入到 Cache 的 0 组 0 页，还是 0 组 1 页，并无强制要求，可任意放置。<br />
  在组相联映射中，Cache 中每一页的标记位长度为 8 位，因为此时除了要记录区号，还得记录组号，即区号 7 位加组号 1 位等于 8 位。<br />
  在组相联映射中，由于 Cache 中每组有若干可供选择的页，因而它在映射定位方面较直接映射方式灵活；每组页数有限，因此付出的代价不是很大，可以根据设计目标选择组内页数。</p>
<h4 id="3-替换算法"><a class="markdownIt-Anchor" href="#3-替换算法"></a> 3. 替换算法</h4>
<p>  当 Cache 产生了一次访问未命中之后，相应的数据应同时读入 CPU 和 Cache。但是当Cache 已存满数据后，新数据必须替换（淘汰）Cache 中的某些旧数据。最常用的替换算法有以下三种：</p>
<ol>
<li>随机算法<br />
  这是最简单的替换算法。随机法完全不管 Cache 块过去、现在及将来的使用情况，简单地根据一个随机数，选择一块替换掉。</li>
<li>先进先出（First In and First Out，FIFO）算法<br />
  按调入 Cache 的先后决定淘汰的顺序，即在需要更新时，将最先进入 Cache 的块作为被替换的块。这种方法要求为每块做一记录，记下它们进入 Cache 的先后次序。这种方法容易实现，而且系统开销小。其缺点是<code>可能会把一些需要经常使用的程序块（如循环程序）替换掉</code>。</li>
<li>近期最少使用（Least Recently Used，LRU）算法<br />
  LRU 算法是把 CPU 近期最少使用的块作为被替换的块。这种替换方法需要随时记录 Cache 中各块的使用情况，以便确定哪个块是近期最少使用的块。LRU 算法相对合理，但实现起来比较复杂，系统开销较大。通常需要对每一块设置一个称为“年龄计数器”的硬件或软件计数器，用以记录其被使用的情况。</li>
</ol>
<h4 id="4写操作"><a class="markdownIt-Anchor" href="#4写操作"></a> 4．写操作</h4>
<p>  因为需要保证缓存在 Cache 中的数据与内存中的内容一致，相对读操作而言，Cache 的写操作比较复杂，常用的有以下几种方法。</p>
<ol>
<li>写直达（write through）<br />
  当要写 Cache 时，数据同时写回内存，有时也称为写通。当某一块需要替换时，也不必把这一块写回到主存中去，新调入的块可以立即把这一块覆盖掉。这种方法实现简单，而且能随时保持主存数据的正确性，但<code>可能增加多次不必要的主存写入</code>，会降低存取速度。</li>
<li>写回（write back）<br />
  CPU 修改 Cache 的某一块后，相应的数据并不立即写入内存单元，而是当该块从 Cache 中被淘汰时，才把数据写回到内存中。在采用这种更新策略的Cache块表中，一般有一个标志位，当一块中的任何一个单元被修改时，标志位被置“1”。<br />
  在需要替换掉这一块时，如果标志位为“1”，则必须先把这一块写回到主存中去之后，才能再调入新的块；如果标志位为“0”，则这一块不必写回主存，只要用新调入的块覆盖掉这一块即可。这种方法的优点是<code>操作速度快</code>，缺点是<code>因主存中的字块未随时修改而有可能出错</code>。</li>
<li>标记法<br />
  对 Cache 中的每一个数据设置一个有效位。当数据进入 Cache 后，有效位置“1”；而当 CPU 要对该数据进行修改时，数据只需写入内存并同时将该有效位置“0”。当要从 Cache 中读取数据时需要测试其有效位，若为“l”则直接从 Cache 中取数，否则，从内存中取数。</li>
</ol>
<h2 id="13-流水线"><a class="markdownIt-Anchor" href="#13-流水线"></a> 1.3 流水线</h2>
<p>  流水线技术把一个任务分解为若干顺序执行的子任务，不同的子任务由不同的执行机构负责执行，而这些机构可以<code>同时并行工作</code>。在任一时刻，任一任务只占用其中一个执行机构，这样就可以实现多个任务的重叠执行，以提高工作效率。</p>
<h3 id="131-流水线周期"><a class="markdownIt-Anchor" href="#131-流水线周期"></a> 1.3.1 流水线周期</h3>
<p>  流水线应用过程中，会将需要处理的工作分为 N 个阶段，<code>最耗时的那一段所消耗的时间为流水线周期</code>。如：使用流水线技术执行 100 条指令，每条指令取指 2ms，分析 4ms，执行 1ms，则流水线周期为 4ms。</p>
<h3 id="132-计算流水线执行时间"><a class="markdownIt-Anchor" href="#132-计算流水线执行时间"></a> 1.3.2 计算流水线执行时间</h3>
<p>  延续上面的场景，将 1 个任务的执行过程可分成 N 个阶段，假设每个阶段完成时间为 t，则完成该任务所需的时间即为 Nt。若以传统的方式，则完成 k 个任务所需的时间是kNt；而使用流水线技术执行，且花费的时间是 Nt+(k-1)t。也就是说，除了第 1 个任务需要完整的时间外，其他都通过并行，节省下了大量的时间。所以流水线的执行时间可通俗的表达为：</p>
<blockquote>
<p>流水线执行时间=第 1 条指令的执行时间+（n-1）*流水线周期<br />
注：n 代表需要处理的任务数量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    在考试时，又需要特别注意一个细节问题。</span><br><span class="line">    流水线的执行时间计算，其实进一步可以分理论情况与实践情况两种不同的处理方式。</span><br><span class="line">例：</span><br><span class="line">    某计算机系统，一条指令的执行需要经历取指（2ms）、分析（4ms）、执行（1ms）三个阶段，现要执行 100 条指令，利用流水线技术需要多长时间?</span><br><span class="line">    理论上来说，1 条指令的执行时间为：2ms+4ms+1ms&#x3D;7ms。</span><br><span class="line">    所以：理论流水线执行时间&#x3D;2ms+4ms+1ms+(100-1)*4&#x3D;403ms。</span><br><span class="line">    而实际上，真正做流水线处理时，考虑到处理的复杂性，会将指令的每个执行阶段的时间都统一为流水线周期，即 1 条指令的执行时间为：4ms+4ms+4ms&#x3D;12ms。 </span><br><span class="line">    所以：实际流水线执行时间&#x3D;4ms+4ms+4ms+(100-1)*4&#x3D;408ms。</span><br><span class="line"></span><br><span class="line">    考试时 80%以上的概率采用理论公式计算，所以考试时需要以理论公式计算，若计算的结果无正确选项才考虑采用实际公式计算。</span><br></pre></td></tr></table></figure>
<h3 id="133-流水线的吞吐率"><a class="markdownIt-Anchor" href="#133-流水线的吞吐率"></a> 1.3.3 流水线的吞吐率</h3>
<p>  流水线的吞吐率（Though Put rate，TP）是指在<code>单位时间</code>内<code>流水线所完成的任务数量或输出的结果数量</code>。有些文献也称为平均吞吐率、实际吞吐率。<br />
  计算流水线吞吐率的最基本的公式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><msub><mi>T</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">TP=\frac {n} {T_k} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9435600000000002em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>  其中n为任务数量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">T_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是处理完成n个任务所用的时间</p>
<p>  流水线的最大吞吐率为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{max}=\lim_{n \to \infty} \frac n {(k+n-1)\Delta t}=\frac 1 {\Delta t} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0435600000000003em;vertical-align:-0.936em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">Δ</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">n</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Δ</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h3 id="134-流水线的加速比"><a class="markdownIt-Anchor" href="#134-流水线的加速比"></a> 1.3.4 流水线的加速比</h3>
<p>  在流水线中，因为在同一时刻，有多个任务在重叠地执行，虽然完成一个任务的时间与单独执行该任务相近（甚至由于分段的缘故，可能更多一些），但是从整体上看完成多个任务所需的时间则大大减少。<br />
  完成同样一批任务，<code>不使用流水线所用的时间</code>与<code>使用流水线所用的时间</code>之比称为流水线的加速比（speedup ratio）。如果不使用流水线，即顺序执行所用的时间为 T0 ，使用流水线的执行时间为 Tk ，则计算流水线加速比的基本公式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><msub><mi>T</mi><mn>0</mn></msub><msub><mi>T</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">S=\frac {T_0} {T_k} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>  如果流水线各个流水段的执行时间都相等（设为Δt），则一条 k 段流水线完成 n 个连续任务所需要的时间为(k+n-1)Δt。如果不使用流水线，即顺序执行这 n 个任务，则所需要的时间为 nkΔt。<br />
  因此，各个流水段执行时间均相等的一条 k 段流水线完成 n 个连续任务时的实际加速比为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mi>k</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mi>k</mi></mrow><mrow><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">S=\frac {nk\Delta t} {(k+n-1)\Delta t}=\frac {nk} {k+n-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.30744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">Δ</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">Δ</span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.14077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>  这种情况下的最大加速比为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mrow><mi>n</mi><mi>k</mi></mrow><mrow><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_{max}=\lim_{n \to \infty} \frac {nk} {k+n-1}=k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.14077em;vertical-align:-0.7693300000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<h1 id="第二章-操作系统"><a class="markdownIt-Anchor" href="#第二章-操作系统"></a> 第二章 操作系统</h1>
<h2 id="21-操作系统的类型与结构"><a class="markdownIt-Anchor" href="#21-操作系统的类型与结构"></a> 2.1 操作系统的类型与结构</h2>
<h3 id="211-操作系统的定义"><a class="markdownIt-Anchor" href="#211-操作系统的定义"></a> 2.1.1 操作系统的定义</h3>
<p>  操作系统（Operating System，OS）是计算机系统中的核心系统软件，负责管理和控制计算机系统中的硬件和软件资源，合理地组织计算机工作流程和有效地利用资源，在计算机与用户之间起接口的作用。</p>
<h3 id="212-操作系统的分类"><a class="markdownIt-Anchor" href="#212-操作系统的分类"></a> 2.1.2 操作系统的分类</h3>
<p>  按照操作系统的功能划分，操作系统的基本类型主要有</p>
<ul>
<li>批处理操作系统</li>
<li>分时操作系统</li>
<li>实时操作系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>嵌入式操作系统</li>
<li>微内核操作系统</li>
</ul>
<h2 id="22-操作系统基本原理"><a class="markdownIt-Anchor" href="#22-操作系统基本原理"></a> 2.2 操作系统基本原理</h2>
<h3 id="221-进程管理"><a class="markdownIt-Anchor" href="#221-进程管理"></a> 2.2.1 进程管理</h3>
<h4 id="1-进程的概念"><a class="markdownIt-Anchor" href="#1-进程的概念"></a> 1. 进程的概念</h4>
<p>  在多道程序处理系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了<code>进程</code>。进程是资源分配和独立运行的基本单位。</p>
<h4 id="2进程的状态转换"><a class="markdownIt-Anchor" href="#2进程的状态转换"></a> 2．进程的状态转换</h4>
<p>  由进程运行的间断性，决定了进程至少具有以下三种状态：</p>
<ol>
<li>就绪状态<br />
  当进程已分配了除 CPU 以外的所有必要的资源后，只要能再获得处理机，便能立即执行，把这时的进程状态称为<code>就绪状态</code>。在一个系统中，可以有多个进程同时处于就绪状态，通常把它们排成一个队列，称为<code>就绪队列</code>。</li>
<li>执行状态<br />
  指进程已获得处理机，其程序正在执行。在单处理机系统中，只能有一个进程处于执行状态。</li>
<li>阻塞状态<br />
  指进程因发生某事件（如请求 I/O、申请缓冲空间等）而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为<code>阻塞状态</code>，有时也称为<code>等待</code>状态或<code>睡眠</code>状态。通常将处于阻塞状态的进程排成一个队列，称为<code>阻塞队列</code>。</li>
</ol>
<p>  进程的状态随着自身的推进和外界的变化而变化。例如，就绪状态的进程被进程调度程序选中进入执行状态；执行状态的进程因等待某一事件的发生转入等待状态；等待状态的进程所等待事件来到便进入就绪状态。进程的状态可以动态地相互转换，但阻塞状态的进程不能直接进入执行状态，就绪状态的进程不能直接进入阻塞状态。在任何时刻，任何进程都处于且只能处于这其中一种状态。进程状态的变化情况如下：</p>
<ol>
<li>运行态→等待态<br />
  一个进程运行中启动了外围设备，它就变成等待外围设备传输信息的状态。<br />
  进程在运行中申请资源（主存储空间及外围设备因得不到满足）时，变成等待资源状态。<br />
  进程在运行中出现了故障（程序出错或主存储器读写错误等），变成等待干预状态。</li>
<li>等待态→就绪态<br />
  外围设备工作结束后等待外围设备传输信息的进程结束等待。<br />
  等待的资源能得到满足时（另一个进程归还了资源），则等待资源者就结束等待。<br />
  故障排队后让等待干预的进程结束等待。<br />
  任何一个结束等待的进程必须先变成就绪状态，待分配到处理器后才能运行。</li>
<li>运行态→就绪态<br />
  进程用完了一个使用处理器的时间后强迫该进程暂时让出处理器。<br />
  当有更优先权的进程要运行时也迫使正在运行的进程让出处理器。<br />
  由于自身或外界原因成为等待状态的进程让出处理器时，它的状态就变成就绪状态。</li>
<li>就绪态→运行态<br />
  等待分配处理器的进程，系统按一种选定的策略从处于就绪状态的进程中选择一个进程，让它占用处理器，那个被选中的进程就变成了运行态。</li>
</ol>
<p>  可用状态转换图表示如下：<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/roqSZ8"><img src="https://s3.ax1x.com/2020/12/28/roqSZ8.png" alt="进程状态转换图" /></a></p>
<h4 id="3挂起状态"><a class="markdownIt-Anchor" href="#3挂起状态"></a> 3．挂起状态</h4>
<p>  在一些系统中，增加了一些新的进程状态，其中最重要的是挂起状态。引入挂起状态的原因有：</p>
<ol>
<li>对换的需要<br />
  为了缓和内存紧张的情况，而将内存中处于阻塞状态的进程换至外存上，使进程又处于一种有别于阻塞状态的新状态。因为即使该进程所期待的事件发生，该进程仍不具备执行条件而不能进入就绪队列，称这种状态为挂起状态。</li>
<li>终端用户的请求<br />
  当终端用户在自己的程序运行期间，发现有可疑问题时，往往希望使自己的进程暂停下来。也就是说，使正在执行的进程暂停执行，若是就绪进程，则不接受调度以便研究其执行情况或对程序进行修改。把这种静止状态也称为挂起状态。</li>
<li>父进程请求<br />
  父进程常希望挂起自己的子进程，以便考查和修改子进程，或者协调各子进程间的活动。</li>
<li>负荷调节的需要<br />
  当实时系统中的工作负荷较重，有可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统正常运行。</li>
<li>操作系统的需要<br />
  操作系统希望挂起某些进程，以便检查运行中资源的使用情况及进行记账。</li>
</ol>
<p>  综上所述，不难了解挂起状态具有以下三个属性。</p>
<ol>
<li>被挂起的进程，原来可能处于就绪状态，此时进程（被挂起）的状态称为挂起就绪；若被挂起的进程原来处于阻塞状态，此时的状态称为挂起阻塞。不论哪种状态，该进程都是不可能被调度而执行的。</li>
<li>处于挂起阻塞状态的进程，其阻塞条件与挂起条件无关；当进程所期待的事件出现后，进程虽不再被阻塞，但仍不能运行，这时，应将该进程从<code>静止阻塞</code>状态转换为<code>挂起就绪</code>状态。</li>
<li>进程可以由其自身挂起，也可由用户或操作系统等将之挂起。其目的都在于阻止进程继续运行，被挂起的进程只能用显式方式来激活，以便从挂起状态中解脱出来。</li>
</ol>
<p>  下图所示为具有挂起操作的进程状态的演变情况：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/roL4AO"><img src="https://s3.ax1x.com/2020/12/28/roL4AO.png" alt="带有挂起操作的进程状态演变图" /></a></p>
<h4 id="4进程互斥与同步"><a class="markdownIt-Anchor" href="#4进程互斥与同步"></a> 4．进程互斥与同步</h4>
<p>  进程互斥：一组并发进程中一个或多个程序段，因共享某一共有资源而导致必须以一个不允许交叉执行的单位执行。也就是说互斥是要保证临界资源在某一时刻只被一个进程访问。<code>（竞争关系）</code><br />
  进程同步：把异步环境下的一组并发进程因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程同步。也就是说进程之间是异步执行的，同步即是使各进程按一定的制约顺序和速度执行。<code>（协作关系）</code></p>
<p>  进程在并发执行中可以共享系统中的资源。但是临界资源的访问则必须互斥进行，必须有专门的同步机构来协调它们，协调准则如下：</p>
<ol>
<li>空闲让进<br />
  无进程处于临界区时，若有进程要求进入临界区则立即允许其进入。</li>
<li>忙则等待<br />
  当已有进程进入其临界区时，其他试图进入各自临界区的进程必须等待，以保证诸进程互斥地进入临界区。</li>
<li>有限等待<br />
  有若干进程要求进入临界区时，应在有限时间内使一进程进入临界区，即它们不应相互等待而谁也不进入临界区。</li>
<li>让权等待<br />
  对于等待进入临界区的进程必须释放其占有的 CPU。</li>
</ol>
<p>  信号量可以有效地实现进程的同步和互斥。在操作系统中，信号量是一个整数。当信号量大于等于 0 时，代表可供并发进程使用的资源实体数，当信号量小于零时则表示正在等待使用临界区的进程数。建立一个信号量必须说明所建信号量代表的意义和设置初值，以及建立相应的数据结构，以便指向那些等待使用该临界区的进程。<br />
  对信号量只能施加特殊的操作：P 操作和 V 操作。P 操作和 V 操作都是不可分割的原子操作，也称为原语。因此，P 原语和 V 原语执行期间不允许中断发生。<br />
  P（sem）操作的过程是将信号量 sem 值减 l，若 sem 的值成负数，则调用 P 操作的进程暂停执行，直到另一个进程对同一信号量做 V 操作。V（sem）操作的过程是将信号量sem 值加 1，若 sem 的值小于等于 0，则从相应队列（与 sem 有关的队列）中选一个进程并唤醒它。</p>
<p>  一般 P 操作与 V 操作的定义如下所述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P 操作：</span><br><span class="line">P（sem）&#123;</span><br><span class="line">    sem &#x3D; sem - 1;</span><br><span class="line">    if（sem &lt; 0）</span><br><span class="line">        进程进入等待状态；</span><br><span class="line">    else </span><br><span class="line">        继续进行；</span><br><span class="line">    &#125; </span><br><span class="line">V 操作：</span><br><span class="line">V（sem）&#123;</span><br><span class="line">    sem &#x3D; sem + 1;</span><br><span class="line">    if（sem ≤ 0）</span><br><span class="line">        唤醒队列中的一个等待进程；</span><br><span class="line">    else </span><br><span class="line">        继续进行；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>  要用 P，V 操作实现进程同步，需要引进私用信号量。私用信号量只与制约进程和被制约进程有关，而不是与整组并发进程相关。与此相对，进程互斥使用的信号量为公用信号量。首先为各并发进程设置私用信号量，然后为私用信号量赋初值，最后利用 P，V 原语和私用信号量规定各进程的执行顺序。</p>
<h4 id="5-前趋图"><a class="markdownIt-Anchor" href="#5-前趋图"></a> 5. 前趋图</h4>
<p>  前趋图是一个由结点和有向边构成的有向无循环图。该图通常用于表现事务之间先后顺序的制约关系。图中的每个结点可以表示一个语句、一个程序段或是一个进程，结点间的有向边表示两个结点之间存在的前趋关系。</p>
<p>  例如在计算机中，经常采用流水线方式执行指令，每一条指令都可以分解为取指、分析和执行三步。取指操作为 Ai，分析操作为 Bi 和执行操作为 Ci(i=1,2,3)。如下图所示为三个任务各程序段并发执行的前驱图。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rozRud"><img src="https://s3.ax1x.com/2020/12/28/rozRud.png" alt="前趋图示例" /></a></p>
<p>  图中 A1 没有前趋结点，称为开始结点，它不受任何制约，可以直接执行；而 B1 与 A2只能在 A1 执行完成之后才能开始，而 B2 必须在 B1 与 A2 完成之后才能开始；C3 没有后继结点，称为终止结点。</p>
<p>  在前趋图中，执行先后顺序的制约关系可分为两种：<code>直接制约</code>和<code>间接制约</code>。<br />
  <code>直接制约</code>通常是指一个操作中，多个步骤之间的制约关系，也可以说是“同步的进程之间的制约关系”。如上图中的A1、B1、C1 是一条指令的取指、分析、执行的三个步骤，所以它们之间的关系是直接制约。<br />
  <code>间接制约</code>通常是指多个操作之间相同步骤的制约关系，也可以说是“互斥的进程之间的制约关系”。如上图中的A1、A2、A3 之间就存在间接制约的关系。</p>
<h4 id="6进程调度与死锁"><a class="markdownIt-Anchor" href="#6进程调度与死锁"></a> 6．进程调度与死锁</h4>
<p>  进程调度即处理器调度（又称上下文转换），它的主要功能是确定在什么时候分配处理器，并确定分给哪一个进程，即让正在执行的进程改变状态并转入就绪队列的队尾，再由调度原语将就绪队列的队首进程取出，投入执行。</p>
<p>  引起进程调度的原因有以下几类：</p>
<ol>
<li>正在执行的进程执行完毕。</li>
<li>执行中的进程自己调用阻塞原语将自己阻塞起来进入睡眠状态。</li>
<li>执行中的进程调用了 P 原语操作，从而因资源不足而阻塞；或调用 V 原语操作激活了等待资源的进程队列。</li>
<li>在分时系统中，当一进程用完一个时间片。</li>
<li>就绪队列中某进程的优先级变得高于当前执行进程的优先级，也将引起进程调度。</li>
</ol>
<p>  进程调度的方式有两类：<code>剥夺方式</code>与<code>非剥夺方式</code>。<br />
  所谓非剥夺方式是指，一旦某个作业或进程占用了处理器，别的进程就不能把处理器从这个进程手中夺走，直到该进程自己因调用原语操作而进入阻塞状态，或时间片用完而让出处理机。<br />
  剥夺方式是指，当就绪队列中有进程的优先级高于当前执行进程的优先级时，便立即发生进程调度，转让处理机。</p>
<p>  进程调度的算法是服务于系统目标的策略，对于不同的系统与系统目标，常采用不同的调度算法：</p>
<ol>
<li>先来先服务（First Come and First Serverd，FCFS）调度算法<br />
  又称先进先出（First Inand First Out，FIFO）。就绪队列按先来后到原则排队。</li>
<li>优先数调度<br />
  优先数反映了进程优先级，就绪队列按优先数排队。有两种确定优先级的方法，即<code>静态优先级</code>和<code>动态优先级</code>。静态优先级是指进程的优先级在进程开始执行前确定，执行过程中不变，而动态优先级则可以在进程执行过程中改变。</li>
<li>轮转法（Round Robin）<br />
  就绪队列按 FCFS 方式排队。每个进程执行一次占有处理器时间都不超过规定的时间单位（时间片）若超过，则自行释放自己所占有的 CPU 而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。</li>
</ol>
<p>  进程管理是操作系统的核心，在进程管理的实现中，如果设计不当，会出现一种尴尬的局面——死锁。当若干个进程互相竞争对方已占有的资源，无限期地等待，不能向前推进时会造成“死锁”。<br />
  例如，P1 进程占有资源 R1，P2 进程占有资源 R2，这时，P1 又需要资源 R2，P2 也需要资源 R1，它们在等待对方占有的资源时，又不会释放自己占有的资源，因而使双方都进入了无限等待状态。<br />
  死锁是系统的一种出错状态，它不仅会浪费大量的系统资源，甚至还会导致整个系统的崩溃，所以死锁是应该尽量预防和避免的。</p>
<ol>
<li>死锁条件<br />
  产生死锁的主要原因是供共享的系统资源不足，资源分配策略和进程的推进顺序不当。系统资源既可能是可重复使用的永久性资源，也可能是消耗性的临时资源。<br />
  产生死锁的必要条件是：<code>互斥条件</code>、<code>保持和等待条件</code>、<code>不剥夺条件</code>和<code>环路等待条件</code>。</li>
<li>解决死锁的策略<br />
  处于死锁状态的进程不能继续执行但又占用了系统资源，从而阻碍其他作业的执行。<br />
  解决死锁有两种策略：一种是在<code>死锁发生前采用的预防和避免策略</code>；另一种是<code>在死锁发生后采用的检测与恢复策略</code>。<br />
  死锁的预防主要是通过打破死锁产生的 4 个必要条件之一来保证不会产生死锁。采用的死锁预防策略通常有资源的<code>静态分配法</code>或<code>有序分配法</code>，它们分别打破了资源动态分配条件和循环等待条件，因此不会发生死锁。但这样做会大大降低系统资源的利用率和进程之间的并行程度。<br />
  死锁避免策略，则是在系统进行资源分配时，先执行一个死锁避免算法（典型的如银行家算法），以保证本次分配不会导致死锁发生。由于资源分配很频繁，因此死锁避免策略要耗费大量的 CPU 和时间。</li>
</ol>
<p>  实际上，系统出现死锁的概率很小，故从系统所花的代价上看，采用死锁发生后的检测与恢复策略要比采用死锁发生前的预防与避免策略代价小一些。</p>
<h3 id="222-存储管理"><a class="markdownIt-Anchor" href="#222-存储管理"></a> 2.2.2 存储管理</h3>
<p>  存储管理主要是指对内存储器的管理，负责对内存的分配和回收、内存的保护和内存的扩充。存储管理的目的是尽量提高内存的使用效率。存储管理的机制经历了多次变迁，由以前的<code>单一连续区管理</code>到<code>分区存储管理</code>再发展为<code>段页式管理</code>。目前前两种技术已逐步被淘汰。</p>
<h4 id="1-页式存储管理"><a class="markdownIt-Anchor" href="#1-页式存储管理"></a> 1. 页式存储管理</h4>
<p>  分页的基本思想是把程序的逻辑空间和内存的物理空间按照同样的大小划分成若干页面，并以页面为单位进行分配。在页式存储管理中，系统中虚地址是一个有序对（页号，位移）。系统为每一个进程建立一个页表，其内容包括进程的逻辑页号与物理页号的对应关系、状态等。<br />
  页式系统的动态地址转换是这样进行的：当进程运行时，其页表的首地址已在系统的动态地址转换机构中的基本地址寄存器中。执行的指令访问虚存地址（p，d）时，首先根据页号 p 查页表，由状态可知，这个页是否已经调入内存。若已调入内存，则得到该页的内存位置 p’，然后，与页内相对位移 d 组合，得到物理地址 r。如果该页尚未调入内存，则产生缺页中断，以装入所需的页，该过程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rTEYIH"><img src="https://s3.ax1x.com/2020/12/28/rTEYIH.png" alt="页式存储动态地址转换" /></a></p>
<p>  页式虚拟存储管理是在页式存储管理的基础上实现虚拟存储器的。首先把作业信息作为副本存放在磁盘上，作业执行时，把作业信息的部分页面装入内存储器，作业执行时若所访问的页面已在内存中，则按页式存储管理方式进行地址转换，得到欲访问的内存绝对地址，若欲访问的页面不在内存中，则产生一个“缺页中断”，由操作系统把当前所需的页面装入内存储器中。<br />
  为此，在装入作业时，就应在该作业的页表中指出哪些页已在内存储器中，哪些页还没有装入内存。可用一个标志位指示对应页是否在内存储器，可假设标志位为 1 表示该页在内存，而标志位为 0 表示该页尚未装入内存。为了能方便地从磁盘上找到作业信息的副本，故在页表中还可指出每一页副本在磁盘上的位置。</p>
<p>  当内存中无空闲块时，为了装入一个页面而必须按某种算法从已在内存的页中选择一页，将它暂时调出内存，让出内存空间以存放所需装入的页面，这个工作称为“页面调度”。如何选择调出的页面是很重要的，如果采用了一个不合适的算法，就会出现这样的现象：刚被调出的页面又立即要用，因而又要把它装入，而装入不久又被选中调出，调出不久又被装入，如此反复，使调度非常频繁。这种现象称为<code>“抖动”</code>。一个好的调度算法应减少或避免抖动现象。</p>
<p>  常用的页面调度算法有：</p>
<ol>
<li>最优（OPT）算法<br />
  选择不再使用或最远的将来才被使用的页，这是理想的算法，但是难以实现，常用于淘汰算法的比较。</li>
<li>随机（RAND）算法<br />
  随机地选择被淘汰的页，开销小，但是可能选中立即就要访问的页。</li>
<li>先进先出算法<br />
  选择在内存驻留时间最长的页似乎合理，但可能淘汰掉频繁使用的页。另外，使用 FIFO 算法时，在未给予进程分配足够的页面数时，有时会出现给予进程的页面数增多，缺页次数反而增加的异常现象。<br />
  FIFO 算法简单，易实现。可以把装入内存储器的那些页的页号按进入的先后顺序排成队列，每次总是调出队首的页，当装入一个新页后，把新页的页号排到队尾。</li>
<li>最近最少使用（Least Recently Used，LRU）算法<br />
  选择离当前时间最近的一段时间内使用得最少的页。这个算法的主要出发点是，如果某个页被访问了，则它可能马上就要被访问；反之，如果某个页长时间未被访问，则它在最近一段时间也不会被访问。</li>
</ol>
<h4 id="2段式存储管理"><a class="markdownIt-Anchor" href="#2段式存储管理"></a> 2．段式存储管理</h4>
<p>  段式存储管理与页式存储管理相似。分段的基本思想是把用户作业按逻辑意义上有完整意义的段来划分，并以段为单位作为内外存交换的空间尺度。<br />
  一个作业是由若干个具有逻辑意义的段（如主程序、子程序、数据段等）组成。分段系统中，容许程序（作业）占据内存中许多分离的分区。每个分区存储一个程序分段。这样每个作业需要几对界限地址寄存器，判定访问地址是否越界也就更困难了。在分段存储系统中常常利用存储保护键实现存储保护。分段系统中虚地址是一个有序对（段号，位移）。系统为每个作业建立一个段表，其内容包括段号、段长、内存起始地址和状态等。状态指出这个段是否已调入内存，即内存起始地址指出这个段，状态指出这个段的访问权限。</p>
<p>  分段系统的动态地址转换是这样进行的：进程执行时，其段表的首地址已在基本地址寄存器中，执行的指令访问虚存（s，d）（取指令或取操作数）时，首先根据段号 s 查段表，若段已经调入内存，则得到该段的内存起始地址，然后与段内相对地址（段内偏移量 d）相加，得到实地址。如果该段尚未调入内存，则产生缺段中断，以装入所需要的段。</p>
<p>  段式虚拟存储管理仍然以段式存储管理为基础，为用户提供比内存实际容量大的虚拟空间。段式虚拟存储管理把作业中的各个分段信息都保留在磁盘上，当作业可以投入执行时，做如下操作：</p>
<ul>
<li>首先把当前需要的一段或几段装入内存。</li>
<li>作业执行时，如果要访问的段已经在内存，则按照“段式存储管理”中的方式进行地址转换；如果要访问的段不在内存中，则产生一个“缺段中断”，由操作系统把当前需要的段装入内存。</li>
</ul>
<p>  因此，在段表中应增设段是否在内存的标志以及各段在磁盘上的位置，已在内存中的段仍要指出该段在内存中的起始地址和占用内存区长度。<br />
  作业执行要访问的段时，由硬件的地址转换机构查段表。若该段在内存中，则立即把逻辑地址转换成绝对地址；若该段不在内存中，则形成“缺段中断”，由操作系统处理这个中断。<br />
  处理的办法是:查内存分配表，找出一个足够大的连续区以容纳该分段，如果找不到足够大的连续区则检查空闲区的总和，若空闲区总和能满足该段要求，那么进行适当移动将分散的空闲区集中；若空闲区总和不能满足该段要求，可把内存中的一段或几段调出，然后把当前要访问的段装入内存中。段被移动、调出和装入后都要对段表中的相应表目做修改。新的段被装入后应让作业重新执行被中断的指令，这时就能找到要访问的段，也可以继续执行下去。</p>
<h4 id="3段页式存储管理"><a class="markdownIt-Anchor" href="#3段页式存储管理"></a> 3．段页式存储管理</h4>
<p>  段页式管理是段式和页式两种管理方法结合的产物，综合了段式组织与页式组织的特点，根据程序模块分段，段内再分页，内存被分划成定长的页。段页式系统中虚地址形式是（段号、页号、页内偏移），如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rTmG6I"><img src="https://s3.ax1x.com/2020/12/28/rTmG6I.png" alt="段页式系统的虚地址形式" /></a></p>
<p>  系统为每个进程建立一个段表，为每个段建立一个页表。段页式管理采用段式分配、页式使用的方法，便于动态连接和存储的动态分配。这种存储管理能提高内存空间的利用率。<br />
  段式虚拟管理还是以段为单位分配内存空间，整段的调出、装入，有时还要移动，这些都增加了系统的开销。如果按段页式存储管理的方式，把每一段再分成若干页面，那么，每一段不必占用连续的存储空间；甚至当内存块不够时，可只将一段中的部分页面装入内存，这种管理方式称为“段页式虚拟存储管理”。<br />
  段页式虚拟存储管理为每一个装入内存的作业建立一张段表，还要为每一段建立页表。段表中指出该段的页表存放位置及长度，页表中应指出该段的各页在磁盘上的位置以及页是否在内存中，若在内存中则填上占用的内存块号。作业执行时按段号查段表，找到相应的页表再根据页号查页表，由标志位判定该页是否已在内存，若是，则进行地址转换；否则进行页面调度。地址转换过程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rTmcn0"><img src="https://s3.ax1x.com/2020/12/28/rTmcn0.png" alt="段页式存储地址转换过程" /></a></p>
<p>  段页式虚拟存储管理结合了段式和页式的优点，但增加了设置表格（段表、页表）和查表等开销，段页式虚拟存储器一般只在大型计算机系统中使用。</p>
<h3 id="223-设备管理"><a class="markdownIt-Anchor" href="#223-设备管理"></a> 2.2.3 设备管理</h3>
<h4 id="1-数据传输控制方式"><a class="markdownIt-Anchor" href="#1-数据传输控制方式"></a> 1. 数据传输控制方式</h4>
<p>  外围设备和内存之间常用的数据传送控制方式主要有以下几种：</p>
<ol>
<li>程序控制方式<br />
  处理器启动数据传输，然后等设备完成。</li>
<li>中断方式<br />
  程序控制方式不能实现并发。中断方式的数据传输过程是这样的，进程启动数据传输（如读）后，该进程放弃处理器，当数据传输完成，设备控制器产生中断请求，中断处理程序对数据传输工作处理之后，让相应进程成为就绪状态。以后，该进程就可以得到所需要的数据。</li>
<li>直接存储访问（Direct Memory Access，DMA）方式<br />
  指外部设备和内存之间开辟直接的数据交换通路。除了控制状态寄存器和数据缓冲寄存器外，DMA 控制器中还包括传输字节计数器、内存地址寄存器等。DMA 方式采用窃取（或挪用）处理器的工作周期和控制总线而实现辅助存储器和内存之间的数据交换。有的 DMA 方式也采用总线浮起方式传输大批量数据。</li>
<li>通道方式<br />
  通道又称为输入/输出处理器（Input/Output Processor，IOP），可以独立完成系统交付的输入/输出任务，通过执行自身的输入/输出专用程序（称通道程序）进行内存和外设之间的数据传输。主要有 3 种通道：字节多路通道、选择通道和成组多路通道。</li>
</ol>
<p>  选择和衡量控制方式的原则如下：</p>
<ol>
<li>数据传送速度足够高，能满足用户的需要但又不丢失数据。</li>
<li>系统开销小，所需的处理控制程序少。</li>
<li>能充分发挥硬件资源的能力，使得 I/O 设备尽量处于使用状态中，而 CPU 等待时间少</li>
</ol>
<h4 id="2-虚设备与spooling技术"><a class="markdownIt-Anchor" href="#2-虚设备与spooling技术"></a> 2. 虚设备与SPOOLING技术</h4>
<p>  采用假脱机技术，可以将低速的独占设备改造成一种可共享的设备，而且一台物理设备可以对应若干台虚拟的同类设备。假脱机（Simultaneous Peripheral Operation On Line，SPOOLING）的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，采用一组程序或进程模拟一台输入/输出处理器。<br />
  该技术利用了专门的外围控制机将低速 I/O 设备上的数据传送到高速设备上，或者相反。但是当引入多道程序后，完全可以利用其中的一道程序来模拟脱机输入时的外围控制机的功能，把低速的 I/O 设备上的数据传送到高速磁盘上；再利用另一道程序来模拟脱机输出时外围控制机的功能，把高速磁盘上的数据传送到低速的 I/O 设备上。这样便可以在主机的控制下实现脱机输入、输出的功能。此时的外围操作与 CPU 对数据的处理同时进行。</p>
<h3 id="224-文件管理"><a class="markdownIt-Anchor" href="#224-文件管理"></a> 2.2.4 文件管理</h3>
<p>  操作系统对计算机的管理包括两个方面：<code>硬件资源</code>和<code>软件资源</code>。<br />
  硬件资源的管理包括<code>CPU的管理</code>、<code>存储器的管理</code>、<code>设备管理</code>等，主要解决硬件资源的有效和合理利用问题。<br />
  软件资源包括<code>各种系统程序</code>、<code>各种应用程序</code>、<code>各种用户程序</code>，也包括大量的<code>文档材料</code>、<code>库函数</code>等。<br />
  每一种软件资源本身都是具有一定逻辑意义的相关信息的集合，在操作系统中它们以文件形式存储。</p>
<p>  计算机系统的重要作用之一是能快速处理大量信息，因此数据的组织、存取和保护成为<br />
一个极重要的内容。文件系统是操作系统中<code>组织</code>、<code>存取</code>和<code>保护</code>数据的一个重要部分。<br />
  文件管理的功能包括：</p>
<ul>
<li>建立、修改、删除文件</li>
<li>按文件名访问文件</li>
<li>决定文件信息的存放位置、存放形式及存取权限</li>
<li>管理文件间的联系及提供对文件的共享、保护和保密等<br />
  允许多个用户协同工作又不引起混乱。文件的共享是指一个文件可以让多个用户共同使用，它可以减少用户的重复性劳动，节省文件的存储空间，减少输入/输出文件的次数等。文件的保护主要是为防止由于错误操作而对文件造成的破坏。文件的保密是为了防止未经授权的用户对文件进行访问。</li>
</ul>
<p>  文件的保护、保密实际上是用户对文件的存取权限控制问题。一般为文件的存取设置两<br />
级控制：第 1 级是访问者的识别，即规定哪些人可以访问；第 2 级是存取权限的识别，即<br />
有权参与访问者可对文件执行何种操作。<br />
1．文件的逻辑结构<br />
文件的结构是指文件的组织形式，从用户角度所看到的文件组织形式，称为文件的逻辑<br />
结构。<br />
文件的逻辑组织是为了方便用户使用。一般文件的逻辑结构可以分为两种：无结构的字<br />
符流文件和有结构的记录文件。记录文件由记录组成，即文件内的信息划分成多个记录，以<br />
记录为单位组织和使用信息。<br />
记录文件有顺序文件、索引顺序文件、索引文件和直接文件。<br />
（1）顺序文件。大多数文件是顺序文件。顺序文件的记录定长，记录中的数据项的类<br />
型长度与次序固定，一般还有一个可以唯一标识记录的数据项，称为键（key），记录是按键<br />
值的约定次序组织的。顺序文件常用于批处理应用，对于查询或更新某个记录的处理性能不<br />
太好。<br />
（2）索引顺序文件。索引顺序文件是基于键的约定次序组织的，而且维护键的索引和<br />
溢出区域。键的索引也可以是多级索引。索引顺序文件既适用于交互方式应用，也适用于批<br />
处理方式应用。<br />
（3）索引文件。索引文件是基于记录的一个键数据项组织的。许多应用需按照别的数<br />
据项访问文件，为此，常采用索引文件方法，即对主文件中的记录按需要的数据项（一个或<br />
几个）建索引，索引文件本身是顺序文件组织。<br />
（4）直接文件。直接文件又称哈希（Hash）文件。记录以它们在直接访问存储设备上<br />
的物理地址直接（随机地）访问。直接文件常用 于需要高速访问文件而且每次仅访问一条<br />
记录的应用中。<br />
2．文件的物理结构<br />
文件的物理结构是指文件在存储设备上的存放方法。文件的物理结构侧重于提高存储器<br />
的利用效率和降低存取时间。文件的存储设备通常划分为大小相同的物理块，物理块是分配<br />
和传输信息的基本单位。文件的物理结构涉及文件存储设备的组块策略和文件分配策略，决<br />
定文件信息在存储设备上的存储位置。常用的文件分配策略有：<br />
（1）顺序分配（连续分配）。这是最简单的分配方法。在文件建立时预先分配一组连续<br />
的物理块，然后，按照逻辑文件中的信息（或记录）顺序，依次把信息（或记录）按顺序存<br />
储到物理块中。这样，只需知道文件在文件存储设备上的起始位置和文件长度，就能进行存<br />
取，这种分配方法适合于顺序存取，在连续存取相邻信息时，存取速度快。其缺点是在文件<br />
建立时必须指定文件的信息长度，以后不能动态增长，一般不宜用于需要经常修改的文件。<br />
（2）链接分配（串联分配）。这是按单个物理块逐个进行的。每个物理块中（一般是最<br />
后一个单元）设有一个指针，指向其后续连接的下一个物理块的地址，这样，所有的物理块<br />
都被链接起来，形成一个链接队列。在建立链接文件时，不需要指定文件的长度，在文件的<br />
说明信息中，只需指出该文件的第一个物理块块号，而且链接文件的文件长度可以动态地增<br />
长。只调整物理块间的指针就可以插入或删除一个信息块。<br />
链接分配的优点是可以解决存储器的碎片问题，提高存储空间利用率。由于链接文件只<br />
能按照队列中的链接指针顺序查找，因此搜索效率低，一般只适用于顺序访问，不适用于随<br />
机存取。<br />
（3）索引分配。这是另一种对文件存储不连续分配的方法。采用索引分配方法的系统，<br />
为每一个文件建立一张索引表，索引表中每一表项指出文件信息所在的逻辑块号和与之对应<br />
的物理块号。<br />
索引分配既可以满足文件动态增长的要求，又可以方便而迅速地实现随机存取。对一些<br />
大的文件，当索引表的大小超过一个物理块时，会发生索引表的分配问题。一般采用多级（间<br />
接索引）技术，这时在由索引表指出的物理块中存放的不是文件存放处而是存放文件信息的<br />
物理块地址。这样，如果一个物理块能存储 n 个地址，则一级间接索引将使可寻址的文件<br />
长度变成 n2 块，对于更大的文件可以采用二级甚至三级间接索引（例如，UNIX 操作系统<br />
采用三级索引结构，如图 2-9 所示）。</p>
<h1 id="第六章-开发方法"><a class="markdownIt-Anchor" href="#第六章-开发方法"></a> 第六章 开发方法</h1>
<h2 id="61-软件生命周期"><a class="markdownIt-Anchor" href="#61-软件生命周期"></a> 6.1 软件生命周期</h2>
<p>  有关软件生命周期的阶段划分，不同的标准有不同的规定。<br />
  在 GB8566-88（《软件工程国家标准——计算机软件开发规范》）中将软件生命周期划分为 8 个阶段：<code>可行性研究与计划</code>、<code>需求分析</code>、<code>概要设计</code>、<code>详细设计</code>、<code>实现</code>、<code>集成测试</code>、<code>确认测试</code>、<code>使用和维护</code>。</p>
<ol>
<li>可行性研究与计划<br />
  在决定是否开发软件之前，首先需要进行可行性研究。通过可行性研究，来确定开发此软件的必要性，并根据可行性研究的结果初步确定软件的目标、范围、风险、开发成本等内容。从而制定出初步的软件开发计划。通过可行性研究，如果确定该软件具有研发的必要，则将产生<code>《可行性研究报告》</code>和<code>《软件开发计划》</code>，并进入需求分析的阶段。</li>
<li>需求分析<br />
  需求分析是软件开发的重要阶段。经过可行性研究后，初步确定了软件开发的目标和范围，之后则需要对软件的需求进行细致的分析，来确定软件要做成什么样的。需求分析是软件开发过程中极其重要的一环，如果需求分析出现了重大偏差，那么软件开发必然会偏离正确的道路，越走越远。尤其是需求分析的错误如果在软件开发后期才被发现，修正的代价是非常大的。</li>
<li>概要设计<br />
  概要设计确定整个软件的技术蓝图，负责将需求分析的结果转化为技术层面的设计方案。在概要设计中，需要确定系统架构、各子系统间的关系、接口规约、数据库模型、编码规范等内容。概要设计的结果将作为程序员的工作指南，供程序员了解系统的内部原理，并在其基础上进行详细设计和编码工作。</li>
<li>详细设计<br />
  详细设计完成编码前最后的设计，详细设计在概要设计的基础上，进行细化，如类设计。<code>详细设计不是开发过程中必需的阶段</code>，在一些规模较小、结构简单的系统中，详细设计往往被省略。同样，在某一次软件开发中，可能只会对部分关键模块进行详细设计。</li>
<li>实现<br />
  实现过程包括<code>编码</code>和<code>单元测试</code>。单元测试指的是对刚刚编写出的一个小的程序单元进行测试，如某一个过程、方法或函数。因为单元测试的对象是小的程序单元，而不是完整的程序，因此往往需要编写一些测试程序来进行测试。有效的单元测试可以大大提高编码的质量，降低软件系统的缺陷率。</li>
<li>集成测试<br />
  集成测试又称为组装测试。通过单元测试的程序并不意味着没有缺陷，当程序单元被集成到一起进行交互的时候，往往会出现单元测试中不能发现的问题。同单元测试不同，集成测试必须经过精心的组织，指定集成测试计划，确定如何将这些程序单元集成到一起，按照什么样的顺序进行测试，使用哪些测试数据等问题。</li>
<li>确认测试<br />
  当完成集成测试后，软件之间的接口方面的错误已经排除，这时需要验证软件是否同需求一致，是否达到了预期目标。同集成测试一样，确认测试也需要进行计划和组织，逐步地验证软件系统同需要的一致性。经过确认测试的软件将投入正常使用，并进入维护期。</li>
<li>使用和维护<br />
  即使通过了单元测试、集成测试和确认测试，也不可能发现软件系统中的全部缺陷；软件系统的需求也会根据业务的发展变化而变化。因此，在软件使用过程中，必须不断地对软件进行维护，修正软件中的缺陷，修改软件中已经不能适应最新情况的功能或者增加新的功能。软件维护的过程会贯穿整个软件的使用过程。当使用和维护阶段结束后，软件系统也就自然消亡，软件系统的生命周期结束。</li>
</ol>
<h2 id="62-软件开发模型"><a class="markdownIt-Anchor" href="#62-软件开发模型"></a> 6.2 软件开发模型</h2>
<p>  软件系统已经变得非常复杂，需要遵循一定的开发方法才能取得成功，于是称这些模式化的开发方法为开发模型。</p>
<h3 id="621-瀑布模型"><a class="markdownIt-Anchor" href="#621-瀑布模型"></a> 6.2.1 瀑布模型</h3>
<p>  顾名思义，瀑布模型就如同瀑布一样，从一个特定的阶段流向下一个阶段，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rjKS91"><img src="https://s3.ax1x.com/2020/12/31/rjKS91.png" alt="瀑布模型" /></a></p>
<h4 id="1-瀑布模型的核心思想"><a class="markdownIt-Anchor" href="#1-瀑布模型的核心思想"></a> 1. 瀑布模型的核心思想</h4>
<p>  瀑布模型认为，软件开发是一个阶段化的精确的过程。就像要制造一艘航空母舰，首先需要知道航空母舰的参数（长、宽、高、排水量、航速等）。在这些参数的技术上需要对航空母舰进行设计，设计包括总体设计和详细设计。只有设计得一清二楚的图纸才能交付施工，否则造出的零件肯定拼装不到一起。制造完毕后，要把这些零件一个一个地拼装起来，拼装成发动机、船舱等部分，并检查这些部分是否符合设计标准，这就是集成测试。最后，把各个部分组合在一起，造出一艘巨大的航母。软件也同样要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段才能够被准确地实现。在瀑布模型图中，每一阶段都有回到前一阶段的反馈线，这指的是，在软件开发中当在后续阶段发现缺陷的时候，可以把这个缺陷反馈到上一阶段进行修正。<br />
  从瀑布模型图中可以看出瀑布模型的一个重要特点：软件开发的阶段划分是明确的，一个阶段到下一个阶段有明显的界线。在每个阶段结束后，都会有固定的文档或源程序流入下一阶段。在需求分析阶段结束后，需要有明确的描述软件需求的��档；总体设计结束后，需要有描述软件总体结构的文档；详细设计结束后，需要有可以用来编码的详细设计文档；而编码结束后，代码本身被作为文档流到下一个阶段。因此也称瀑布模型是<code>面向文档的软件开发模型</code>。<br />
  当软件<code>需求明确、稳定</code>时，可以采用瀑布模型按部就班地开发软件，当软件需求不明确或变动剧烈时，瀑布模型中往往要到测试阶段才会暴露出需求的缺陷，造成后期修改代价太大，难以控制开发的风险。</p>
<h4 id="2瀑布v模型"><a class="markdownIt-Anchor" href="#2瀑布v模型"></a> 2．瀑布V模型</h4>
<p>  瀑布V模型是瀑布模型的一种变体。随着对瀑布模型的应用，人们发现，缺陷是无法避免的，任何一个阶段都会在软件中引入缺陷，而最后的测试也不能保证软件完全没有缺陷，只能争取在交付前发现更多的缺陷。测试成为软件开发中非常重要的环节，测试的质量直接影响到软件的质量。因此，人们对瀑布模型进行了小小的更改，提出了<code>更强调测试</code>的瀑布V模型，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rjGAMR"><img src="https://s3.ax1x.com/2020/12/31/rjGAMR.png" alt="瀑布V模型" /></a></p>
<p>整个瀑布模型在编码与调试阶段转了个弯，形成了一个对称的 V 字。瀑布 V 模型同标准瀑布模型一样，在进行完需求分析后就将进入总体设计阶段，但是除总体设计外，需求分析还有一条虚线指向系统测试。这指的是，<code>需求分析的结果将作为系统测试的准则</code>，即需求分析阶段也将产生同软件需求一致的系统测试；同时软件产品是否符合最初的需求将在系统测试阶段得到验证。以此类推，总体设计对应了集成测试，详细设计对应了单元测试。瀑布 V 模型不但保持了瀑布模型的阶段式文档驱动的特点，而且更强调了软件产品的验证工作。</p>
<h4 id="3瀑布模型的缺点"><a class="markdownIt-Anchor" href="#3瀑布模型的缺点"></a> 3．瀑布模型的缺点</h4>
<p>  虽然是经典的开发模型，但瀑布模型中仍存在一些难以克服的缺陷，即使是在改进的瀑布 V 模型中还是会存在。<br />
  首先，在瀑布模型中，需求分析阶段是一切活动的基础，设计、实现和验证活动都是从需求分析阶段的结果导出的。一旦需求分析的结果不完全正确，存在偏差，那么后续的活动只能放大这个偏差，在错误的道路上越走越远。<br />
  事实上，由于用户和开发者的立场、经验、知识域都不相同，不同的人对同一件事物的表述也不同，这就造成需求分析的结果不可能精确、完整地描述整个软件系统。所以瀑布模型后期的维护工作相当繁重，而这些维护工作大多都是修正在需求分析阶段引入的缺陷。这个问题是瀑布模型难以克服的。<br />
其次，瀑布模型难以适应变化。在瀑布模型中精确地定义了每一个阶段的活动和活动结果，而每一阶段都紧密依赖于上一阶段的结果。如果在软件的后期出现了需求的变化，整个系统又要从头开始。<br />
  再次，使用瀑布模型意味着当所有阶段都结束才能最终交付软件产品，所以在提出需求后需要相当长一段时间的等待才能够看到最终结果，才能发现软件产品究竟能不能够满足客户的需求。<br />
  最后，文档驱动型的瀑布模型除了制造出软件产品外还将产生一大堆的文档，大部分的文档对客户没有任何意义，但完成这些对客户没有意义的文档却需要花费大量的人力。所以瀑布模型也是一种重载过程。</p>
<h3 id="622-演化模型"><a class="markdownIt-Anchor" href="#622-演化模型"></a> 6.2.2 演化模型</h3>
<p>  瀑布模型看起来很好，随着一个又一个阶段的流过，软件系统就被建立起来了。可是在应用软件开发的过程中，人们发现很难一次性完全理解用户的需求、设计出完美的架构，开发出可用的系统，这是由于人的认知本身就是一个过程，这个过程是渐进的、不断深化的。<br />
  对于复杂问题，“做两次”肯定能够做得更好。那么，对于软件开发这个复杂而且与人的认知过程紧密相关的事也应该是一个渐进的过程。<br />
  演化模型正是基于这个观点提出的。一般情况下，一个演化模型可以看做若干次瀑布模型的迭代，当完成一个瀑布模型后，重新进入下一个迭代周期，软件在这样的迭代过程中得以演化、完善。根据不同的迭代特点，演化模型可以演变为螺旋模型、增量模型和原型法开发。</p>
<h3 id="623-螺旋模型"><a class="markdownIt-Anchor" href="#623-螺旋模型"></a> 6.2.3 螺旋模型</h3>
<p>  螺旋模型将瀑布模型和演化模型结合起来，不仅体现了两个模型的优点，而且还强调了其他模型均忽略了的风险分析。螺旋模型的每一周期都包括需求定义、风险分析、工程实现和评审 4 个阶段，由这 4 个阶段进行迭代，软件开发过程每迭代一次，软件开发就前进一个层次。采用螺旋模型的软件过程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rjaz6g"><img src="https://s3.ax1x.com/2020/12/31/rjaz6g.png" alt="螺旋模型" /></a></p>
<p>  螺旋模型的基本做法是在“瀑布模型”的每一个开发阶段前，引入一个非常严格的风险识别、风险分析和风险控制。它把软件项目分解成一个个小项目，每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。<br />
  螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险都有所了解，继而做出应有的反应。因此，螺旋模型特别适用于<code>庞大而复杂</code>、<code>具有高风险</code>的系统，对于这些系统，风险是软件开发潜在的、不可忽视的不利因素，它可能在不同程度上损害软件开发过程，影响软件产品的质量。减小软件风险的目标是在造成危害之前，及时对风险进行识别、分析，决定采取何种对策，进而消除或减少风险的损害。<br />
  与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便，有助于提高目标软件的适应能力，为项目管理人员及时调整管理决策提供了便利，从而降低了软件开发风险。<br />
但是，不能说螺旋模型绝对比其他模型优越，事实上，螺旋模型也有其自身的缺点：</p>
<ol>
<li>采用螺旋模型，需要具有相当丰富的风险评估经验和专业知识。在风险较大的项目开发中，如果未能及时标识风险，势必会造成重大损失。</li>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ol>
<h3 id="624-增量模型"><a class="markdownIt-Anchor" href="#624-增量模型"></a> 6.2.4 增量模型</h3>
<p>  演化模型的另一种形式是增量模型。在系统的<code>技术架构成熟</code>、<code>风险较低</code>的时候，可以采用增量的方式进行系统开发，这样可以提前进行集成测试和系统测试，缩短初始版本的发布周期，提高用户对系统的可见度。<br />
对于增量模型，通常有两种策略。<br />
  一是<code>增量发布</code>的办法。即首先做好系统的分析和设计工作，然后将系统划分为若干不同的版本，每一个版本都是一个完整的系统，后一版本以前一版本为基础进行开发，扩充前一版本的功能。在这种策略中，第一版本往往是系统的核心功能，可以满足用户最基本的需求，随着增量的发布，系统的功能逐步地丰富、完善起来。用户在很短的时间内就可以得到系统的初始版本并进行试用。试用中的问题可以很快地反馈到后续开发中，从而降低了系统的风险。在应用增量模型中需要注意：</p>
<ol>
<li>每一个版本都是一个完整的版本。虽然最初的几个增量不能完全地实现用户需求，但这些版本都是完整的、可用的。</li>
<li>版本间的增量要均匀，这一点是很重要的。如果第一个版本花费一个月的时间，而第二个版本需要花费 6 个月的时间，这种不均匀的分配会降低增量发布的意义，需要重新调整。</li>
</ol>
<p>  另一种策略是原型法。原型法的每一次迭代都经过一个完整的生命周期。当用户需求很不明确或技术架构中存在很多不可知因素的时候，可以采用原型法。在初始的原型中，针对一般性的用户需求进行快速实现，并不考虑算法的合理性或系统的稳定性。这个原型的主要目的是<code>获得精确的用户需求</code>，或<code>验证架构的可用性</code>。一般情况下，会在后面的开发中抛弃这个原型，重新实现完整的系统。</p>
<h3 id="625-构件组装模型"><a class="markdownIt-Anchor" href="#625-构件组装模型"></a> 6.2.5  构件组装模型</h3>
<p>  随着软构件技术的发展，人们开始尝试利用软构件进行搭积木式的开发，即构件组装模型。在构建组装模型中，当经过需求分析定义出软件功能后，将对构件的组装结构进行设计，将系统划分成一组构件的集合，明确构件之间的关系。在确定了系统构件后，则将独立完成每一个构件，这时既可以开发软件构件，也可以重用已有的构件，当然也可以购买或选用第三方的构件。构件是独立的、自包容的，因此架构的开发也是独立的，构件之间通过接口相互协作。构件组装模型的一般开发过程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rj0pon"><img src="https://s3.ax1x.com/2020/12/31/rj0pon.png" alt="构件组装模型" /></a></p>
<p>  构件组装模型的优点如下：</p>
<ol>
<li>构件的自包容性让系统的扩展变得更加容易</li>
<li>设计良好的构件更容易被重用，降低软件开发成本</li>
<li>构件的粒度较整个系统更小，因此安排开发任务更加灵活，可以将开发团队分成若干组，并行地独立开发构件。</li>
</ol>
<p>  然而鱼与熊掌不可兼得，构件组装模型也有明显的缺点：</p>
<ol>
<li>对构件的设计需要经验丰富的架构设计师，设计不良的构件难以实现构件的优点，降低构件组装模型的重用度。</li>
<li>在考虑软件的重用度时，往往会对其他方面做出让步，如性能等。</li>
<li>使用构件组装应用程序时，要求程序员熟练地掌握构件，增加了研发人员的学习成本。</li>
<li>第三方构件库的质量会最终影响到软件的质量，而第三方构件库的质量往往是开发团队难以控制的。</li>
</ol>
<h2 id="63-统一过程"><a class="markdownIt-Anchor" href="#63-统一过程"></a> 6.3 统一过程</h2>
<p>  统一过程（Unified Process，UP）是由 Rational 公司开发的一种迭代的软件过程，是一个优秀的软件开发模型，它提供了完整的开发过程解决方案，可以有效地降低软件开发过程的风险，经过裁剪的 UP 可以适应各种规模的团队和系统。</p>
<h3 id="631-up的二维模型"><a class="markdownIt-Anchor" href="#631-up的二维模型"></a> 6.3.1 UP的二维模型</h3>
<p>  UP 是一个很有特色的模型，它本身是一个二维的结构，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rjBUuF"><img src="https://s3.ax1x.com/2020/12/31/rjBUuF.md.png" alt="UP模型" /></a></p>
<p>  对于 UP 而言，时间主线就是横轴的阶段，随着时间的流逝，软件开发活动总要经过<code>初始</code>、<code>细化</code>、<code>构建</code>和<code>交付</code>这 4 个阶段方能完成。而纵轴的工作流程则描述了在不同的阶段需要进行的主要工作。例如在初始阶段，软件组织需要进行大量的调研，对软件进行业务建模、需求，同时进行一些设计以验证建模的合理性，还要进行一些实施甚至测试和部署的工作，用以验证需求和设计的工作及开发系统原型，当然配置与变更管理、项目管理和环境是在任何阶段都是不能缺少的。<br />
  从这个模型中可以看出 UP 迭代的特点。任何一个阶段的工作都不是绝对的，都是相互交叠配合的。但每一个阶段都有其侧重点：<br />
  在初始阶段，开发者刚刚接入系统，此时最重要的工作是界定系统范围，明确系统目的。在这一阶段，业务建模和需求工作成了重头戏。<br />
  在细化阶段，开发者需要抽象出软件的逻辑模型，设计出软件的架构，在这一阶段，分析设计工作是最主要的工程活动。<br />
  在构建阶段，开发者需要基本完成系统的构建，使之成为一个完整的实体，并进行测试和部署，在这一阶段，实施和测试是最主要的活动。<br />
  当进入交付阶段（该阶段也经常被称为转移阶段），软件系统需求已经完全成熟或产品化，或进入下一个版本。在这一阶段不可避免地要对软件系统进行重构、修改、测试和部署。<br />
  在这 4 个阶段中，各有侧重点，但也不是像瀑布模型那样完全不允许其他活动的存在。在初始阶段，为了验证开发者的想法，就需要进行一部分的实施和测试；而即使到了交付阶段，需要也可能会发生变化，仍然需要进行部分业务建模、需求和设计的活动。<br />
  在每个阶段中，系统推进不是一蹴而就的。在图中将细化阶段划分为第 1 次细化和第 2 次细化，将构建阶段也划分为 3 个小阶段。在实际开发中，可以根据实际的需要划分为更多的小阶段来完成。</p>
<p>  对于纵轴而言，业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境称为 UP 的 9 个核心工作流。可以把这 9 个工作流进行简单的分类以帮助理解，业务建模、需求、分析设计、实施、测试和部署是工程活动，而配置与变更管理、项目管理和环境是管理活动。<br />
  在这 9 个工作流中，前 8 个可以说是绝大多数人都耳熟能详的东西，而“环境”工作流则相对难以理解。“环境”工作流很重要，也可以称之为“环境管理”。俗语说，“巧妇难为无米之炊”，“环境”工作流就是为软件开发准备“米”的活动。在软件开发中，需要为各种工作准备相应的工作环境，在工作环境中需要包含必需的工具、活动的指南、活动的流程规范、工作产品的模板、基本的开发设施等。在很多组织中，“环境”工作流没有得到应有的重视，或者完全被忽视，以为为开发者提供了工作台和计算机就万事大吉了，其实这种做法是错误的。每一个开发团体都有自己特定的活动准则和规范，这些准则和规范是团体协作的基础，万万少不得。没有合理的工具配备，没有充分的指南、规范和模板，软件开发的活动肯定是放羊式的管理，管理者除了一些“羊毛”外什么也收获不到。观察 UP 模型就可以发现，在每一阶段的最开始，“环境”工作流都有一个小小的波峰。在这里面，开发团队需要为开发环境进行相应的准备并在后续活动中为开发环境提供支持。</p>
<h3 id="632-up的生命周期"><a class="markdownIt-Anchor" href="#632-up的生命周期"></a> 6.3.2 UP的生命周期</h3>
<p>  UP 模型的时间主线是阶段，UP 的生命周期也是与阶段一一对应的。在 UP 的生命周期中共有 4 个里程碑：</p>
<ol>
<li>目标里程碑<br />
  目标里程碑对应着先启阶段的结束，当开发者可以明确软件系统的目标和范围时即达到了该里程碑。</li>
<li>架构里程碑<br />
  架构里程碑是 UP 生命周期中的第二个里程碑，在这个里程碑前，开发者需要确定稳定的系统架构。</li>
<li>能力里程碑<br />
  当系统已经足够的稳定和成熟并完成 Alpha 测试后，认为达到了第 3 个里程碑。</li>
<li>发布里程碑<br />
  在达到发布里程碑前，需要完成系统的测试、完成系统发布和用户培训等工作。</li>
</ol>
<p>  在经过这 4 个里程碑后，即为一个完整的生命周期，开发出一个新的版本。此时可以关闭该产品的开发，也可以迭代进入下一版本。</p>
<h3 id="633-up的特点"><a class="markdownIt-Anchor" href="#633-up的特点"></a> 6.3.3 UP的特点</h3>
<p>  UP 是一个特点鲜明的开发模型，下面列出 UP 的一些特点：</p>
<ol>
<li>UP 是一个迭代的二维开发模型，在生命周期的每一阶段都可以进行需求、设计等活动。UP 不但给出了迭代的生命周期，还给出了生命周期每一阶段的迭代指南。</li>
<li>采用不同迭代方式的 UP 可以演变为演化模型或增量模型。</li>
<li>UP 的迭代特点使得更容易控制软件开发的风险。</li>
<li>虽然 UP 是一个迭代的开发模型，但 UP 本身并不属于敏捷方法。相反，一般认为，未经裁减的 UP 是一个重载过程。</li>
<li>在实际应用中可以根据具体问题对 UP 进行裁减，从而使其可以适应各种规模的软件和开发团队。</li>
</ol>
<h3 id="634-架构设计师在up中的活动"><a class="markdownIt-Anchor" href="#634-架构设计师在up中的活动"></a> 6.3.4 架构设计师在UP中的活动</h3>
<p>  架构设计师在 UP 活动中承担着非常重要的角色。在 UP 中，架构设计师除了需要建立系统架构模型外，还需要：</p>
<ol>
<li>同需求人员和项目管理人员密切协作。</li>
<li>细化软件架构。</li>
<li>保持整个架构的概念完整性。具体地说，架构设计师不但需要设计系统架构，还需要定义设计方法、设计指南、编码指南、评审设计等工作。因此，有人也称 UP 是一个以架构为中心的开发模型。</li>
</ol>
<h2 id="64-敏捷方法"><a class="markdownIt-Anchor" href="#64-敏捷方法"></a> 6.4 敏捷方法</h2>
<p>  2001 年 2 月，在美国的犹他州，17 位“无政府主义者”共同发表了《敏捷软件开发宣言》，在宣言中指出：</p>
<blockquote>
<p>尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。<br />
拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。<br />
经常交付可工作的软件，从几周到几个月，时间范围越小越好。<br />
在整个项目中，业务人员和开发者紧密合作。<br />
围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予足够的信任。<br />
在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。<br />
可以工作的软件是进度首要的度量方式。<br />
可持续地开发。投资人、开发团队和用户应该保持固定的节奏。<br />
不断追求优秀的技术和良好的设计有助于提高敏捷性。<br />
要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。<br />
最好的架构、需求和设计都来自于一个自我组织的团队。<br />
团队要定期地总结如何能够更有效率，然后相应地自我调整。</p>
</blockquote>
<p>  至此，敏捷软件联盟建立起来，敏捷软件开发方法进入了大发展的时代。这份宣言也就是敏捷方法的灯塔，所有的敏捷方法都在向这个方向努力。</p>
<h3 id="641-极限编程"><a class="markdownIt-Anchor" href="#641-极限编程"></a> 6.4.1 极限编程</h3>
<p>  XP 是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。与其他方法论相比，其最大的不同在于：</p>
<ol>
<li>在更短的周期内，更早地提供具体、持续的反馈信息。</li>
<li>迭代地进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断地发展它。</li>
<li>依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。</li>
<li>依赖于口头交流、测试和源程序进行沟通。</li>
<li>倡导持续的、演化式的设计。</li>
<li>依赖于开发团队内部的紧密协作。</li>
<li>尽可能达到程序员短期利益和项目长期利益的平衡。</li>
</ol>
<p>  XP 由<code>价值观</code>、<code>原则</code>、<code>实践</code>和<code>行为</code>四个部分组成，它们彼此相互依赖、关联，并通过行为贯穿于整个生命周期。</p>
<h4 id="1四大价值观"><a class="markdownIt-Anchor" href="#1四大价值观"></a> 1．四大价值观</h4>
<p>   XP 的核心是其总结的<code>沟通</code>、<code>简单</code>、<code>反馈</code>、<code>勇气</code>四大价值观，它们是 XP 的基础，也是 XP 的灵魂。</p>
<ol>
<li>沟通<br />
  XP 方法认为，如果小组成员之间无法做到持续的、无间断的交流，那么协作就无从谈起。从这个角度来看，通过文档、报表等人工制品进行交流，具有很大的局限性。因此， XP组合了诸如<code>结对编程</code>这样的最佳实践，鼓励大家进行口头交流、通过交流解决问题，提高效率。</li>
<li>简单<br />
  XP 方法在工作中秉承<code>“够用即好”</code>的思路，也就是<code>尽量地简单化</code>，只要今天够用就行，不考虑明天会出现的新问题。这一点看上去十分容易，但要真正做到保持简单的工作其实是很难的，因为在传统的开发方法中，都要求开发人员对未来做一些预先规划，以便对今后可能发生的变化预留一些扩展空间。<br />
  <code>沟通</code>和<code>简单</code>之间还有一种相当微妙的互相支持关系。一方面，团队成员之间沟通得越多，就越容易明白哪些工作需要做，哪些工作不需要做；另一方面，系统越简单，需要沟通的内容也就越少，沟通也将更加全面。</li>
<li>反馈<br />
  在很多项目中，当开发团队经历过了需求分析阶段之后，在一个相当长的时间段中，是没有任何反馈信息的。整个开发过程对于客户和管理层而言就像一个黑盒子，进度完全看不到。而且，在项目开发过程中，这样的现象不仅出现在开发团队与客户、管理层之间，还包括在开发团队内部。因此，开发团队需要更加<code>注重反馈</code>。反馈对于任何软件项目的成功都是至关重要的，而在 XP 方法论中则更进一步，通过<code>持续、明确的反馈</code>来暴露软件状态的问题。<br />
  反馈与沟通有着良好的配合，及时和良好的反馈有助于沟通。而简单的系统，更有利于测试和反馈。</li>
<li>勇气<br />
  在应用 XP 方法时，每时每刻都在应对变化：由于沟通良好，会有更多<code>需求变更</code>的机会；由于时刻保持系统的简单，新的变化会带来一些<code>重新开发</code>的需要；由于反馈及时，会有更多中间打断思路的<code>新需求</code>。总之，这一切使得开发团队处于变化之中，因此，这时就需要有勇气来面对快速开发，面对可能的重新开发。勇气可以来源于沟通，因为它使得高风险、高回报的试验成为可能；勇气可以来源于简单，因为面对简单的系统，更容易鼓起勇气；勇气可以来源于反馈，因为可以及时获得每一步前进的状态（自动测试），会让人更勇于重构代码。</li>
</ol>
<h4 id="2十二个最佳实践"><a class="markdownIt-Anchor" href="#2十二个最佳实践"></a> 2．十二个最佳实践</h4>
<p>  在 XP 中，集成了 12 个最佳实践。其主要的创新点在于提供一种良好的思路将这些最佳实践结合在一起，并且确保尽可能彻底地执行，使得它们能够在最大程度上互相支持。</p>
<ol>
<li>计划游戏<br />
  计划游戏的主要思想就是先快速地制定一份<code>概要的计划</code>，然后，随着项目细节的不断清晰，再逐步完善这份计划。计划游戏产生的结果是一套用户故事及后续的一两次迭代的概要计划。</li>
<li>小型发布<br />
  XP 方法秉承的是<code>“持续集成、小步快走”</code>的哲学思维，也就是说每一次发布的版本应该<code>尽可能地小</code>，当然前提条件是每个版本有足够的商业价值，值得发布。由于小型发布可以使得集成更频繁，客户获得的中间结果越频繁，反馈也就越频繁，客户就能够实时地了解项目的进展情况，从而提出更多的意见，以便在下一次迭代中计划进去，以实现更高的客户满意度。</li>
<li>隐喻<br />
  相对而言，隐喻比较令人费解。根据词典中的解释是：“一种语言的表达手段，它用来暗示字面意义不相似的事物之间的相似之处”。隐喻常用于四个方面：<code>寻求共识</code>、<code>发明共享语汇</code>、<code>创新的武器</code>、<code>描述架构</code>。</li>
<li>简单设计<br />
  强调简单的价值观，引出了简单性假设原则，落到实处就是“简单设计”实践。这个实践看上去似乎很容易理解，但却又经常被误解，许多批评者就指责 XP 忽略设计是不正确的。其实，XP 的简单设计实践并不是要忽略设计，而是认为<code>设计不应该在编码之前一次性完成</code>，因为那样只能建立在“情况不会发生变化”或者“我们可以预见所有的变化”之类的谎言的基础上。</li>
<li>测试先行<br />
  对于有些团队而言，有时候程序员会以“开发工作太紧张”为理由，继而忽略测试工作。这样，就导致了一个恶性循环，越是没空编写测试程序，代码的效率与质量越差，花在找缺陷、解决缺陷的时间也越来越多，实际产能大大降低。由于产能降低，因此时间更紧张，压力就更大。</li>
<li>重构<br />
  重构是一种对代码进行改进而不影响功能实现的技术，XP 需要开发人员在<code>“闻到代码的坏味道”</code>时，就有重构代码的勇气。重构的目的是降低变化引发的风险、使得代码优化更加容易。</li>
<li>结对编程<br />
  从 20 世纪 60 年代开始，就有类似的实践在进行，长年以来的研究结果给出的结论是，结对编程的效率反而比单独编程更高。一开始虽然会牺牲一些速度，但慢慢地，开发速度会逐渐加快。究其原因，主要是结对编程大大<code>降低了沟通成本</code>，<code>提高了工作质量</code>。结对编程技术被誉于 XP 保证工作质量、强调人文主义的一个最典型的实践，应用得当还能够使开发团队协作更加顺畅、知识交流与共享更加频繁、团队稳定性也会更加牢固。</li>
<li>集体代码所有制<br />
  由于 XP 方法鼓励团队进行结对编程，而且认为结对编程的组合应该动态地搭配，根据任务的不同、专业技能的不同进行最优组合。因此，每一个人都会遇到不同的代码，代码的所有制就不再适合于私有，因为那样会给修改工作带来巨大的不便。所谓集体代码所有制，就是团队中的每个成员都拥有对代码进行改进的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时，XP 强调代码是谁破坏的（修改后出现问题），就应该由谁来修复。</li>
<li>持续集成<br />
  在前面谈到小型发布、重构、结对编程、集体代码所有制等最佳实践的时候，多次提到“持续集成”，可以说持续集成是这些最佳实践的基本支撑条件。</li>
<li>每周工作 40 小时<br />
  XP 方法认为，加班最终会扼杀团队的积极性，最终导致项目的失败，这也充分体现了 XP 方法关注人的因素比关注过程的因素更多一些。不过，有一点是需要解释的，“每周工作 40 小时”中的“40”不是一个绝对数，它所代表的意思是团队应该保证按照“正常的时间” 进行工作。</li>
<li>现场客户<br />
  为了保证开发出来的结果与客户的预想接近，XP 方法认为最重要的是将客户请到开发现场。就像计划游戏中提到过的，在 XP 项目中，应该时刻保证客户负责业务决策，开发团队负责技术决策。因此，在项目中有客户在现场明确用户故事，并做出相应的业务决策，对于 XP 项目而言有着十分重要的意义。</li>
<li>编码标准<br />
  XP 方法的编码标准的目的不是创建一个事无巨细的规则列表，而是要能够提供一个确保代码清晰，便于交流的指导方针。</li>
</ol>
<h3 id="642-特征驱动开发"><a class="markdownIt-Anchor" href="#642-特征驱动开发"></a> 6.4.2 特征驱动开发</h3>
<p>  FDD 是一个迭代的开发模型。FDD 的每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供精确的项目进度报告和状态信息。同敏捷方法一样，FDD 弱化了过程在软件开发中的地位。虽然 FDD 中也定义了开发的过程，不过一个几页纸就能完全描述的过程深受开发者的喜爱。</p>
<h4 id="1fdd角色定义"><a class="markdownIt-Anchor" href="#1fdd角色定义"></a> 1．FDD角色定义</h4>
<p>  FDD 认为，有效的软件开发不可缺少的三个要素是：<code>人</code>、<code>过程</code>和<code>技术</code>。软件开发不能没有过程，也不能没有技术，但软件开发中最重要的是人。个人的生产率和人的技能将会决定项目的成败。为了让项目团队能够紧密地工作在一起，FDD 定义了 6 种关键的项目角色：</p>
<ol>
<li>项目经理<br />
  项目经理是开发的组织者，但项目经理不是开发的主宰。对于项目团队来说，项目经理应该是团队的保护屏障。他将同团队外界（如高层领导、人事甚至写字楼的物业管理员）进行沟通，努力为团队提供一个适宜的开发环境。</li>
<li>首席架构设计师<br />
  负责系统架构的设计。</li>
<li>开发经理<br />
  开发经理负责团队日常的开发，解决开发中出现的技术问题与资源冲突。</li>
<li>主程序员<br />
  主程序员将带领一个小组完成特征的详细设计和构建的工作，一般要求主程序员具有一定的工作经验，并能够带动小组的工作。</li>
<li>程序员<br />
  若干个程序员在主程序员的带领下形成一个开发小组，按照特征开发计划完成开发。</li>
<li>领域专家<br />
  领域专家是对业务领域精通的人，一般由客户、系统分析员等担当。领域专家作为关键的项目角色正是敏捷宣言中“业务人员同开发人员紧密合作”的体现。</li>
</ol>
<p>  根据项目规模的大小，有些角色是可以重复的。例如在一个小规模项目中，项目经理自身的能力很强，他就可以同时担当项目经理、首席架构设计师和开发经理的角色。</p>
<h4 id="2核心过程"><a class="markdownIt-Anchor" href="#2核心过程"></a> 2．核心过程</h4>
<p>  FDD 共有 5 个核心过程，如下图所示。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/saOaGD"><img src="https://s3.ax1x.com/2021/01/14/saOaGD.png" alt="FDD核心过程" /></a></p>
<ol>
<li>开发整体对象模型<br />
  开发整体对象模型也就是<code>业务建模</code>的阶段。不过 FDD 强调的是系统地完整地面向对象建模，这种做法有助于把握整个系统，而不仅仅关注系统中的若干个点。在这一阶段，<code>领域专家和首席架构设计师</code>相互配合，完成整体对象模型。</li>
<li>构造特征列表<br />
  完成系统建模后，需要构造一个完整的特征列表。所谓特征指的是一个小的、对客户有价值的功能。采用动作、结果和目标来描述特征，特征的粒度最好可以在两周之内实现。在这一阶段中，可以整理出系统的需求。</li>
<li>计划特征开发<br />
  任何一个软件项目都必须有计划——无论是重载方法还是敏捷方法。在这一阶段中，<code>项目经理</code>根据构造出的特征列表、特征间的依赖关系进行计划，安排开发任务。</li>
<li>特征设计<br />
  在这一阶段，<code>主程序员</code>将带领特征小组对特征进行详细设计，为后面的构建做准备。</li>
<li>特征构建<br />
  特征构建和特征设计这两个阶段合并起来可以看做特征的实现阶段，这两个阶段反复地迭代，直到完成全部的开发。</li>
</ol>
<h4 id="3最佳实践"><a class="markdownIt-Anchor" href="#3最佳实践"></a> 3．最佳实践</h4>
<p>  组成 FDD 的最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性。<br />
  其中最有特色的莫过于<code>类的个体所有</code>。几乎所有的开发模型都是代码共有，程序员们负责开发系统中的全部代码，并通过配置管理和变更控制来保持代码的一致性。在 FDD 中，<code>将类分配给特定的任何小组</code>，分配给 A 成员的代码将全部由 A 来维护，除 A 外的角色都不能修改它，只能使用它。这样做当然有它的优点：个人对所分配的类很容易保持概念的完整性；开发类代码的人肯定是最熟悉这个类的主人；而对这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过 FDD 也提到了类个体所有的缺陷：项目中的依赖关系增强、当 A 需要 B 修改他自己的类时，必须等待 B 完成修改才能使用；类的个体所有增加了员工离职的损失。面对这些优点和缺陷，显然 FDD 认为类的个体所有对系统开发更有帮助。<br />
  除类的个体所有外，<code>审查</code>也是 FDD 中很具特色的一项实践。不少人都认为审查是非常严格的软件过程所特有的，因为进行审查不但要花费不少的人力和时间，对审查者本身的素质也有要求。然而在 FDD 中，明确地将审查作为一项最佳实践提出。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格审查制度保证软件质量。有效的审查可以发现很多潜在的问题，而这些问题往往是无法通过测试发现的，例如建模、需求和设计期的缺陷。这些潜在的缺陷大多要到系统测试甚至发布后才能发现，修正这些缺陷的代价是很大的。</p>
<h3 id="643-scrum"><a class="markdownIt-Anchor" href="#643-scrum"></a> 6.4.3 Scrum</h3>
<p>  Scrum 是一个用于开发和维持复杂产品的框架，是一个增量的、迭代的开发过程。在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个 Sprint，每个 Sprint 的建议长度是 2 到 4 周(互联网产品研发可以使用 1 周的 Sprint)。在 Scrum 中，使用产品 Backlog 来管理产品的需求，产品 Backlog 是一个按照商业价值排序的需求列表，列表条目的体现形式通常为<code>用户故事</code>。Scrum 团队总是先开发对客户具有较高价值的需求。<br />
  在 Sprint 中，Scrum 团队从产品 Backlog 中挑选最高优先级的需求进行开发。挑选的需求在 Sprint 计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为 Sprint backlog。在每个迭代结束时，Scrum 团队将递交潜在可交付的产品增量。<br />
  Scrum 起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。Scrum 的基本流程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/swwUmt"><img src="https://s3.ax1x.com/2021/01/15/swwUmt.png" alt="Scrum流程图" /></a></p>
<h4 id="1scrum-的五个活动"><a class="markdownIt-Anchor" href="#1scrum-的五个活动"></a> 1．Scrum 的五个活动</h4>
<p>  Scrum 主要包括：产品待办事项列表梳理、Sprint 计划会议、每日 Scrum 会议、Sprint评审会议、Sprint 回顾会议等五个活动。</p>
<ol>
<li>产品待办事项列表梳理<br />
  产品待办事项通常会很大，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表梳理是一个始终贯穿整个 Scrum 项目的活动。该活动包含但不限于以下的内容：保持产品待办事项列表有序、把看起来不再重要的事项移除或者降级、增加或提升涌现出来的或变得更重要的事项、将事项分解成更小的事项、将事项归并为更大的事项、对事项进行估算。<br />
  产品待办事项列表梳理的一个最大好处是为即将到来的几个 Sprint 做准备。为此，梳理时会<code>特别关注那些即将被实现的事项</code>。需要考虑不少因素，这包括但不限于以下的内容：<br />
  理想情况下，下一个 Sprint 的备选事项都应该提升“商业价值”。开发团队需要能够在一个 Sprint 内完成每一个事项。每个人都需要清楚预期产出是什么。<br />
  产品开发决定了，有可能需要其他的技能和输入。因此，产品待办事项列表梳理最好是所有团队成员都参与的活动，而不单单是产品负责人。</li>
<li>Sprint 计划会议<br />
  每个 Sprint 都以 Sprint 计划会议作为开始，这是一个<code>固定时长</code>的会议，在这个会议中，Scrum 团队共同选择和理解在即将到来的 Sprint 中要完成的工作。<br />
  整个团队都要参加 Sprint 计划会议。针对排好序的产品待办事项列表（Product Backlog），产品负责人和开发团队成员讨论每个事项，并对该事项达成共识，包括根据当前的“完成的定义”，为了完成该事项所需要完成的所有事情。所有的 Scrum 会议都是限定时长的。Sprint 计划会议推荐时长是 Sprint 中的<code>每周对应两小时</code>或者更少（例如，一个 Sprint 包含 2 个星期，则 Sprint 计划会议时长应为 4 个小时或者更少）。因为会议是限制时长的,Sprint 计划会议的成功十分依赖于产品待办事项列表的质量。这就是产品待办事项列表梳理十分重要的原因。<br />
  在 Scrum 中，Sprint 计划会议有两部分：<br />
  <code>第一部分：需要完成哪些工作？</code><br />
  在会议的第一部分，产品负责人向开发团队介绍<code>排好序的产品待办事项</code>，整个 Scrum 团队共同理解这些工作。<br />
  Sprint 中需要完成的产品待办事项数目完全由开发团队决定。为了决定做多少，开发团队需要考虑当前产品增量的状态，团队过去的工作情况，团队当前的生产能力，以及排好序的产品待办事项列表。做多少工作只能由开发团队决定。产品负责人或任何其他人，都不能给开发团队强加更多的工作量。<br />
  通常 Sprint 都有个目标，称作 Sprint 目标。这将十分有效地帮助大家更加专注于需要完成的工作的本质，而不必花太多精力去关注那些对于我们需要完成的工作并不重要的小细节。<br />
  <code>第二部分：如何完成工作？</code><br />
  在会议的第二部分里，开发团队需要根据当前的“完成的定义”一起决定如何实现下一个产品增量。他们进行足够的设计和计划，从而有信心可以在 Sprint 中完成所有工作。前几天的工作会被分解成小的单元，每个工作单元不超过一天。之后要完成的工作可以稍大些，以后再对它们进行分解。<br />
  决定如何完成工作是开发团队的职责，决定做什么则是产品负责人的职责。在计划会议的第二部分，产品负责人可以继续留下来回答问题，以及澄清一些误解。<br />
  不管怎样，团队应该很容易找到产品负责人。<br />
  Sprint 计划会议最终需要 Scrum 团队对 Sprint 需要完成工作的数量和复杂度达成共识，并预期在一个合理的条件范围内完成它们。开发团队预测并共同承诺他们要完成的工作量。总而言之：在 Sprint 计划会议中，开发团队和产品负责人一起考虑并讨论产品待办事项，确保他们对这些事项的理解，选择一些他们预测能完成的事项，创建足够详细的计划来确保他们能够完成这些事项。<br />
  最终产生的待办事项列表就是“Sprint 待办事项列表（Sprint Backlog）”。</li>
<li>每日 Scrum 会议<br />
  开发团队是自组织的。开发团队通过每日 Scrum 会议来确认他们仍然可以实现 Sprint 的目标。这个会议<code>每天在同样的时间和同样的地点</code>召开。每一个开发团队成员需要提供以下三点信息：<br />
  从上一个每日 Scrum 到现在，我完成了什么；从现在到下一个每日 Scrum，我计划完成什么；有什么阻碍了我的进展。<br />
  每日 Scrum 中可能有简要的问题澄清和回答，但是不应该有任何话题的讨论。通常，许多团队会在每日 Scrum 之后马上开会处理他们遇到的任何问题。<br />
  每日 Scrum 既不是向管理层汇报，也不是向产品负责人或者 ScrumMaster 汇报。它是一个开发团队<code>内部的沟通会议</code>，来保证他们对现状有一致的了解。只有 Scrum 团队的成员，包括 ScrumMaster 和产品负责人，可以在会议中发言。其他感兴趣的人可以来旁听。在必要时，开发团队会基于会议中的发现重新组织他们的工作来完成 Sprint 的目标。<br />
  每日 Scrum 是 Scrum 的一个关键组成部分，它可以带来透明性,信任和更好的绩效。它能帮助快速发现问题，并促进团队的自组织和自立。所有 Scrum 会议都是限定时长的。每日 Scrum 通常<code>不超过 15 分钟</code>。</li>
<li>Sprint 评审会议<br />
  Sprint 结束时，Scrum 团队和相关人员一起评审 Sprint 的产出。Sprint 评审会议的推荐时长是 Sprint 中的每一周对应一个小时（例如，一个 Sprint 包含 2 个星期，则 Sprint 评审会议时长为 2 个小时）。<br />
  讨论围绕着 Sprint 中完成的产品增量。由于 Sprint 的产出会涉及一些人的“利益”，因此一个明智的做法是邀请他们参加这个会议，这会很有帮助。这个会议是个非正式的会议,帮助大家了解我们目前进展到哪里，并一起讨论我们下一步如何推进。每个人都可以在Sprint 评审会议上发表意见。当然，产品负责人会对未来做出最终的决定，并适当地调整产品待办事项列表 Product Backlog。<br />
  团队会找到他们自己的方式来开 Sprint 评审会议。通常会演示产品增量,整个小组也会经常讨论他们在 Sprint 中观察到了什么、有哪些新的产品想法出现。他们还会讨论产品待办事项列表的状态、可能的完成日期以及在这些日期前能完成什么。Sprint 评审会议向每个人展示了当前产品增量的概况。因此，通常都会在 Sprint 评审会议中调整产品待办事项列表。</li>
<li>Sprint 回顾会议<br />
  在每个 Sprint 结束后,Scrum 团队会聚在一起开 Sprint 回顾会议,目的是回顾一下团队在流程人际关系以及工具方面做得如何。团队识别出哪些做得好,哪些做得不好,并找出潜在的改进事项,为将来的改进制定计划。Sprint 回顾会议的推荐时长是 Sprint 中的每一周对应一个小时（例如，一个 Sprint 包含 2 个星期，则 Sprint 回顾会议时长为 2 个小时）。<br />
  Scrum 团队总是在 Scrum 的框架内，改进他们自己的流程。</li>
</ol>
<h4 id="2scrum-的-5-大价值观"><a class="markdownIt-Anchor" href="#2scrum-的-5-大价值观"></a> 2．Scrum 的 5 大价值观</h4>
<p>  Scrum 的 5 大价值观为：</p>
<ul>
<li>承诺—愿意对目标做出承诺。</li>
<li>专注—把你的心思和能力都用到你承诺的工作上去。</li>
<li>开放—Scrum 把项目中的一切开放给每个人看。</li>
<li>尊重—每个人都有他独特的背景和经验。</li>
<li>勇气—有勇气做出承诺，履行承诺，接受别人的尊重。</li>
</ul>
<h3 id="644-水晶方法"><a class="markdownIt-Anchor" href="#644-水晶方法"></a> 6.4.4 水晶方法</h3>
<p>  水晶方法（Crystal），是由 Alistair Cockburn 和 Jim Highsmith 建立的敏捷方法系列，其目的是发展一种提倡“机动性的”方法，包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。<br />
  Crystal 家族实际上是一组经过证明、对不同类型项目非常有效的敏捷过程，它的发明使得敏捷团队可以根据其项目和环境选择最合适的 Crystal 家族成员（分为 Crystal Clear，Crystal Yellow，Crystal Orange 和 Crystal Red 分别适用于不同的项目）。水晶方法中，使用频度较高的是 Crystal Clear——透明水晶方法。透明水晶方法，适合于一个小团队来进行敏捷开发，人数在 6 人以下为宜。</p>
<p>  透明水晶方法有七大体系特征：</p>
<ol>
<li>经常交付<br />
  任何项目，无论大小、敏捷程度，其最重要的一项体系特征是每过几个月就向用户交付已测试的运行代码。如果你使用了此体系特征，你就会发现，“经常交付”的作用还是很让人吃惊的。<br />
  项目主办者根据团队的工作进展获得重要反馈。用户有机会发现他们原来的需求是否是他们真正想要的，也有机会将观察结果反馈到开发当中。开发人员打破未决问题的死结，从而实现对重点的持续关注。团队得以调整开发和配置的过程，并通过完成这些工作鼓舞团队的士气。</li>
<li>反思改进<br />
  在我们的开发中，时常会出现这样那样的问题，技术难题、各种烦心事等，这会在很大的程度上影响项目的进展。而且，如果其他任务对这项任务有依赖的话，那么其他的任务也会被推迟，这就很可能会导致项目的失败。<br />
  换句话说，如果我们能够经常在迭代会中及时地反思和改进，那么，这种事情应该是不会发生的，或者说发生了，也能够很快地找到解决方案去应对它。事实上，从慌乱的日常开发中，抽出一点时间来思考更为行之有效的工作方法就已经足够了。</li>
<li>渗透式交流<br />
  渗透交流就是信息流向团队成员的背景听觉，使得成员就像通过渗透一样获取相关信息。这种交流通常都是通过团队成员在同一间工作室内工作而实现的。若其中一名成员提出问题，工作室内的其他成员可以选择关注或不关注的态度，可以加入到这个问题的讨论当中来，也可以继续忙自己的工作。</li>
<li>个人安全<br />
  个人安全指的是当你指出困扰你的问题时，你不用担心受到报复。个人安全非常重要，有了它，团队可以发现和改正自身的缺点。没有它，团队成员们知而不言，缺点则愈发严重以至于损害整个团队。个人安全是迈向信任的第一步。有了信任，团队协作才能真正地实施，开发效率也就会直线上升的。</li>
<li>焦点<br />
  所谓“焦点”，就是确定首先要做什么，然后安排时间，以平和的心态开展工作。确保团队成员清楚地了解他们自己最重要的任务是什么，确保他们能够有充分的时间去完成这些任务。</li>
<li>与专家用户建立方便的联系<br />
  与专家用户持续建立方便的联系能够给团队提供：对经常交付进行配置以及测试的地方，关于成品质量的快速反馈，关于设计理念的快速反馈，最新的（用户）需求。</li>
<li>配有自动测试、配置管理和经常集成功能的技术环境<br />
  自动测试可以为开发人员在代码修改后就可以进行自动测试，并且能够发现存在的一些bug，以至开发人员能够及时地进行修改，对于他们来说，节省了时间，提高了效率，而且还不用为烦人的测试而苦恼。<br />
  配置管理系统允许人们不同步地对工作进行检查，可撤销更改，并且可以将某一系统设置保存后进行新系统的发布，当新系统出现问题，即可还原原系统的设置。<br />
  经常集成可以使得团队在一天之内对系统进行多次集成。其实，团队越频繁地对系统进行集成，他们就能够越快地发现错误，堆积到一起的错误也会越少，并使他们产生更新的灵感。<br />
  最好的团队是将这三大技术结合成“持续测试集成技术”。这样做他们可以在几分钟内发现因集成所产生的错误。</li>
</ol>
<h3 id="645-其他敏捷方法"><a class="markdownIt-Anchor" href="#645-其他敏捷方法"></a> 6.4.5 其他敏捷方法</h3>
<p>  除了上面介绍的几种敏捷方法，以下敏捷方法我们也需要掌握其基本特征。</p>
<ol>
<li>开放式源码<br />
  开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障（debug）的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。</li>
<li>ASD 方法<br />
  ASD (Adaptive Software Development)方法由 Jim Highsmith 提出，其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。</li>
</ol>
<h2 id="65-软件重用"><a class="markdownIt-Anchor" href="#65-软件重用"></a> 6.5 软件重用</h2>
<p>  软件重用技术是一种重要的软件开发方法，虽然至今软件重用技术还不够成熟，离理想中的软件工厂还有很长的路要走，但现有的一些重用技术（例如，中间件、应用服务器等）已经改变了开发过程。</p>
<h3 id="651-软件重用"><a class="markdownIt-Anchor" href="#651-软件重用"></a> 6.5.1 软件重用</h3>
<p>  软件产品与其他的产品不同，是抽象的，一旦产生就可以无限制地复制，因此重复利用软件产品的意义重大，可以节约大量的人力物力。软件重用指的是利用已经存在的软件元素建立新的软件系统，这其中的软件元素既可以是软件产品、源程序，也可以是文档、设计思想甚至是领域知识。软件重用可以直接提高软件的开发效率、降低软件的开发成本、缩短软件的开发周期、提高软件质量。</p>
<p>  常见的软件重用形式包括：</p>
<ol>
<li>源代码重用<br />
  这是最简单也是最常见的重用形式，但由于软件系统的复杂性，很难大规模地重用已有源代码。</li>
<li>架构重用<br />
  架构重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大的影响。</li>
<li>应用框架的重用<br />
  随着软件技术的发展，应用框架的重用变得越来越普遍，很多成熟的软件公司都建立了自己的开发框架。在开源社区中，世界各地的技术爱好者也在不断地推出应用了各种新技术的开发框架，例如，应用了 AOP（Aspect Oriented Programming，面向方面编程）技术的 Spring 等。</li>
<li>业务建模的重用<br />
  虽然不同的软件的业务领域各自不同，但人们还是总结出了一些常见领域的建模方法，重用这些领域模型可以降低因领域知识不足而造成的需求风险。</li>
<li>文档及过程的重用<br />
  软件文档和软件过程也是软件开发中不可或缺的元素，有效地重用这些文档和过程也有助于提高开发效率和软件质量、降低开发成本。</li>
<li>软件服务的重用<br />
  随着 Web 服务的提出，人们越来越关注服务的重用。SOA（Service-Oriented Architecture，面向服务的架构）提出了面向服务的软件架构，并定义了相应的标准。</li>
</ol>
<h3 id="652-构件技术"><a class="markdownIt-Anchor" href="#652-构件技术"></a> 6.5.2 构件技术</h3>
<p>  构件又称为组件，是一个自包容、可复用的程序集。首先，构件是一个程序集，或者说是一组程序的集合。这个集合可能会以各种方式体现出来，如源程序或二进制的代码。这个集合整体向外提供统一的访问接口，构件外部只能通过接口来访问构件，而不能直接操作构件的内部。<br />
  构件的两个最重要的特性是<code>自包容</code>与<code>可重用</code>。自包容指的是构件的本身是一个功能完整的独立体，构件内部与外部的功能界限清晰明确，可以独立配置与使用。而可重用既是构件的特点，也是构件出现的目的。使用构件技术实现软件复用，采用“搭积木”的方式生产软件，是软件人员的梦想。<br />
  构件的开发者和使用者往往不是相同的人或组织，所以必须定义构件的标准才能够消除其中的障碍。随着构件技术的发展，目前应用比较广泛的构件标准有 CORBA、Java Bean/EJB、COM/DCOM。</p>
<h2 id="66-基于架构的软件设计"><a class="markdownIt-Anchor" href="#66-基于架构的软件设计"></a> 6.6 基于架构的软件设计</h2>
<p>  基于架构的软件设计（Architecture-Based Software Design，ABSD）是一种架构驱动方法。这种方法有 3 个基础：</p>
<ol>
<li>功能的分解<br />
  在功能分解中，ABSD 方法使用已有的基于模块的内聚和耦合技术。</li>
<li>通过选择架构风格来实现质量和业务需求。</li>
<li>软件模板的使用<br />
  软件模板利用了一些软件系统的结构。</li>
</ol>
<p>  然而，对于设计方法来说，软件模板的使用是一个新概念，下面，我们进行简单的介绍。<br />
  软件模板是一个特殊类型的软件元素，包括描述所有这种类型的元素在共享服务和底层构造的基础上如何进行交互。软件模板还包括属于这种类型的所有元素的功能，这些功能的例子有：每个元素必须记录某些重大事件，每个元素必须为运行期间的外部诊断提供测试点等。在软件产品线系统中，软件模板显得格外重要，因为新元素的引入是一个通用的技术，这种技术用来使产品线架构适应一个特定的产品。<br />
  ABSD 方法是递归的，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，架构总是清晰的，这有助于降低架构设计的随意性。</p>
<h3 id="661-absd-方法与生命周期"><a class="markdownIt-Anchor" href="#661-absd-方法与生命周期"></a> 6.6.1 ABSD 方法与生命周期</h3>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sg8fsJ"><img src="https://s3.ax1x.com/2021/01/19/sg8fsJ.png" alt="ABSD 方法与生命周期" /></a></p>
<p>  上图描述了 ABSD 方法在生命周期中的位置。假设一个需求阶段至少部分地完成，从需求阶段（包括功能需求、质量和业务需求、约束等）获得了输出。ABSD 方法的输出是<code>三个视图的概念构件的集合</code>，包括能够产生每个概念构件的假定、软件模板的集合和那些已经做出的具体实现的决策，我们把具体实现决策当作附加约束来维护。<br />
  在 ABSD 方法中，必须记录所有做出的决策及这些决策的原理，这有利于决策的可跟踪性和决策评审。</p>
<p>  ABSD 方法的输入由下列部分组成：</p>
<ol>
<li>抽象功能需求，包括变化的需求和通用的需求；</li>
<li>用例（实际功能需求）；</li>
<li>抽象的质量和业务需求；</li>
<li>质量因素（实际质量和业务需求）；</li>
<li>架构选项；</li>
<li>约束。</li>
</ol>
<p>  下面，我们描述需求阶段的假定输出，即 ABSD 方法的输入。</p>
<h4 id="1-抽象功能需求"><a class="markdownIt-Anchor" href="#1-抽象功能需求"></a> 1. 抽象功能需求</h4>
<p>  ABSD 方法假定需求阶段的输出之一是功能需求的抽象描述，包括这些需求的粗略变化的描述。当获取需求时，考虑所有最终用户是重要的。<br />
  对一个特定系统来说，通常有不同类型的最终用户。不同的系统管理员（数据库管理员、系统管理员、网络管理员等）都可以是最终用户。维护工程师也可以是系统的最终用户。总之，一个最终用户就是当系统运行时使用系统的任何人员。<br />
  与抽象功能需求相联系的是对公共需求和与这些需求相关的粗略变化的描述，在设计阶段，理解这些需求之间的依赖关系是至关重要的。<br />
  我们必须在某种抽象级别上获取功能需求，产品的详细需求往往要等具体产品开发完成后才能知道。当详细需求明确时，抽象功能的获取为详细需求提供了分类。</p>
<h4 id="2-用例"><a class="markdownIt-Anchor" href="#2-用例"></a> 2. 用例</h4>
<p>  如前所述，用例是一个或多个最终用户与系统之间的交互的具体表述，在这里，最终用户既可以是<code>操作人员</code>，也可以是与系统进行交互操作的其他<code>软件系统</code>。虽然用例很容易找到和创建，甚至可能有成百上千个，但是，因为我们需要分析用例，所以<code>必须限制用例的数量</code>。在架构设计阶段，只有重要的用例才有用。我们必须对所创建的用例进行分组、设置优先级，以便筛选出最重要的用例，剩下的用例可以在设计阶段的任何时候创建。</p>
<h4 id="3抽象的质量和业务需求"><a class="markdownIt-Anchor" href="#3抽象的质量和业务需求"></a> 3．抽象的质量和业务需求</h4>
<p>  我们必须对待构建系统的质量和业务需求进行编号，每个质量属性都包含一个特定的刺激，以及希望得到的响应。质量需求要尽量具体化。</p>
<h4 id="4架构选项"><a class="markdownIt-Anchor" href="#4架构选项"></a> 4．架构选项</h4>
<p>  对每个质量和业务需求，我们都要<code>列举能够满足该需求的所有可能的架构</code>。例如，如果需求是支持一系列不同的用户界面，则可能的架构选择就是把不同的用户界面分解成不同的构件。又如，如果需求是保持操作系统的独立性，则可能的架构选择就是构建虚拟的操作系统层，接受所有的操作系统调用，并解释之为当前操作系统所能支持。<br />
  在这个时候，只需列举所有可能的选项，而<code>不需要对这些架构选项进行决策</code>，这种列举取决于设计师的经验，既可来自某些书籍介绍，也可直接来自设计师本身的实践。</p>
<h4 id="5质量场景"><a class="markdownIt-Anchor" href="#5质量场景"></a> 5．质量场景</h4>
<p>  正如用例使功能需求具体化一样，质量场景使质量需求具体化。质量场景是质量需求的特定扩充。<br />
  与用例一样，质量场景也很容易找到和创建，可以创建很多个。我们必须对质量场景进行分组、设置优先级，只需<code>验证最重要的质量场景</code>。</p>
<h4 id="6约束"><a class="markdownIt-Anchor" href="#6约束"></a> 6．约束</h4>
<p>  约束是一个前置的设计决策，设计过程本身包含决策。某些决策可以直接由业务目标导出而无须考虑对设计的影响。例如，如果一个公司在某个中间件产品上投入了大量资金，那么在产品的选择上就可以不必考虑其他决策。在需求获取阶段，约束主要来自系统的业务目标。<br />
  在某些特殊情况下，约束由遗留系统决定。今天，几乎没有软件系统不参考已有系统的，常见的情况是，新老系统同时并存，或者新系统替代老系统，但是必须尽可能重用老系统的功能。在设计阶段，虽然这些遗留系统处于被设计系统的外部，但设计师必须考虑遗留系统的特征。也就是说，在某种程度上，遗留系统影响着当前的设计，因此，理解遗留系统的结构和解决问题的技术都很重要。出于商业目的，可能要求重用遗留系统的构件，这种需求就变成了约束。</p>
<h3 id="662-基于架构的软件开发模型"><a class="markdownIt-Anchor" href="#662-基于架构的软件开发模型"></a> 6.6.2 基于架构的软件开发模型</h3>
<p>  基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为<code>架构需求</code>、<code>设计</code>、<code>文档化</code>、<code>复审</code>、<code>实现</code>、<code>演化</code>等 6 个子过程，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sghqsg"><img src="https://s3.ax1x.com/2021/01/19/sghqsg.png" alt="基于架构的软件开发模型" /></a></p>
<h4 id="1架构需求"><a class="markdownIt-Anchor" href="#1架构需求"></a> 1．架构需求</h4>
<p>  需求是指用户对目标软件系统在<code>功能</code>、<code>行为</code>、<code>性能</code>、<code>设计约束</code>等方面的期望。架构需求受<code>技术环境</code>和<code>架构设计师的经验</code>影响。需求过程主要是获取用户需求，标识系统中所要用到的构件。架构需求过程如下图所示。如果以前有类似的系统架构的需求，我们可以从需求库中取出，加以利用和修改，以节省需求获取的时间，减少重复劳动，提高开发效率。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sg4I0J"><img src="https://s3.ax1x.com/2021/01/19/sg4I0J.png" alt="架构需求过程" /></a></p>
<ol>
<li>需求获取<br />
  架构需求一般来自三个方面，分别是系统的质量目标、系统的业务目标和系统开发人员的业务目标。软件架构需求获取过程主要是定义开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足业务上的功能需求。与此同时，还要获得软件质量属性，满足一些非功能需求。</li>
<li>标识构件<br />
  在<code>架构需求过程图</code>中虚框部分属于标识构件过程，该过程为系统生成初始逻辑结构，包含大致的构件。这一过程又可分为三步来实现。
<ul>
<li>第一步：生成类图。生成类图的工具有很多，例如 Rational Rose 就能自动生成类图。</li>
<li>第二步：对类进行分组。在生成的类图基础上，使用一些标准对类进行分组可以大大简化类图结构，使之更清晰。一般地，与其他类隔离的类形成一个组，由泛化关联的类组成一个附加组，由聚合或组合关联的类也形成一个附加组。</li>
<li>第三步：把类打包成构件。把在第二步得到的类簇打包成构件，这些构件可以分组合并成更大的构件。</li>
</ul>
</li>
<li>需求评审<br />
  组织一个由不同代表（如分析人员、客户、设计人员、测试人员）组成的小组，对架构需求及相关构件进行仔细的审查。审查的主要内容包括所获取的需求是否真实反映了用户的要求，类的分组是否合理，构件合并是否合理等。<br />
  必要时，可以在“需求获取—标识构件—需求评审”之间进行迭代。</li>
</ol>
<h4 id="2架构设计"><a class="markdownIt-Anchor" href="#2架构设计"></a> 2．架构设计</h4>
<p>  架构需求用来激发和调整设计决策，不同的视图被用来表达与质量目标有关的信息。架构设计是一个迭代过程，如果要开发的系统能够从已有的系统中导出大部分，则可以使用已有系统的设计过程。软件架构设计过程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sgIqsO"><img src="https://s3.ax1x.com/2021/01/19/sgIqsO.png" alt="架构设计过程" /></a></p>
<ol>
<li>提出软件架构模型<br />
  在建立架构的初期，选择一个合适的架构风格是首要的。在这个风格基础上，开发人员通过架构模型，可以获得关于架构属性的理解。此时，虽然这个模型是理想化的（其中的某些部分可能错误地表示了应用的特征），但是该模型为将来的实现和演化过程建立了目标。</li>
<li>把已标识的构件映射到软件架构中<br />
  把在架构需求阶段已标识的构件映射到架构中，将产生一个中间结构，这个中间结构只包含那些能明确适合架构模型的构件。</li>
<li>分析构件之间的相互作用<br />
  为了把所有已标识的构件集成到架构中，必须认真分析这些构件的相互作用和关系。</li>
<li>产生软件架构<br />
  一旦决定了关键的构件之间的关系和相互作用，就可以在第 2 阶段得到的中间架构的基础上进行细化。</li>
<li>设计评审<br />
  一旦设计了软件架构，我们必须邀请独立于系统开发的外部人员对架构进行评审。</li>
</ol>
<h4 id="3架构文档化"><a class="markdownIt-Anchor" href="#3架构文档化"></a> 3．架构文档化</h4>
<p>  绝大多数的架构都是抽象的，由一些概念上的构件组成。例如，层的概念在任何程序设计语言中都不存在。因此，要让系统分析师和程序员去实现架构，还<code>必须得把架构进行文档化</code>。文档是在系统演化的每一个阶段，系统设计与开发人员的通信媒介，是为验证架构设计和提炼或修改这些设计（必要时）所执行预先分析的基础。<br />
  架构文档化过程的主要输出结果是<code>架构需求规格说明</code>和<code>测试架构需求的质量设计说明书</code>这两个文档。生成需求模型构件的精确的形式化的描述，作为用户和开发者之间的一个协约。<br />
  软件架构的文档要求与软件开发项目中的其他文档是类似的。文档的完整性和质量是软件架构成功的关键因素。文档要从使用者的角度进行编写，必须分发给所有与系统有关的开发人员，且必须保证开发者手上的文档是最新的。</p>
<h4 id="4架构复审"><a class="markdownIt-Anchor" href="#4架构复审"></a> 4．架构复审</h4>
<p>  架构设计、文档化和复审是一个迭代过程。从这个方面来说，在一个主版本的软件架构分析之后，要安排一次由<code>外部人员</code>（用户代表和领域专家）参加的复审。<br />
  复审的目的是<code>标识潜在的风险</code>，以及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否在设计中得到体现、层次是否清晰、构件的划分是否合理、文档表达是否明确、构件的设计是否满足功能与性能的要求等等。<br />
  由外部人员进行复审的目的是保证架构的设计能够公正地进行检验，使组织的管理者能够决定正式实现架构。</p>
<h4 id="5架构实现"><a class="markdownIt-Anchor" href="#5架构实现"></a> 5．架构实现</h4>
<p>  所谓“实现”就是要用实体来显示出一个软件架构，即要符合架构所描述的结构性设计决策，分割成规定的构件，按规定方式互相交互。架构的实现过程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sgTd4s"><img src="https://s3.ax1x.com/2021/01/19/sgTd4s.png" alt="架构实现过程" /></a></p>
<p>  上图中的虚框部分是架构的实现过程。整个实现过程是以复审后的文档化的架构说明书为基础的，每个构件必须满足软件架构中说明的对其他构件的责任。这些决定即实现的约束是在系统级或项目范围内做出的，每个构件上工作的实现者是看不见的。<br />
  在架构说明书中，已经定义了系统中构件与构件之间的关系。因为在架构层次上，构件接口约束对外唯一地代表了构件，所以可以从构件库中查找符合接口约束的构件，必要时开发新的满足要求的构件。<br />
  然后，按照设计提供的结构，通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成。<br />
  最后一步是测试，包括单个构件的功能性测试和被组装应用的整体功能和性能测试。</p>
<h4 id="6架构演化"><a class="markdownIt-Anchor" href="#6架构演化"></a> 6．架构演化</h4>
<p>  在构件开发过程中，最终用户的需求可能还有变动。在软件开发完毕，正常运行后，由一个单位移植到另一个单位，需求也会发生变化。在这两种���况下，就必须相应地修改软件架构，以适应新的软件需求。架构演化过程如下图所示。架构演化是<code>使用系统演化步骤去修改应用</code>，以满足新的需求。主要包括以下七个步骤：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sg7NM6"><img src="https://s3.ax1x.com/2021/01/19/sg7NM6.png" alt="架构演化过程" /></a></p>
<ol>
<li>需求变动归类<br />
  首先必须对用户需求的变化进行归类，使变化的需求与已有构件对应。对找不到对应构件的变动，也要做好标记，在后续工作中，将创建新的构件，以对应这部分变化的需求。</li>
<li>制订架构演化计划<br />
  在改变原有结构之前，开发组织必须制订一个周密的架构演化计划，作为后续演化开发工作的指南。</li>
<li>构件变动<br />
  修改、增加或删除构件在演化计划的基础上，开发人员可根据在第一步得到的需求变动的归类情况，决定是否修改或删除存在的构件、增加新构件。最后，对修改和增加的构件进行功能性测试。</li>
<li>更新构件的相互作用<br />
  随着构件的增加、删除和修改，构件之间的控制流必须得到更新。</li>
<li>构件组装与测试<br />
  通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成，形成新的架构。然后对组装后的系统的整体功能和性能进行测试。</li>
<li>技术评审<br />
  对以上步骤进行确认，进行技术评审。评审组装后的架构是否反映需求变动，符合用户需求。如果不符合，则需要在第 2 到第 6 步之间进行迭代。</li>
<li>演化后的架构<br />
  在原来系统上所作的所有修改必须集成到原来的架构中，完成一次演化过程，产生演化后的架构。</li>
</ol>
<h2 id="67-形式化方法"><a class="markdownIt-Anchor" href="#67-形式化方法"></a> 6.7 形式化方法</h2>
<p>  形式化方法是指采用严格的数学方法，使用形式化规约语言来精确定义软件系统。非形式化的开发方法是通过自然语言、图形或表格描述软件系统的行为和特性，然后基于这些描述进行设计和开发，而形式化开发则是基于数学的方式描述、开发和验证系统。<br />
  形式化方法包括形式化描述和基于形式化描述的形式化验证两部分内容。形式化描述就是用形式化语言进行描绘，建立软件需求和特性，即解决软件“做什么”的问题。形式化验证指的是验证已有的程序是否满足形式化描述的定义。形式化描述主要可以分为两类，一类是通过建立计算模型来描述系统的行为特性，另一类则通过定义系统必须满足的一些属性来描述系统。形式化描述又称之为形式化规约，相对于自然语言描述，形式化描述是精确的、可验证的，避免了模糊性与二义性，消除需求中相互矛盾的地方，避免需求定义人员和开发人员对需求的理解偏差。<br />
  形式化描述可以通过计算机技术进行自动处理，进行一致性的检查和证明，提高需求分析的效率和质量。通过形式化描述，需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现，并得到解决，从而降低后期开发和维护的成本，并提升软件的质量和可靠性。<br />
  在一些要求高可靠性的关键应用上，采用形式化开发方法可以保证软件系统的可靠性。</p>
<p>  在非形式化开发中，关键应用系统的软件的单元测试和集成测试都是非常重要的工作，通常要付出高昂的代价。形式化开发的优点可见一般。</p>
<h1 id="第七章-系统规划"><a class="markdownIt-Anchor" href="#第七章-系统规划"></a> 第七章 系统规划</h1>
<p>  系统计划主要用于描述从项目提出、选择到确立的过程，包括系统项目的提出与可行性分析，系统方案的制订、评价和改进，新旧系统的分析和比较，以及现有软件、硬件和数据资源的有效利用等问题。</p>
<h2 id="71-项目的提出与选择"><a class="markdownIt-Anchor" href="#71-项目的提出与选择"></a> 7.1 项目的提出与选择</h2>
<p>  组织在信息化的过程中，可能基于各种动机提出系统项目的建设，有关人员要根据这些动机，提出和确定信息系统的工作范围，确定项目立项，提出系统选择方案，给出选择结果。</p>
<h3 id="711-项目的立项目标和动机"><a class="markdownIt-Anchor" href="#711-项目的立项目标和动机"></a> 7.1.1 项目的立项目标和动机</h3>
<p>  企事业单位在其自身的经营管理过程中，对于项目的立项建设可能具有多种动机，通常可归结为下列几种。</p>
<ol>
<li>进行基础研究并获取技术<br />
  此类项目通常由大学院校或企业集团的战略研究性部门提出和实施。小规模的研究组织可能仅仅是企业中的一个研发部门或从事研发工作的团队；中大规模的研究组织包括研究所或研究院这种独立建制的单位；大规模的研究性项目可类似于国家 863 计划等跨行业、跨地域协作的国家级重大项目立项。</li>
<li>进行应用研发并获得产品<br />
  此类项目通常由企业进行立项和开发，企业立项的基本动机通常是为了得到应用软件产品并向目标客户群进行销售从而获取利润等。产品一般会基于某类特定客户群体的需求进行设计，有明确和具体的研发目标需求，有严格的时间限制、资源预算等，因此可归入 “应用研发”型软件。<br />
  应用研发型软件通常具有一定的通用性，客户广泛，既可能是面向个人消费者的工具软件（例如 Office、杀毒软件、游戏软件等），也可能是面向特定领域或行业的工具软件（例如 SQL Server 数据库、AutoCAD 工程绘图软件、Rational Rose 这样的建模工具软件等）。</li>
<li>提供技术服务<br />
  对此类项目进行立项的企业通常能向目标客户群提供比较全面的技术服务而不是单一的软件产品。因此企业的服务范围可能包含提供技术和解决方案的咨询、利用现有产品进行系统集成和服务、面向特定客户的软件项目定制开发、对现有的软件系统进行升级和改造、提供软件应用相关的技术支持、服务和培训等服务中的一个或多个内容。<br />
  总的来说，此类组织通常会面向一个特定行业、具有相对稳定性的客户群体，通过提供一种综合性服务来获取市场价值，因此可以把此类公司看做“服务”导向的组织。</li>
<li>信息技术产品的使用者<br />
  信息技术的使用者是最终客户。对他们来说，软件项目的立项动机既不是为了得到软件产品而进行销售，也不是为了提供技术服务，而是通过购买产品或服务来得到使用价值。例如：一个消费者购买了绘图软件是为了存储和处理个人数码相机中的照片；而一个企业通过实施 ERP（Enterprise Resource Planning，企业资源计划）可能是为了达到生产能力的控制、生产计划科学性、提高管理水平、获取新的决策能力、降低库存成本、提高资金周转率、建立面向市场订单生产方式等目标，并期望通过这些目标的实现来增强企业竞争力、获取更大的市场份额。对信息技术的使用者来说，信息技术是一种手段，同时也是一种成本。如何用最小的成本和风险获得满意的效果是客户最关心的问题。</li>
</ol>
<h3 id="712-项目的选择和确定"><a class="markdownIt-Anchor" href="#712-项目的选择和确定"></a> 7.1.2 项目的选择和确定</h3>
<p>  系统项目的选择至少包含两种实用性目的，一个是软件开发公司在诸多的产品方向中<code>选择适当的方向</code>进行研究和开发，另一种是客户从诸多的产品中购买<code>适合自己需要的产品或技术方案</code>进行实施。与系统项目提出的问题一样，并不存在一个统一模式进行系统项目的选择和取舍，但可以提出进行项目取舍和评估的若干原则。通过使用项目取舍和评估的原则，可以逐步排除那些不符合需求的项目定义，从而找到比较适合的项目或产品开发方向。</p>
<h4 id="1选择有核心价值的产品项目或开发方向"><a class="markdownIt-Anchor" href="#1选择有核心价值的产品项目或开发方向"></a> 1．选择有核心价值的产品/项目或开发方向</h4>
<p>  这个策略关键在于确定什么样的系统项目是有价值的。由于立项单位所处的行业、在行业中的位置、立项目标等因素不同，对软件项目的价值判断也不同。但“有核心价值的软件项目”通常总是和企业或客户的核心业务相关的。<br />
  美国哈佛商学院的著名教授Michael Porter曾经在他的《竞争优势》（CompetitiveAdvantage）一书中提出了<code>“价值链”</code>的概念，价值链把企业运作的各种活动划分为产品设计、产品生产、产品营销和产品应用等独立领域，企业的价值链也可以进一步和上游供货商与下游买主的价值链相连，从而构成一个产业的价值链。如果以“价值链”的观点来看待软件产品或项目，软件是作为一种技术服务手段被运用到企业业务的价值链上的，通过实现价值链中的关键业务的信息化从而最终改善客户单位的企业质量，同时也使软件开发公司获得现实的经济利益。<br />
  因此，在企业或客户经营活动中对价值链增值最大的部分，就是企业或客户的“核心业务”。针对核心业务的信息化产品或项目，通常都是具有高价值的，也可以说，所谓的 “行业信息化”的关键就是该行业中这些核心业务的信息化改造。例如：</p>
<ol>
<li>对生产制造业的企业来说，生产计划、库存控制、实现面向订单的生产就是核心业务，无论实施 ERP 还是小规模的 MIS 系统，针对这些部分的软件功能总是被客户认为是最有价值的。</li>
<li>对于金融保险行业来说，由于保险公司的基本职责是分摊风险和补偿损失，所以一般要求保险公司有足够的分散风险的能力。因此，管理保单数据的业务系统、评估风险的定损系统等就是非常有价值的软件系统。</li>
<li>对于教育行业来说，因为学校的核心职能是教书育人，因此与教研、教学、考试、评价等业务相关的软件系统，以及支持上述业务开展的教育资源库软件、电子图书馆软件等就是高价值的软件系统。</li>
</ol>
<p>  总之，选择软件项目，必须首先考察软件应用的行业、业务和目标，以便判明要建设的软件项目价值。</p>
<h4 id="2评估项目风险-收益和代价"><a class="markdownIt-Anchor" href="#2评估项目风险-收益和代价"></a> 2．评估项目风险、收益和代价</h4>
<p>  在判断出一个潜在的软件项目后，还应评估项目实施的风险、收益和维护付出的代价。对于开发产品进行销售的情况，主要评估的是产品的预期收益和为完成开发投入的各种资源（包括时间、人力、资金等），项目的风险主要是技术难度、技术能力、经济能力和各种资源是否能承担、是否是企业需要优先实施的项目、是否符合行业标准和国家政策规定（例如：在电子签章没有经过国家法律许可之前，使用电子签章替代手工操作可能是有风险的）等。<br />
  对于购买产品或技术服务的客户来说，还应该评估项目实施后对自身业务变更，组织机构和人员职责的影响，现有的业务流程和人员的 IT 技能是否能满足要求，是否需制定相关的系统维护、运行规约和规章制度等。而项目实施的实际开销，除购买产品或服务的开支外，通常还包括各种系统维护、改进、培训，招聘新职员，变更业务流程等各种应用方面的开销。以总持有成本（Total Owner Cost，TOC）来评估信息化的代价才能比较准确地得到项目的实际代价。<br />
  评估项目风险、预期收益和代价后，可筛选掉多数不符合企业要求的建议项目。</p>
<h4 id="3评估项目的多种实施方式"><a class="markdownIt-Anchor" href="#3评估项目的多种实施方式"></a> 3．评估项目的多种实施方式</h4>
<p>  对于已经确认有价值、并且有能力开发的软件项目，则可以进一步参照企业现状考察项目的实施方式。这种实施方式通常既包括了前面对项目风险、预期收益和资源开销的评估，也包含了企业对现阶段经营目标和现有资源如何合理运用的考虑。这个过程通常由项目的负责人和企业中高层经理进行决策，决策结果决定了项目的实施优先级及具体的实施方式。<br />
  需要说明的是，企业完成软件项目的方式并不单纯限制于自己组建开发团队进行软件项目或软件产品开发的策略。根据具体情况不同，还可能使用诸如转包开发业务给外部公司、直接 OEM（Original Equipment Manufacture，原始设备制造商）软件产品并进行系统集成、购买关键技术并进行“软件集成”方式的开发、完成技术方案和设计，然后寻求外部公司进行编码等各种方式。对这些项目实施方式的取舍，主要依据依然是对项目风险、收益和资源开销综合平衡的考虑。</p>
<h4 id="4平衡地选择适合的方案"><a class="markdownIt-Anchor" href="#4平衡地选择适合的方案"></a> 4．平衡地选择适合的方案</h4>
<p>  人们在选择可行的方案时，总是希望得到高质量、低成本的产品和方案。软件开发人员通常也很愿意在产品开发中，向产品加入创造性的内容。另一方面，客户单位在面对诸多的投标方案时，会听到各种各样关于技术先进性、快速开发、产品质量稳定可靠、价格如何低廉、推荐的方案有多少成功应用等宣传。然而：</p>
<ol>
<li>新技术可能意味着未来更多的变化从而导致风险，也意味着未来产品的使用者需要更多的学习和导入期，而采用成熟的技术则可能享受不到新技术带来的好处。</li>
<li>不基于某种快速开发技术或平台构造的产品可能会延长项目开发时间从而导致更多的开销，但基于某种平台的产品又可能使得用户未来“绑定”在某种平台之上，减少未来的自由选择性。</li>
<li>不考虑系统的扩展性则很可能在业务变更时，会受阻于已经实施的 IT 设施，但过多考虑系统的扩展性，软件接口通常就需要花费较大的力气进行设计，那么用户是否在当前的购买中为一些自己并不需要的特性多支付成本？尤其在软件技术高速发展的今天，当用户期望进行系统升级的时候，常常会发现原来的计算体系已经早就被开发单位淘汰和抛弃。</li>
<li>价格低廉的产品可能具有好的质量，也可能有些功能并不那么让人满意，而最重要的是，当关注这些具有先进性、低成本及拥有众多成功应用的产品或方案的时候，项目的选择者容易失去对自己目标的关注，即这些先进技术或宣传的产品特性是否确实是自己需要的？</li>
</ol>
<p>  事实上，对性能的要求常常是充满矛盾的，任何时候都不存在一个完美无缺的方案，只存在一个对当前的项目目标相对比较适合的方案。项目的决策者必须从最终的项目目标出发，判明各种功能或性能的重要性和优先级。在抛弃明显存在问题的“差”项目后，选择项目的基本立场应该是“适合”，而不是尽可能的“好”。（实际上任何超出预期设定目标的“好”性能，通常都意味着更多的成本。）<br />
  更进一步地看，“适合”的方案就是平衡考虑开发单位利益和客户满意度的方案。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sWYfHg"><img src="https://s3.ax1x.com/2021/01/20/sWYfHg.png" alt="顾客质量模型图" /></a></p>
<p>  上图是 Noriaki Kano 提出的顾客质量模型图，要求质量是客户认为产品应该具备的功能或性能，实现越多客户会越满意；假想质量是客户想当然认为产品应具备的功能或性能，客户并不能正确描述自己想当然要得到的这些功能或性能需求；兴奋质量则是客户要求范围外的功能或性能（但通常是软件开发者很乐意赋予产品的技术特性），实现这些性 能客户会更高兴，但不实现也不影响其购买的决策。<br />
  显然，项目开发方更多考虑的是项目风险和回报。而客户更多关心的是成本和购买后的满意度。好的方案必须平衡考虑这些因素。系统分析师应尽可能用技术手段来平衡这些彼此对立的要求，保证在项目预期投入资源可接受的范围内，尽量实现客户要求质量对应的功能和性能、发掘客户假想质量对应的功能要求并进行沟通确认，但按自身所服务企业的经营目标平衡考虑客户兴奋质量的实现策略（是努力提供兴奋质量的功能、争取忠诚的客户获得远期潜在的收益，还是削减这些功能、以便使项目的成本最小化）。</p>
<blockquote>
<p>系统设计师常犯的一个错误，就是用自己对技术的兴趣产生的兴奋质量，来替换客户最基本的要求质量和假想质量。而企业经营者常犯的错误，则可能是对客户提出的合理要求质量视而不见；或者走向另一个极端，不加区分地把一切未经评估的假想要求质量不断指派给软件开发团队。这些都是错误的做法。</p>
</blockquote>
<h3 id="713-项目提出和选择的结果"><a class="markdownIt-Anchor" href="#713-项目提出和选择的结果"></a> 7.1.3 项目提出和选择的结果</h3>
<p>  系统项目提出和选择的结果，最终会以“产品/项目建议书”的方式来体现。典型的应用场景是：</p>
<ol>
<li>在投标项目中，产品/项目建议书通常是乙方提交给甲方竞标方案的一部分；</li>
<li>企业单位在确立了要开发某类型产品后，对该产品进行多角度的评估，最终项目立项人向上级提交供决策的建议报告的主要内容就是“产品/项目建议书”。</li>
</ol>
<p>  产品/项目建议书是一个包含多种综合内容的报告，涉及的范围通常要比《GB8567-1988》标准中规定的标准——“项目可行性分析报告”的内容更全面。在项目建议书中，可能包含如下几个部分：</p>
<blockquote>
<p>用户单位、项目或产品的立项背景、需求来源和目标性的介绍；<br />
用户的内外部环境、组织机构、现有的 IT 设施情况等；<br />
用户的业务模型和业务规划；<br />
预期要建设的技术系统在用户业务中的位置和作用；<br />
信息化后的用户业务模型、软件应用方式、相关的部署环境、运行规则、管理规范等；<br />
为实现信息化业务模型，技术系统的产品需求定义（功能、性能、约束）和部署方式等；<br />
产品或项目的技术框架；<br />
项目的要点、技术难点、主要实施障碍等；<br />
项目或产品的可行性研究结果；<br />
项目可选择的实施方式、组织方式、沟通和协调机制等；<br />
项目的资源范围和预算（人、财、物、时间等）；<br />
项目的成本/收益分析；<br />
……</p>
</blockquote>
<p>  其他项目建议书可能包含的内容，或以单独文档列举的内容可能包括：</p>
<blockquote>
<p>项目风险及影响评估；<br />
项目进度计划；<br />
项目质量计划；<br />
项目过渡期资金的获得方式、财务计划；<br />
产品或项目的商务模式、盈利模式论述；<br />
同类产品或公司的市场调查结果，以及竞争性比较；<br />
企业成功案例、资质等；<br />
商务条款或供应商/客户合同；<br />
……</p>
</blockquote>
<p>  项目建议书标志着项目立项和选择阶段性工作的完成，一旦项目建议书被批准通过，项目即可进入正式的开发准备和实施阶段。</p>
<h2 id="72-可行性研究与效益分析"><a class="markdownIt-Anchor" href="#72-可行性研究与效益分析"></a> 7.2 可行性研究与效益分析</h2>
<p>  在项目计划和选择的过程中，需要完成的首要目标是对项目进行估算。项目估算的范围涉及方方面面，例如项目或产品开发的范围、投入和回报、项目风险、作用和意义等。在传统软件工程方法中，是以<code>可行性研究</code>的方式来组织项目的主要估算内容。<br />
  可行性研究的范围可能覆盖技术、经济、执行、环境等各种需要评估的因素，但它并不是最后的详细计划（例如：项目的时间进度及人员安排）。通常在进行可行性研究的阶段，项目的目标或产品的最终方向也是极易变化的。<br />
  但可行性研究的意义在于，虽然可行性研究不能指出项目最终的详细计划和方向，但可行性研究可以在项目定义阶段用较小的代价识别出错误构思的系统，从而规避未来更多的资源投入的损失（时间、资金、人力、机会），或者因遭遇到无法逾越的技术障碍或环境障碍导致的不可避免的失败。<br />
  对于那些可行性研究表明可执行的软件项目来说，可行性研究的结果也不承诺系统的收益一定很大或技术风险和资源投入就一定很低，但可行性研究的结果设立了一个“底线”，即如果做什么，风险和收益是什么样的控制范围。这些评估结果给了未来的项目评估、项目风险控制，甚至在资源剧烈变化的情况下有计划有重点地削减功能、重定义项目开发范围，提供了非常有价值的方向性指引。</p>
<h3 id="721-可行性研究的内容"><a class="markdownIt-Anchor" href="#721-可行性研究的内容"></a> 7.2.1 可行性研究的内容</h3>
<p>  可行性研究的主要内容包括<code>经济可行性</code>、<code>技术可行性</code>、<code>法律可行性</code>、<code>执行可行性</code>和<code>方案的选择</code> 5个部分。</p>
<h4 id="1经济可行性"><a class="markdownIt-Anchor" href="#1经济可行性"></a> 1．经济可行性</h4>
<p>  经济可行性主要评估项目的开发成本及项目成功后可能获得的经济收益。多数项目只有开发成本能控制在企业可接受的范围内的时候，项目才有可能被批准执行。而经济收益的考虑则非常广泛，例如：项目技术开发的直接现金收入、新产品在生命周期中预期的总销售收入、技术积累、对公司业务和产品线的完善和支持、开辟新市场和利润增长点、进入预期能带来较高收益的新市场、提高客户满意度和忠诚度、打击竞争对手抢夺市场份额、获得新的信息化能力从而改善经营或管理格局等。</p>
<h4 id="2技术可行性"><a class="markdownIt-Anchor" href="#2技术可行性"></a> 2．技术可行性</h4>
<p>  技术可行性评估对于假想的软件系统需要实现的功能和性能，以及技术能力约束。技术可行性分析可通过“提问—回答”的方式来进行论证，包括：</p>
<ol>
<li>技术<br />
  现有的技术能力和 IT 技术的发展现状足以支持想象中的系统目标实现吗？</li>
<li>资源<br />
  现有的资源（掌握技术的职员、公司的技术积累、构件库、软硬件条件等）足以支持项目实施吗？技术风险在评估的哪个范围内？</li>
<li>目标<br />
  在目前设定的系统目标中，哪些目标会遭遇到较强的技术障碍？尤其是那些被设定为必须实现的系统目标。</li>
</ol>
<p>  由于在可行性研究阶段，项目的目标是比较模糊的，因此技术可行性最好与项目功能、性能和约束的定义同时进行。在可行性研究阶段，调整开发目标和选择可行的技术体系均是可用的手段，而一旦项目进入开发阶段，任何调整都意味着更多的开销。<br />
  需要再次指出的是，技术可行性绝不仅仅是论证在技术上是否可实现，实际上还包含了在当前资源条件下的技术可行性。<br />
  投资不足、时间不足、预设的开发目标技术难度过大、没有足够的技术积累、没有熟练的职员可用、没有足够的合作公司和外包资源积累等均是技术可行性的约束。软件系统的技术评估者通常都只考虑技术手段是否能实现而忽视了当前的资源条件和环境，从而对技术可行性研究得出了过于乐观的结果，这种错误判断对后期的项目实施会导致灾难性的后果！<br />
  加强前期的项目调研、寻求专家的咨询以及采用具有大量成功应用案例、被广泛支持的技术标准和事实标准等均有助于改善项目的技术可行性。</p>
<h4 id="3法律可行性"><a class="markdownIt-Anchor" href="#3法律可行性"></a> 3．法律可行性</h4>
<p>  法律可行性评估可能由系统开发引发的侵权或法律责任，可能包括合同的订立和条款，职责、侵权情况的设定，违约、争议的解决等方方面面的内容。法律可行性还包括国家政策和法律的限制，例如：在政府信息化的领域中使用未被认可的加密算法或未经许可在产品中使用了其他公司被保护的软件技术、构件等。</p>
<h4 id="4执行可行性"><a class="markdownIt-Anchor" href="#4执行可行性"></a> 4．执行可行性</h4>
<p>  执行可行性也称操作可行性，它主要评估预期的软件系统在真实环境中能够被应用的程度和实施过程中障碍。例如：ERP 系统建成后的数据采集和数据质量问题，或客户工作人员没有足够的 IT 技能等。这些问题虽然与软件系统本身无关，但如果不经评估，很可能会导致投入巨资建成的软件系统毫无用处。<br />
  执行可行性还需要评估对用户的各种影响，包括对现有 IT 设施的影响、对用户组织机构的影响、对现有业务流程的影响、对地点的影响、对经费开支的影响等。如果某项影响会过多改变客户的现状，需要将这些因素作进一步的讨论并和软件系统的使用者进行沟通，提出建议的解决方法。</p>
<h4 id="5方案的选择"><a class="markdownIt-Anchor" href="#5方案的选择"></a> 5．方案的选择</h4>
<p>  评估系统或产品开发的可选方法。一般来说，同样的项目，可以采用不同的方法来实现。甚至一个大项目的若干个子系统的实现方法也不一样。如何进行系统分解、如何定义各子系统的功能、性能和界面，实现方案不唯一。可以采用折中的方法，反复比较各个方案的成本和效益，选择可行的方案。</p>
<h3 id="722-成本效益分析"><a class="markdownIt-Anchor" href="#722-成本效益分析"></a> 7.2.2 成本效益分析</h3>
<p>  效益分析实际上包含了“成本—收益”的分析。从内容上来看，效益分析是可以包含在可行性研究的经济可行性分析中的。但效益分析的目的在于，对项目开发目标的成本及可度量的项目现金收入和无形收益进行一次专门化的评估。这种以经济回报为收益的评估结果，是得到企业管理、决策层批准项目实施的重要因素。<br />
  效益分析中的成本分析，将尽可能地列举所有项目涉及的直接财务支出数字，以便管理层协调和制订各种资源的支出计划。效益分析中的收益分析，将尽可能清晰地列举实施项目带来的各种直接经济收益和无形收益，以便管理层理解项目的价值和给予项目资源上的支持。否则，一旦项目所需要的各种资源不能按计划投入，项目失败的风险将大大增加，并且除了变更项目预设的开发目标外，几乎没有可供选择的应急方案。</p>
<h4 id="1项目可能涉及的成本"><a class="markdownIt-Anchor" href="#1项目可能涉及的成本"></a> 1．项目可能涉及的成本</h4>
<p>  项目的成本部分，通常包括：</p>
<ul>
<li>基础建设支出<br />
  如房屋和设施，办公设备，平台软件，必需的工具软件等购置费用。</li>
<li>一次性支出<br />
  如研究咨询费用、调研费、管理费用、培训费、差旅费、其他一次性杂费等。</li>
<li>运行维护费用<br />
  如设备租金和定期维护费用、定期消耗品支出、通信费、人员工资奖金、房屋租金、公共设施维护及其他经常性的支出项目。</li>
</ul>
<h4 id="2项目可能涉及的收益"><a class="markdownIt-Anchor" href="#2项目可能涉及的收益"></a> 2．项目可能涉及的收益</h4>
<p>  项目的收益，通常可以分为<code>一次性收益</code>、<code>非一次性收益</code>和<code>不可定量的收益</code>三个部分。</p>
<ol>
<li>一次性收益
<ul>
<li>开支的缩减<br />
  包括改进了的系统的运行所引起的开支缩减，如资源要求的减少，运行效率的改进，数据进入、存储和恢复技术的改进，系统性能的可监控，软件的转换和优化，数据压缩技术的采用，处理的集中化和分布化等。</li>
<li>价值的增升<br />
  包括由于一个应用系统的使用价值的增升所引起的收益，如资源利用的改进，管理和运行效率的改进及出错率的减少等。</li>
<li>其他<br />
  如从多余设备出售回收的收入等。</li>
</ul>
</li>
<li>非一次性收益<br />
  在整个系统生命期内由于运行所建议系统而导致的按月的、按年的能用人民币表示的收益，包括开支的减少。</li>
<li>不可定量的收益<br />
  无法直接用人民币表示的收益，如服务的改进，由操作失误引起的风险的减少，信息掌握情况的改进，组织机构给外界形象的改善等。有些不可捉摸的收益只能大概估计或进行极值估计（按最好和最差情况估计）。</li>
</ol>
<h4 id="3效益分析的若干指标和进一步的分析"><a class="markdownIt-Anchor" href="#3效益分析的若干指标和进一步的分析"></a> 3．效益分析的若干指标和进一步的分析</h4>
<ol>
<li>收益/投资比<br />
  软件项目实施后整个系统生命期的收益/投资比值。</li>
<li>投资回收周期<br />
  收益的累计数开始超过支出的累计数的时间。</li>
<li>敏感性分析<br />
  分析项目中的一些关键性因素如系统生命期长度、系统的工作负荷量、工作负荷的类型、处理速度、设备和软件的配置等因素发生变化或进行合理搭配时，对开支和收益的影响最灵敏的范围估计。通常当项目需要在不同因素之间取舍和调整的时候，需要参考敏感性分析的内容。</li>
</ol>
<h3 id="723-可行性分析报告"><a class="markdownIt-Anchor" href="#723-可行性分析报告"></a> 7.2.3 可行性分析报告</h3>
<p>  在国家标准《GB8567-1988》中，规定了可行性分析报告的详细格式和内容。这个规范文本基本上涵盖了可行性分析需要考察的问题，可作为书写可行性研究报告的参考文档模板。 不管可行性报告的形式如何，最重要的内容应当有以下几项。</p>
<ul>
<li>项目背景：包括问题描述、实现环境和限制条件；</li>
<li>管理概要和建议：包括重要的研究结果、说明、建议和影响；</li>
<li>候选方案：包括候选系统的配置和最终方案的选择标准；</li>
<li>系统描述：包括系统工作范围的简要说明和被分配系统元素的可行性；</li>
<li>经济可行性（成本/效益分析）：包括经费概算和预期的经济效益；</li>
<li>技术可行性（技术风险评价）：包括技术实力、已有工作基础和设备条件；</li>
<li>法律可行性：包括系统开发可能导致的侵权，违法和责任等；</li>
<li>用户使用可行性：包括用户单位的行政管理，工作制度和使用人员的素质；</li>
<li>其他与项目有关的问题：例如，其他方案介绍和未来可能的变化。</li>
<li>可行性研究报告首先由项目负责人审查（审查内容是否可靠），再上报给上级主管审阅（评估项目的地位）。从可行性研究报告中应当得出“行或不行”的决断。</li>
</ul>
<h2 id="73-方案的制订和改进"><a class="markdownIt-Anchor" href="#73-方案的制订和改进"></a> 7.3 方案的制订和改进</h2>
<p>  在系统方案阶段，主要完成的工作则是解释“系统如何实现”的问题。系统方案制订的最主要内容，包括以下几个方面。</p>
<h3 id="731-确定软件架构"><a class="markdownIt-Anchor" href="#731-确定软件架构"></a> 7.3.1 确定软件架构</h3>
<p>  在问题定义阶段得到的软件概念模型使用各种工具定义了项目的开发目标。在系统方案制订阶段才开始真正考虑如何去实现软件。其中最重要的工作，就是制定系统的实现架构。<br />
  系统的实现架构与一些很具体的方面相关：</p>
<ol>
<li>分析模型的结构<br />
  例如，采用结构化分析方法得到的功能分解体系，或面向对象的类和“对象－关系图”、“对象－行为图”。</li>
<li>一些对应于系统目标的最基本、最重要的实现要素<br />
  例如，关键的用例、最主要的控制类、对象组织的模式、常用和最关键的实现算法模型等。这些实现要素对应于系统目标实现最重要的场景，表示了整个系统最主要的控制流程和实现机制。</li>
<li>特性和要点的解释<br />
  这些附加的内容解释系统的一些特性、服务等是如何实现的。</li>
</ol>
<h3 id="732-确定实现的各种关键性要素和实现手段关键性的实现要素"><a class="markdownIt-Anchor" href="#732-确定实现的各种关键性要素和实现手段关键性的实现要素"></a> 7.3.2 确定实现的各种关键性要素和实现手段关键性的实现要素</h3>
<p>  通常包括：</p>
<ul>
<li>关键的用例、最主要的控制类、功能和服务的首要组织方式（例如网站首页）；</li>
<li>对象的组织模式；</li>
<li>常用和最关键的实现算法模型。关键性的实现手段通常包括：</li>
<li>选定基础计算平台，如操作系统、数据库、Web 服务器、中间件平台等；</li>
<li>选定开发工具和开发环境，如计算机语言、构件库、工具软件等。</li>
</ul>
<h3 id="733-归结目标到最适合的计算体系"><a class="markdownIt-Anchor" href="#733-归结目标到最适合的计算体系"></a> 7.3.3 归结目标到最适合的计算体系</h3>
<p>  通常，提供开发工具和开发环境的组织总是有一些标准的计算体系可以选择（例如.NET和 J2EE 等），因此对于大多数系统开发项目来说，比较各种标准计算体系与预期目标之间的匹配程度即可选定计算体系。选择标准的计算体系去实现系统可以忽略大多数基础平台和底层支撑技术的实现问题，从而大大提高系统的质量、降低开发风险和成本。开发人员常根据基础平台的系统实现能力支持，公司或项目组在特定实现平台上的技术积累，甚至技术的“先进性”或流行程度这样的因素去选择系统的实现技术体系。<br />
  在另一些情况下，出于各种诸如用户投资力度，与用户现有的 IT 设施保持一致性、兼容性、扩展性及未来维护的能力等因素，系统的基础平台很可能在项目的论证阶段就已经被确定，如操作系统、数据库系统、Web 服务器、开发工具或开发环境等。在这种情况下，系统的实现体系实际上已经确定。<br />
  通过同时参考系统概念模型，将前面得到的系统功能清单和系统实现的各种关键要素整理并分类，然后与现有的技术、标准的实现体系进行比较和匹配，就可以将系统概念模型定义的系统目标，进一步映射到真正可计算、可实现的系统架构上。这个过程可以理解为一种不断归结、比较并匹配的过程。<br />
  进行匹配的过程常常是一种双向的选择和探究过程，一方面拿出一个系统目标中的功能或实现要素，询问：这部分功能属于表示层、业务逻辑、还是数据服务？另一方面，也研究标准计算体系提供的功能，例如：放在业务逻辑层合适吗？技术人员具有这方面的开发经验积累吗？甚至是标准构件或服务可用吗？<br />
  各种标准的计算体系可能很复杂，但通常总是包括一些逻辑上的划分，例如，.NET 体系将应用系统理解为表示层、事务逻辑层和数据服务层三个层次构成。</p>
<ol>
<li>表示层<br />
  用户的界面部分。例如，单一应用程序的用户界面、C/S 计算模式的客户端、B/S 模式在浏览器中运行的 HTML、DHTML、Scripting、JavaApplet、ActiveX 等。</li>
<li>事务逻辑层<br />
  负责处理表示层的应用请求，完成商务逻辑的计算任务，并将处理结果返回给用户。事务逻辑处理层是将原先置于客户端的事务逻辑分离出来，集中置于服务器部分，为所有用户共享。事务逻辑层是整个应用的核心部分，而组件对象模型 COM 则相当于其心脏。事务逻辑层通过 COM 进行事务处理，并由 IIS（Internet Information Server，Internet 信息服务器）和 MTS（Microsoft Transaction Server，微软事务处理服务器）为各种应用组件提供完善的管理。</li>
<li>数据服务层<br />
  为应用提供数据来源。和以往的两层架构不同，数据库不再和每个活动客户保持一个连接，而是若干个客户通过应用逻辑组件共享数据库的连接，从而减少连接次数，提高数据服务器的性能和安全性。</li>
</ol>
<p>  相同的三层计算模式，也会表现为不同的实现方式。例如，表示层可能是单一应用系统的用户界面、C/S 计算的客户端、或 B/S 计算的 Web 页面和元素；事务逻辑层可能是单一应用系统的程序模块、C/S 的服务器端服务、B/S 应用服务器中的业务脚本或业务对象；当利用类似存储过程来实现数据操作逻辑的时候，存储过程也被看作事务逻辑层的一部分，但如果利用 ADO（ActiveX Data Object，ActiveX 数据对象）这样的数据访问组件访问数据时，ADO 和后台的数据库系统及数据库的逻辑则被看作数据服务层的一部分。<br />
  在必要的情况下，某个层次还可能进一步细分，例如，使用面向对象设计方法的系统常常会将事务逻辑层划分为基本的计算对象、业务对象及黏合业务对象实现功能的脚本 “胶水”或一些控制类。<br />
  不同标准的计算体系的逻辑划分，甚至同一个计算体系的不同版本，通常也不会套用这样的三层分类方式，但却有类似之处。下图表示了利用 JSP 开发 Web 程序的计算模式。JSP 页面构成了前端的表示层，EJB 构成了业务逻辑层，JDBC（Java DataBase Connectivity，Java 数据库连接）和后台的数据库构成了数据服务层。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sI0gvF"><img src="https://s3.ax1x.com/2021/01/22/sI0gvF.png" alt="利用 JSP 开发 Web 程序的计算模式" /></a></p>
<p>  对于小规模的网站系统，开发者可能直接在 JSP 页面中书写所有的应用逻辑脚本，这样业务逻辑层就和表示层合并了，而对于使用 J2EE 体系的开发人员来说，利用 EJB 的容器、对象操作语言等机制直接实现了对象级的接口，开发人员直接在业务逻辑层去构思应用，JDBC 和后台数据库系统的数据服务层被隐含在 J2EE 的平台机制内，在更高的抽象级别上被屏蔽。<br />
  因此，归结系统实现要素到计算体系的时候，要点在于理解各种计算体系的大致分层和构成，比较实现要素的目标和实现手段之间的“适合程度”，而不是生搬硬套某种实现机制，或盲目追求某种“流行的”或“先进的”算体系。<br />
系统方案制订后，需要根据有关标准进行评价，找出不符合实际的地方，然后进行改进。</p>
<h2 id="74-新旧系统的分析和比较"><a class="markdownIt-Anchor" href="#74-新旧系统的分析和比较"></a> 7.4 新旧系统的分析和比较</h2>
<p>  计算机技术飞速发展，日新月异，许多企业因为业务发展的需要和市场竞争的压力，需要建设新的企业信息系统。在这种升级改造的过程中，怎么处理和利用那些历史遗留下来的老系统，成为影响新系统建设成败和开发效率的关键因素之一。通常称这些老系统为遗留系统。<br />
  目前，学术和工业界对遗留系统的定义没有统一的意见。Bennett 在 1995 年对遗留系统做了如下的定义：遗留系统是不知道如何处理但对组织又至关重要的系统。Brodie 和Stonebraker 对遗留系统的定义如下：遗留系统是指任何基本上不能进行修改和演化以满足新的变化了的业务需求的信息系统。<br />
  笔者认为，遗留系统应该具有以下特点：</p>
<ol>
<li>系统虽然能完成企业中许多重要的业务管理工作，但已经不能完全满足要求。一般实现业务处理电子化及部分企业管理功能，很少涉及经营决策。</li>
<li>系统在性能上已经落后，采用的技术已经过时。如多采用主机/终端形式或小型机系统，软件使用汇编语言或第三代程序设计语言的早期版本开发，使用文件系统而不是数据库。</li>
<li>通常是大型的系统，已经融入企业的业务运行和决策管理机制之中，维护工作十分困难。</li>
<li>系统没有使用现代系统工程方法进行管理和开发，现在基本上已经没有文档，很难理解。</li>
</ol>
<p>  在企业信息系统升级改造过程中，如何处理和利用遗留系统，成为新系统建设的重要组成部分。处理恰当与否，直接关系到新系统的成败和开发效率。遗留系统的演化方式可以有很多种，根据系统的技术条件、商业价值及维护和运行系统的组织特征不同，可以采取继续维护、某种形式的重构或替代策略，或者联合使用几种策略。究竟采用哪些策略来处理遗留系统，需要根据对遗留系统的所有系统特性的评价来确定。</p>
<h3 id="741-遗留系统的评价方法"><a class="markdownIt-Anchor" href="#741-遗留系统的评价方法"></a> 7.4.1 遗留系统的评价方法</h3>
<p>  对遗留系统评价的目的是为了获得对遗留系统更好的理解，这是遗留系统演化的基础，是任何遗留系统演化项目的起点。本文的评价方法包括度量<code>系统技术水准</code>、<code>商业价值</code>和<code>与之关联的组织特征</code>，其结果作为选择处理策略的基础。<br />
  评价方法由一系列活动组成，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sIBWz8"><img src="https://s3.ax1x.com/2021/01/22/sIBWz8.png" alt="评价活动" /></a></p>
<h4 id="1启动评价"><a class="markdownIt-Anchor" href="#1启动评价"></a> 1．启动评价</h4>
<p>  评价是为了获得对遗留系统的足够深度的理解，从技术、商业和企业角度对系统的理解为系统处理策略提供基础，开始评价前，需要了解以下问题。</p>
<ol>
<li>对企业来说，遗留系统是否是至关重要的<br />
  在评价过程中，可能会发现系统对企业的继续运作产生的影响不大。在这种情况下，就没有必要考虑系统的演化问题。</li>
<li>企业的商业目标是什么<br />
  从商业观点来看，评估师必须理解企业的商业目标，因为商业目标产生演化需求。</li>
<li>演化需求是什么<br />
  演化需求来自企业的商业目标和评价活动。需求必须是可见的，以便决定已存在的系统是否能满足需求。</li>
<li>所期望的系统寿命多长<br />
  一个系统的寿命由软件和硬件的服务能力决定，一旦系统硬件或支撑软件过时，系统的有效性就受到限制。</li>
<li>系统使用期限多久<br />
  如果系统的使用期限只是短期的，就没有必要花费成本来演化系统。相反，如果系统将在相当长的时期内支持主要业务流程，则必须进行演化。</li>
<li>系统的技术状态如何<br />
  例如，如果应用软件的技术状况很差，则很难理解，维护费用会很高。</li>
<li>企业是否愿意改变<br />
  企业对改变的态度是遗留系统演化成功的关键因素之一。</li>
<li>企业是否有能力承受演化<br />
  企业的技术成熟度，员工的素质，支撑工具的级别等都是影响演化的因素。</li>
</ol>
<h4 id="2商业价值评价"><a class="markdownIt-Anchor" href="#2商业价值评价"></a> 2．商业价值评价</h4>
<p>  商业价值评价的目标是判断遗留系统对企业的重要性。在多数情况下，重要业务过程的改变意味着旧的系统现在仅仅具有外围价值，修改这种系统只需花费少许财力和物力。<br />
  在其他情况下，系统的业务价值很大，需要继续维护运行。可以在概要和详细两个级别上进行遗留系统的商业价值评价。</p>
<p>  概要级评价将为更加详细的分析提供信息。概要级评价包括：</p>
<ol>
<li>咨询<br />
  向有关专家进行咨询，包括最终用户和负责业务处理的管理人员。</li>
<li>评价问卷<br />
  问卷应该标识系统在业务处理过程中的哪些地方使用，本系统与其他系统的关系，如果系统不再运行所需的代价，系统已有的缺点和存在的问题等。问题的准确性依赖于所评价的系统。</li>
<li>进行评价<br />
  有了问卷的基础后，必须认真分析系统是如何使用的，这往往会发现系统的价值，而这在问卷中是得不到的。</li>
</ol>
<blockquote>
<p>详细级评价包括应用系统不符合业务规范的风险分析，这种分析十分费时，最好由业务分析师来完成详细级的评价。</p>
</blockquote>
<h4 id="3外部环境评价"><a class="markdownIt-Anchor" href="#3外部环境评价"></a> 3．外部环境评价</h4>
<p>  外部环境评价系统的外部技术环境是指硬件、支撑软件和企业基础设施的统一体。</p>
<ol>
<li>
<p>硬件<br />
  系统硬件包括许多需要进行常规性维护的部件，这些硬件或者在一个站点，或者分布在许多站点并由网络连接。一般来说，遗留系统的硬件包括主机和小型机、磁盘驱动器、磁带、终端、打印机和网络硬件。<br />
  与商业价值评价类似，硬件评价也可以分为概要级评价和详细级评价。概要级评价把遗留系统作为一个整体，提供硬件质量估计。详细级评价包括识别系统中的每个部件。在这两种情况下，必须识别一系列特征，用作评价的基础。特征的选择取决于要评价的系统，系统的一些常见特征有供应商、维护费用、失效率、年龄、功能、性能等。<br />
  具体评价方法是：每一个部件（或整个系统）在每个特征上分配一个价值分数（取值为1～4），然后把所有分数相加，获得该部件的总分。</p>
</li>
<li>
<p>支撑软件<br />
  系统的支撑软件环境也由许多部分组成，可包括操作系统、数据库、事务处理程序、编译器、网络软件、应用软件等。一般来说，支撑软件是依赖于某个硬件的，应用软件依赖于系统软件。在评价过程中，必须考虑这种依赖性。支撑软件的评价方法类似于硬件评价，在此省略。</p>
</li>
<li>
<p>企业基础设施<br />
  企业基础设施包括开发和维护系统的企业职责和运行该系统的企业职责（两者可能为同一个企业），这些基础设施是很难评价的，但对遗留系统的演化起关键作用。因此必须考虑以下问题：</p>
</li>
<li>
<p>企业和使用者的类型<br />
  企业或者有自己的系统开发队伍，或者所有开发和应用管理都是请其他企业完成。系统用户或许只重复一些记录性工作，或许包括一些更有技术性的工作。开发组织的技术成熟度。</p>
</li>
<li>
<p>开发组织的技术成熟度<br />
  包括是否使用了现代系统工程方法，是否遵循了统一的标准，是否进行了过程改进等。</p>
</li>
<li>
<p>企业的培训过程<br />
  如果企业（包括开发方和客户方）的培训做得好，遗留系统的演化可能会更成功。</p>
</li>
<li>
<p>系统支持人员的技术水平<br />
  如果系统支持人员的水平和经验不够，就不要急于对系统做大的改动。</p>
</li>
<li>
<p>企业是否愿意改变<br />
  企业对改变的态度是遗留系统演化成功的关键因素之一。企业基础设施的评价方法类似于硬件评价，在此省略。</p>
</li>
</ol>
<h4 id="4应用软件评价"><a class="markdownIt-Anchor" href="#4应用软件评价"></a> 4．应用软件评价</h4>
<p>  应用软件评价也有两个级别。</p>
<ol>
<li>系统级<br />
  把整个系统看作是不可分的原子，评价时不考虑系统的任何部分。</li>
<li>部件级<br />
  关注系统的每个子系统，考虑每个子系统的特征，包括复杂性、数据、文档、外部依赖性、合法性、维护记录、大小、安全性等。</li>
</ol>
<p>  具体评价方法也与硬件评价类似，在此省略。</p>
<h4 id="5分析评价结果评价"><a class="markdownIt-Anchor" href="#5分析评价结果评价"></a> 5．分析评价结果评价</h4>
<p>  活动将产生硬件、支撑软件、企业基础设施和应用软件的特征值矩阵，这些特征值体现了遗留系统当前的技术因素，其加权平均值代表了系统的技术水平。<br />
  计算公式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>R</mi><mo>=</mo><mo stretchy="false">(</mo><mi>P</mi><mn>1</mn><mi>O</mi><mi>R</mi><mi>H</mi><mo>+</mo><mi>P</mi><mn>2</mn><mi>O</mi><mi>R</mi><mi>S</mi><mo>+</mo><mi>P</mi><mn>3</mn><mi>O</mi><mi>A</mi><mi>F</mi><mo>+</mo><mi>P</mi><mn>4</mn><mi>O</mi><mi>R</mi><mi>A</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">OR=(P1ORH+P2ORS+P3OAF+ P4ORA)/4
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span></span></span></span></span></p>
<p>  其中 ORH 是硬件的评价值，ORS 是支撑软件的评价值，ORF 是企业基础设施的评价值，ORA 是应用软件的评价值，Pi (1 i 4) 分别是它们的权系数，即第 i 个评价值对遗留系统的影响因子。<br />
  把对技术水平的全面评价结果与商业评价进行比较，可以为系统演化提供第一手的资料。具体方法是按照商业评价分值和技术水平分值的情况，把评价结果分为四种类型，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sIrRKS"><img src="https://s3.ax1x.com/2021/01/22/sIrRKS.png" alt="评价结果分析" /></a></p>
<h3 id="742-遗留系统的演化策略"><a class="markdownIt-Anchor" href="#742-遗留系统的演化策略"></a> 7.4.2 遗留系统的演化策略</h3>
<p>  在评价结果分析图中，把对遗留系统的评价结果分列在坐标的四个象限内。对处在不同象限的遗留系统采取不同的演化策略。</p>
<h4 id="1淘汰策略"><a class="markdownIt-Anchor" href="#1淘汰策略"></a> 1．淘汰策略</h4>
<p>  第 3 象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的商业价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。<br />
  完全淘汰是一种极端性策略，一般是企业的业务产生了根本的变化，遗留系统基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上更合算。<br />
  对遗留系统的完全淘汰是企业资源的根本浪费，应该善于“变废为宝”，通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。</p>
<h4 id="2继承策略"><a class="markdownIt-Anchor" href="#2继承策略"></a> 2．继承策略</h4>
<p>  第 4 象限为低水平、高价值区，即遗留系统的技术含量较低，可满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业业务对该系统仍有很大的依赖性。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。<br />
  要做到对遗留系统的继承，必须对系统进行分析，得到旧系统的功能模型和数据模型，这种分析可以部分代替或验证系统的需求分析。<br />
  如果遗留系统的维护文档不完整，而又必须解析系统的功能模型和数据模型，那将是一项十分艰巨的任务。这时可使用有关系统重构的 CASE 工具，通过分析系统的代码生成系统结构图或其他报告。</p>
<h4 id="3改造策略"><a class="markdownIt-Anchor" href="#3改造策略"></a> 3．改造策略</h4>
<p>  第 1 象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有较大的生命力，且具有较高的商业价值，基本上能够满足企业业务运作和决策支持的要求。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。<br />
  这些改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变。数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型转化的过程。</p>
<h4 id="4集成策略"><a class="markdownIt-Anchor" href="#4集成策略"></a> 4．集成策略</h4>
<p>  第 2 象限为高水平、低价值区，即遗留系统的技术含量较高，但其商业价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但从企业全局来看，多个这样的系统，他们各自基于不同的平台，不同的数据模型，无法互联互通，数据还不一致，这就是很严重的问题了。<br />
  对这种遗留系统的演化策略为集成。<br />
  在集成过程中，可采用由互连系统构成的系统的架构，遗留系统可作为从属系统来描述。在企业信息系统建设过程中，如何处理那些遗留系统，将会是越来越突出的问题，因为即使是今天看来很先进的系统在明天也会成为遗留系统。对遗留系统的处理恰当与否，直接关系到新系统的成败和开发效率。如何建立一套系统的、行之有效的方法，以期望对实际工作有所指导，已成为一个迫切的问题。在实际工程项目中，遇到处理遗留系统的问题时，要具体情况具体分析，选择最佳的演化策略。</p>
<h1 id="第八章-系统分析与设计方法"><a class="markdownIt-Anchor" href="#第八章-系统分析与设计方法"></a> 第八章 系统分析与设计方法</h1>
<p>  对于架构设计师而言，如何进行系统设计是其“看家本领”，而设计是在对系统进行分析的基础上进行的，否则，设计就是“无米之炊”。从软件开发项目中的角色分配来看，系统架构设计师应该在信息系统项目管理师的协调下，与系统分析师协同工作。</p>
<h2 id="81-定义问题与归结模型"><a class="markdownIt-Anchor" href="#81-定义问题与归结模型"></a> 8.1 定义问题与归结模型</h2>
<p>  软件系统的目的是解决问题，因此在建模之初最重要的步骤是对问题的分析与定义，并在此基础上归结模型，这样才能够获得切实有效的模型。定义问题的过程包括：理解真实世界中的问题和用户的需要，并提出满足这些需要的解决方案的过程。</p>
<h3 id="811-问题分析"><a class="markdownIt-Anchor" href="#811-问题分析"></a> 8.1.1 问题分析</h3>
<p>  问题分析的目标就是在开发之前对要解决的问题有一个更透彻的理解。为了达到这一目标，通常需要经过在问题定义上达成共识，理解问题的本质，确定项目干系人和用户，定义系统的边界和确定系统实现的约束这五个步骤。</p>
<h4 id="1在问题定义上达成共识"><a class="markdownIt-Anchor" href="#1在问题定义上达成共识"></a> 1．在问题定义上达成共识</h4>
<p>  要检验大家是否在问题的定义上达成了共识，最简单的方法就是把问题写出来，看看是否能够获得大家的认可。而要使得这个过程更加有效，应该将问题用标准化的格式写出来，根据 UP 的建议，应该包括以下几个方面的要素。</p>
<ol>
<li>问题概述<br />
  用简短的几句话，将所理解的问题本质描述出来；</li>
<li>影响<br />
  说明该问题将会对哪些项目干系人（Stakeholder，风险承担者）产生影响；</li>
<li>结果<br />
  确定问题对项目干系人和商业活动会产生什么样的影响；</li>
<li>优点<br />
  概要性地提出解决方案，并列举出该解决方案的主要优点。</li>
</ol>
<p>  在问题定义上达成共识，就能够有效地将开发团队的理解与用户的需求达成一致，这样就能够使得整个系统的开发沿着合理的方向发展。</p>
<h4 id="2理解问题的本质"><a class="markdownIt-Anchor" href="#2理解问题的本质"></a> 2．理解问题的本质</h4>
<p>  每一句描述都会夹杂着叙述者的个人理解和判断，因此透过表面深入本质，理解问题背后的问题，是问题分析阶段一个十分关键的任务。其中一种技术是“根本原因”分析，这是一种提示问题或其表象的根本原因的系统化方法。在实际的应用中，常使用<code>因果鱼骨图</code>和<code>帕累托图</code>两种方法。</p>
<ol>
<li>因果鱼骨图<br />
  因果鱼骨图是一种有效的探寻问题根源的技术，它通过直观的图形找出问题或现象的所有潜在原因，从而追踪出问题的根源。它能够帮助人们将问题的原因而放在首位，提供了一种运用集体智慧解决问题的方法。在使用时，通常按照以下步骤进行。<br />
  将问题简明扼要地写在右边的方框里；<br />
  确定问题潜在原因的主要类别，将它们连到鱼的脊骨上；<br />
  用头脑风暴法寻找原因并归类。<br />
  下图是鱼骨图的一个示例。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/sjMluQ"><img src="https://s3.ax1x.com/2021/01/26/sjMluQ.png" alt="鱼骨图示例" /></a></li>
<li>帕累托图。<br />
  帕累托图是采用直方图的形式，根据问题的相对频率或大小从高往低降序排列，帮助设计师将精力集中在重要的问题上。它为 80%的问题找到关键的 20%的原因，它可以一目了然地显示出各个问题的相对重要程度，有助于预防在解决了一些问题后，却使另外一些问题变得更糟的现象发生。在使用时，通常按照以下步骤进行。<br />
  明确问题：也就是前面达成共识的问题定义；<br />
  找出问题的各种可能原因：通常可以利用头脑风暴来收集意见，并通过参考以往积累的资料和运营的数据来综合分析；<br />
  选择评价标准和考察期限：最常用的评价标准包括频率（占总原因的百分比）和费用（产生的影响），而考察的期限则应具有相应问题的代表性，并不是越长越好；<br />
  收集各种原因发生的频率及费用数据；<br />
  将原因按照发生的频率或费用从大到小排列起来；<br />
  将原因排在横轴上，频率或费用排列在纵轴上，形成如下图所示的结果。<br />
  这样就能够将造成问题的关键原因捕获出来，以便指导设计出更符合需要、更能够解决问题的解决方案。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/sjMRgO"><img src="https://s3.ax1x.com/2021/01/26/sjMRgO.png" alt="帕累托图示例" /></a></li>
</ol>
<h4 id="3确定项目干系人和用户"><a class="markdownIt-Anchor" href="#3确定项目干系人和用户"></a> 3．确定项目干系人和用户</h4>
<p>  要想有效地解决问题，必须了解用户和其他相关的项目干系人（任何将从新系统或应用的实现中受到实质性影响的人）的需要。不同的项目干系人通常对问题有不同的看法和不同的需要，这些在解决问题时必须加以考虑。事实上，许多项目干系人就是系统的用户，这一部分通常是易于识别的；但还有一部分项目干系人是系统的间接用户，甚至只是受系统影响的商业结果，这一部分不易识别，但十分重要。<br />
  在寻找项目干系人时，可以思考：系统的用户是谁？系统的客户（购买者）是谁？还有哪些人会受到系统输出的影响？系统完成并投入使用后，有谁会对它进行评估？还有没有其他系统内部或外部的客户，他们的需要有没有必要去考虑？系统将来由谁来维护？</p>
<h4 id="4定义系统的边界"><a class="markdownIt-Anchor" href="#4定义系统的边界"></a> 4．定义系统的边界</h4>
<p>  系统的边界是指解决方案系统和现实世界之间的边界。在系统边界中，信息以输入和输出的形式流入系统并由系统流向系统外的用户，所有和系统的交互都是通过系统和外界的接口进行的。在定义系统的边界时，将世界分为两个部分：系统及与系统进行交互的事物。要描述系统的边界有两种方法：一种是结构化分析中的“上下文范围图”，另一种则是面向对象分析中的“用例模型”。</p>
<ol>
<li>上下文范围图<br />
  也就是数据流图中的顶层图，它是一个反映领域信息的模型，能够清晰地显示出系统的工作职责和相邻系统的职责起止之处，从而让读者能够从宏观的层面去了解系统。下图就是一个描述“证券经纪人系统”的上下文范围图。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/sjQmZ9"><img src="https://s3.ax1x.com/2021/01/26/sjQmZ9.png" alt="上下文范围图示例" /></a></li>
<li>用例模型<br />
  用例模型则通过引入参与者来描述“和系统进行交互的事物”，只要识别了参与者，自然而然系统的界限就确定下来了。在寻找参与者时，可以思考以下问题：谁会对系统提供信息？谁会在系统中使用信息？谁会从系统中删除信息？谁将操作系统？系统将会在哪里被使用？系统从哪里得到信息？哪些外部系统要和系统进行交互？<br />
  然后，再根据每个参与者的功能需求，识别出代表系统功能的用例，从而界定系统的边界。而关于用例模型的更多细节，请参考 <a href="#8.4.3-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80">8.4.3</a> 节。</li>
</ol>
<h4 id="5确定系统实现的约束"><a class="markdownIt-Anchor" href="#5确定系统实现的约束"></a> 5．确定系统实现的约束</h4>
<p>  由于各种因素的存在，会对解决方案的选择造成一定的限制，称这种限制为约束。每条约束都将影响到最后的解决方案的形成，甚至会影响是否能够提出解决方案。<br />
  在考虑约束时，首先应该考察到不同的约束源，其中包括进度、投资收益、人员、设备预算、环境、操作系统、数据库、主机和客户机系统、技术问题、行政问题、已有软件、公司总体战略和程序、工具和语言的选择、人员及其他资源限制等。</p>
<h3 id="812-问题定义"><a class="markdownIt-Anchor" href="#812-问题定义"></a> 8.1.2 问题定义</h3>
<p>  通过对问题进行细致周密的分析，就可以对其进行综合的定义。对于一个问题的完整定义，通常应包括目标、功能需求和非功能需求三个方面。</p>
<h4 id="1目标"><a class="markdownIt-Anchor" href="#1目标"></a> 1．目标</h4>
<p>  目标是指构建系统的原因，它是最高层次的用户需求，是业务上的需要，而功能、性能需求则必须是以某种形式对该目标做出贡献。在描述目标时，应该注意以下几个方面。</p>
<ul>
<li>优势：目标应该不仅仅是解决问题，还要提供业务上的优势；</li>
<li>度量：不仅要说明业务的优势，而且还必须提供度量这种优势的标准；</li>
<li>合理性：要确保完成解决方案所需的工作量少于所获得的业务优势，这才是合理的解决方案；</li>
<li>可行性：要探寻能够满足度量标准的解决方案；</li>
<li>可达成性：对于组织而言，是否具备获取该系统的技能，构建完成后是否能够操作它。</li>
</ul>
<p>  例如，下面就是一个很好的目标描述的例子。</p>
<blockquote>
<p>目标：在冬季道路养护支出上节省费用<br />
优势：减少除冰和道路养护的费用<br />
度量标准：除冰费用将在目前道路养护费用的基础上降低25%，冰对道路的损伤将降低50%</p>
</blockquote>
<h4 id="2功能需求"><a class="markdownIt-Anchor" href="#2功能需求"></a> 2．功能需求</h4>
<p>  功能需求是用来指明系统必须做的事情，只有这些行为的存在，才有系统存在的价值。功能需求应该源于业务需求，它只与问题域相关，与解决方案域无关。也就是说，功能需求是在与用户或某个业务人员交谈时，他们所描述的内容是为了完成他们某部分的工作而必须做的事情。而在设计解决方案时，会遇到一些限制条件，这些东西也是“系统需求” 的一部分，不过应该是设计约束或非功能需求形式指定。<br />
  在规定功能需求时要注意其详细程度。由于这些需求是业务需求，因此应该由业务人员来验证。也就是说，用户应该能够指明系统要达到有用的程度，功能是否已经足够；考虑到工作的成果，它的功能是否正确。另外，在描述功能需求时，应该注意需求的二义性。而二义性主要体现在以下几个方面:</p>
<ol>
<li>同名异义的词<br />
  在自然语言中存在许多同名但异义的词语，应该谨慎地排除它们带来的影响。</li>
<li>代词<br />
  在需求描述中，代词经常会产生指代不明的现象，应该尽量避免使用，而是换成主语及宾语。</li>
</ol>
<h4 id="3非功能需求"><a class="markdownIt-Anchor" href="#3非功能需求"></a> 3．非功能需求</h4>
<p>  非功能需求是系统必须具备的属性，这些属性可以看作是一些使产品具有吸引力、易用、快速或可靠的特征或属性。非功能需求并不改变产品的功能，它是为工作赋予特征的。在识别功能需求和非功能需求时，有一种十分有用的思维模式：功能需求是以动词为特征的，而非功能性需求则是以副词为特征的。非功能需求主要包括以下几种:</p>
<ol>
<li>观感需求<br />
  即产品外观的精神实质，也就是与用户界面的观感相关的一组属性。</li>
<li>易用性需求<br />
  也就是产品的易用性程度，以及特殊的可用性考虑，通常包括用户的接受率、因为引入该产品而提高的生产效率、错误率、特殊人群的可用性等指标。</li>
<li>性能需求<br />
  也就是关于功能实现要求有多快、多可靠、多少处理量及多精确的约束。例如：速度、精度、安全性、容量、值范围、吞吐量、资源使用效率、可靠性（平均无故障时间）、可用性（不停机时间）、可扩展性等。</li>
<li>可操作性需求<br />
  衡量产品的操作环境，以及对该操作环境必须考虑的问题。</li>
<li>可维护性和可移植性需求<br />
  期望的改变，以及完成改变允许的时间。</li>
<li>安全性需求<br />
  产品的安全保密性，通常体现为保密性、完整性和可获得性。</li>
<li>文化和政策需求<br />
  由产品的开发者和使用者所带来的特别需求。</li>
<li>法律需求<br />
  哪些法律和标准适用于本产品。</li>
</ol>
<h2 id="82-需求分析与软件设计"><a class="markdownIt-Anchor" href="#82-需求分析与软件设计"></a> 8.2 需求分析与软件设计</h2>
<p>  需求分析是软件生命周期中相当重要的一个阶段。根据 Standish Group 对 23000 个项目进行的研究结果表明，28%的项目彻底失败，46%的项目超出经费预算或者超出工期，只有约 26%的项目获得成功。需求分析工作在整个软件开发生命周期中有着十分重要的意义。而在这些高达 74%的不成功项目中，有约 60%的失败是源于需求问题，也就是差不多有一半的项目都遇到了这个问题，这一可怕的现象引起人们对需求分析的高度重视。需求分析阶段的主要任务是通过开发人员与用户之间的广泛交流，不断澄清一些模糊的概念，最终形成一个完整的、清晰的、一致的需求说明。<br />
  而当明确了用户的需求之后，下一步的任务就是对未来的软件系统进行设计，它是确定系统实现的关键工作。需求分析和设计的方法对软件开发过程而言是十分重要的，因此必须扎实地掌握它。<br />
  需求分析与软件设计是软件生存期中最重要的两个步骤，需求分析解决的是“做什么”的问题，系统设计则是解决“怎么做”的问题。</p>
<h3 id="821-需求分析的任务与过程"><a class="markdownIt-Anchor" href="#821-需求分析的任务与过程"></a> 8.2.1 需求分析的任务与过程</h3>
<p>  需求分析所要做的工作是深入描述软件的功能和性能，确定软件设计的限制和软件同其他系统元素的接口细节，定义软件的其他有效性需求，细化软件要处理的数据域。用一句话概括就是：需求分析主要是确定待开发软件的功能、性能、数据、界面等要求。需求分析的实现步骤通常包括：<code>获取当前系统的物理模型</code>，<code>抽象出当前系统的逻辑模型</code>，<code>建立目标系统的逻辑模型</code>三个部分。具体来说，需求分析阶段的工作可以分成 4 个方面：</p>
<ol>
<li>问题识别<br />
  用于发现需求、描述需求，主要包括功能需求、性能需求、环境需求、可靠性需求、安全保密需求、用户界面需求、资源使用需求、软件成本消耗与开发进度需求，以此来预先估计以后系统可能达到的目标。</li>
<li>分析与综合<br />
  就是对问题进行分析，然后在此基础上整合出解决方案。这个步骤经常是反复进行的，常用的方法有面向数据流的结构化分析方法（Structured Analysis，SA），面向数据结构的 Jackson 方法，面向对象的分析方法（Object Oriented Analysis，OOA），以及用于建立动态模型的状态迁移图和 Petri 网。</li>
<li>编制需求分析的文档<br />
  就是对已经确定的需求进行文档化描述，该文档通常称为《需求规格说明书》。</li>
<li>需求分析与评审<br />
  它是需求分析工作的最后一步，主要是对功能的正确性、完整性和清晰性，以及其他需求给予评价。</li>
</ol>
<h4 id="1需求的分类"><a class="markdownIt-Anchor" href="#1需求的分类"></a> 1．需求的分类</h4>
<p>  软件需求就是系统必须完成的事及必须具备的品质。具体来说，软件需求包括功能需求、非功能需求和设计约束三方面内容。各种需求的概念示意图如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sxXJuF"><img src="https://s3.ax1x.com/2021/01/27/sxXJuF.png" alt="需求概念示意图" /></a></p>
<ul>
<li>功能需求<br />
  是指系统必须完成的那些事，即为了向它的用户提供有用的功能，产品必须执行的动作。</li>
<li>非功能需求<br />
  是指产品必须具备的属性或品质，如性能、响应时间、可靠性、容错性、扩展性等。</li>
<li>设计约束<br />
  也称为限制条件、补充规约，这通常是对解决方案的一些约束说明，例如必须采用国有自主知识版权的数据库系统，必须在 UNIX 操作系统之下运行等。</li>
</ul>
<p>  除了这三种需求之外，还有业务需求、用户需求、系统需求这三个处于不同层面的概念，充分地理解这样的模型才能够更加清晰地理清需求的脉络。</p>
<ul>
<li>业务需求（Business Requirement）<br />
  是指反映组织机构或客户对系统、产品高层次的目标要求，通常问题定义本身就是业务需求。</li>
<li>用户需求（User Requirement）<br />
  是指描述用户使用产品必须要完成什么任务，怎么完成的需求，通常是在问题定义的基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立从用户角度出发的需求。</li>
<li>系统需求（System Requirement）<br />
  是从系统的角度来说明软件的需求，它包括用特性说明的功能需求、质量属性、非功能需求及设计约束。</li>
</ul>
<p>  分析师经常围绕着“功能需求”来展开工作，而功能需求大部分都是从“系统需求” 的角度来分析与理解的，也就是用“开发人员”的视角来理解需求。但要想真正地得到完整的需求，仅戴上“开发人员”的眼镜是不够的，还需要“领域专家”的眼镜，要从更高的角度来理解需求，这就是“业务需求”；同时还应该更好地深入用户，了解他们的使用场景，了解他们的想法，这就是“用户需求”。这是一个理解层次的问题，并不仅仅是简单的概念。</p>
<h4 id="2需求工程"><a class="markdownIt-Anchor" href="#2需求工程"></a> 2．需求工程</h4>
<p>  需求工程就是包括创建和维护系统需求文档所必需的一切活动的过程，主要包括需求开发和需求管理两大工作。</p>
<ol>
<li>需求开发<br />
  包括<code>需求捕获</code>、<code>需求分析</code>、<code>编写规格说明书</code>和<code>需求验证</code> 4 个阶段。在这个阶段需要完成确定产品所期望的用户类型、获取每种用户类型的需求、了解实际用户任务和目标及这些任务所支持的业务需求、分析源于用户的信息、对需求进行优先级分类、将所收集的需求编写成为软件规格说明书和需求分析模型、对需求进行评审等工作。</li>
<li>需求管理<br />
  通常包括<code>定义需求基线</code>、<code>处理需求变更</code>、<code>需求跟踪</code>等方面的工作。</li>
</ol>
<p>  这两个方面是相辅相成的，需求开发是主线，是目标；需求管理是支持，是保障。换句话说，需求开发是努力更清晰、更明确地掌握客户对系统的需求；而需求管理则是对需求的变化进行管理的过程。</p>
<h4 id="3需求分析方法"><a class="markdownIt-Anchor" href="#3需求分析方法"></a> 3．需求分析方法</h4>
<p>  需求分析的方法可谓种类繁多，不过如果按照分解方式的不同，可以很容易地划分出几种类型。本节先从分析方法发展的历史，对其建立一个概要性的认识，在本章的后面几节中将详细说明最具有代表性的结构化分析与设计、面向对象分析与设计两种方法。</p>
<ol>
<li>结构化分析方法<br />
  最初的分析方法都不成体系，而且通常都只包括一些笼统的告诫，在 20 世纪 70 年代分析技术发展的分水岭终于出现了。这时人们开始尝试使用标准化的方法，开发和推出各种名为“结构化分析”的方法论，而 Tom DeMacro 则是这个领域最有代表性和权威性的专家。</li>
<li>软系统方法<br />
  这是一个过渡性的方法论，并未真正流行过，它的出现只是证明了结构化分析方法的一些不足。因为结构化分析方法采用的相对形式化的模型不仅与社会观格格不入，而且在解决“不确定性”时显得十分无力。最有代表性的软系统方法是 Checkland方法。</li>
<li>面向对象分析方法<br />
  在 20 世纪 90 年代，结构化方法的不足在面对多变的商业世界时，显得更加苍白无力，这就催使了 OOA 的迅速发展。</li>
<li>面向问题域的分析（Problem Domain Oriented Analysis，PDOA）<br />
  现在又发现面向对象分析方法也存在着很多的不足，应运而生了一些新的方法论，PDOA 就是其中一种。不过现在还在研究阶段，并未广泛应用。</li>
</ol>
<h3 id="822-如何进行系统设计"><a class="markdownIt-Anchor" href="#822-如何进行系统设计"></a> 8.2.2 如何进行系统设计</h3>
<p>  在实践中，系统设计与其说是在设计，不如说是在选择和妥协。<br />
  系统目标包括但不限制于功能、性能、健壮性、开发周期、交付日期等。不幸的是，这些目标往往是矛盾的，提高软件性能直接意味着开发周期的增加、交付日期的推迟，盲目地增加功能可能导致性能降低，维护成本提高。<br />
  软件设计者的难题在于在如此众多的目标之间找到这个平衡点，并且明确知道如何设计能实现这个平衡，既可以让投资者觉得在预算之内，又能让用户相对满意。可行性分析阶段应该已经论述了这样一个平衡点，可是如果设计者发现没有这样一个平衡点，如同没有一个设计者能让人骑着自行车到月球上去，那么设计者只能提出放弃某个方面的过度要求，否则系统要遭受必然失败的命运。更多的情况是没有经验的设计者不知道是否存在这些平衡点，更不知道如何利用合理的设计及有效的工具来达到平衡。因此设计者需要了解可以解决问题的各种方案，并清楚知道各个方案的效果、成本、缺点，以及这些方案的区别，并在各种方案中进行选择。而这些，不是一个人能在一两天了解的。<br />
  没有一个设计者会完全重新开始设计一个系统，他们总参考多个与目标系统相类似的系统，再从中进行甄别、取舍和补充来作为新系统的设计。要成为优秀的设计者，了解、掌握、消化、总结前人和自己以前的设计成果是最好的方法，这似乎也是唯一的方法。<br />
  设计者的苦恼有时候和编程人员一样。计算机系统的发展如此迅速，解决方案也越来越多，如同编程语言的发展，同时，随着人类社会的进步，投资者和客户也提出了越来越高的要求，这又需要设计者不断学习、创造新的方案。<br />
  但系统设计也并非没有规律可以遵循，人们在实践中发现优秀的系统设计一般在以下几个方面都很出色。</p>
<ol>
<li>组件的独立性<br />
  审视自己设计的系统，是否做到了高内聚、低耦合？</li>
<li>例外的识别和处理<br />
  谁能保证系统使用者都精确按照使用说明书使用？</li>
<li>防错和容错<br />
  当网络中断、数据库崩溃这样的灾难性事件发生时，系统也跟着崩溃吗？</li>
</ol>
<p>  而且，更幸运的是，也有一些技术能够改进系统设计，这些方法包括：降低复杂性、通过合约进行设计、原型化设计、错误树分析等。</p>
<h3 id="823-软件设计的任务与活动"><a class="markdownIt-Anchor" href="#823-软件设计的任务与活动"></a> 8.2.3 软件设计的任务与活动</h3>
<p>  软件设计是一个把软件需求变换成软件表示的过程。最初这种表示只是描绘出软件的总体框架，然后再进一步细化，并在此框架中填入细节。</p>
<h4 id="1软件设计的两个阶段"><a class="markdownIt-Anchor" href="#1软件设计的两个阶段"></a> 1.软件设计的两个阶段</h4>
<p>  从工程管理角度，软件设计可以分为两个步骤：</p>
<ol>
<li>概要设计<br />
  也称为高层设计，将软件需求转化为数据结构和软件的系统结构。例如，如果采用结构化设计，则将从宏观的角度将软件划分成各个组成模块，并确定模块的功能及模块之间的调用关系。</li>
<li>详细设计<br />
  也称为低层设计，将对结构表示进行细化，得到详细的数据结构与算法。同样的，如果采用结构化设计，则详细设计的任务就是为每个模块进行设计。</li>
</ol>
<h4 id="2主要的设计方法比较"><a class="markdownIt-Anchor" href="#2主要的设计方法比较"></a> 2．主要的设计方法比较</h4>
<p>  在结构化设计风行的时代，主流的设计方法还包括 Jackson 方法和 Parnas 方法。结构化方法侧重于“模块相对独立且功能单一，使模块间联系弱、模块内联系强”；而 Jackson 方法则是从数据结构导出模块结构；Parnas 方法的主要思想则是将可能引起变化的因素隐藏在有关模块内部，使这些因素变化时的影响范围受到限制，它只提供了重要的设计准则，但没有规定出具体的工作步骤。<br />
  而近年来，对象技术凭借其对数据的高效封装及良好的消息机制，实现了高内聚、低耦合的系统设计，成了现代软件设计的主流方法学。</p>
<h2 id="83-结构化分析与设计"><a class="markdownIt-Anchor" href="#83-结构化分析与设计"></a> 8.3 结构化分析与设计</h2>
<p>  结构化分析与设计方法是一种面向数据流的需求分析和设计方法，它适用于分析和设计大型数据处理系统，是一种简单、实用的方法，曾获得广泛的应用。</p>
<h3 id="831-结构化分析"><a class="markdownIt-Anchor" href="#831-结构化分析"></a> 8.3.1 结构化分析</h3>
<p>  结构化分析方法的基本思想是自顶向下逐层分解。分解和抽象是人们控制问题复杂性的两种基本手段。对于一个复杂的问题，人们很难一下子考虑问题的所有方面和全部细节，通常可以把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题，经过多次逐层分解，每个最底层的问题都是足够简单、容易解决的，于是复杂的问题也就迎刃而解了。这个过程就是分解过程。<br />
  结构化分析与面向对象分析方法之间的最大差别是：结构化分析方法把系统看作一个过程的集合体，包括人完成的和电脑完成的；而面向对象方法则把系统看成一个相互影响的对象集。结构化分析方法的特点是利用数据流图来帮助人们理解问题，对问题进行分析。<br />
  结构化分析一般包括以下工具：数据流图（Data Flow Diagram，DFD）、数据字典（DataDictionary，DD）、结构化语言、判定表、判定树。在接下来的部分将对它们一一做简单介绍。<br />
  结构化系统分析方法从总体上来看是一种强烈依赖数据流图的自顶向下的建模方法。它不仅是需求分析技术，也是完成需求规格化的有效技术手段。</p>
<h4 id="1结构化分析的工作步骤"><a class="markdownIt-Anchor" href="#1结构化分析的工作步骤"></a> 1．结构化分析的工作步骤</h4>
<p>  在介绍具体的结构化分析方法之前，先对如何进行结构化分析做一个总结性描述，以帮助大家更好地应用该方法。</p>
<ol>
<li>研究“物质环境”<br />
  首先，应画出当前系统（可能是非计算机系统，或是半计算机系统）的数据流图，说明系统的输入、输出数据流，说明系统的数据流情况，以及经历了哪些处理过程。在这个数据流图中，可以包括一些非计算机系统中数据流及处理的命名，例如部门名、岗位名、报表名等。这个过程可以帮助分析员有效地理解业务环境，在与用户的充分沟通与交流中完成。</li>
<li>建立系统逻辑模型<br />
  当物理模型建立完成之后，接下来的工作就是画出相对于真实系统的等价逻辑数据流图。在前一步骤建立的数据流图的基础上，将所有自然数据流都转成等价的逻辑流，例如，将现实世界的报表存储在计算机系统中的文件里；又如将现实世界中“送往总经理办公室”改为“报送报表”。</li>
<li>划清人机界限<br />
  最后，确定在系统逻辑模型中，哪些将采用自动化完成，哪些仍然保留手工操作。这样，就可以清晰地划清系统的范围。</li>
</ol>
<h4 id="2数据流图"><a class="markdownIt-Anchor" href="#2数据流图"></a> 2．数据流图</h4>
<p>  DFD 是一种图形化的系统模型，它在一张图中展示信息系统的主要需求，即输入、输出、处理（过程）、数据存储。由于从 DFD 中可以很容易地看出系统紧密结合的各个部分，而且整个图形模式只有 5 个符号需要记忆，所以深受分析人员的喜爱，因而广为流行。<br />
  如下图所示，DFD 中包括以下几个基本元素。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/y9AVgS"><img src="https://s3.ax1x.com/2021/01/28/y9AVgS.png" alt="数据流图符号集" /></a></p>
<ul>
<li>过程<br />
  也称为加工，一步步地执行指令，完成输入到输出的转换。</li>
<li>外部实体<br />
  也称为源/宿，系统之外的数据源或目的。</li>
<li>数据存储<br />
  也称为文件，存放数据的地方，一般是以文件、数据库等形式出现。</li>
<li>数据流<br />
  从一处到另一处的数据流向，如从输入或输出到一个过程的数据流。</li>
<li>实时连接<br />
  当过程执行时，外部实体与过程之间的来回通信。</li>
</ul>
<ol>
<li>数据流图的层次<br />
  正如前面提到的，结构化分析的思路是依赖于数据流图进行自顶而下的分析。这也是因为系统通常比较复杂，很难在一张图上将所有的数据流和加工描述清楚。因此，数据流图提供一种表现系统高层和低层概念的机制。也就是先绘制一张较高层次的数据流图，然后在此基础上，对其中的过程（处理）进行分解，分解成为若干独立的、低层次的、详细的数据流图，而且可以这样逐一地分解下去，直至系统被清晰地描述出来。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/y9Al40"><img src="https://s3.ax1x.com/2021/01/28/y9Al40.png" alt="数据流图的层次" /></a></li>
<li>Context图<br />
  Context 图，也就是系统上下文范围关系图。这是描述系统最高层结构的 DFD 图。它的特点是，将整个待开发的系统表示为一个过程，将所有的外部实体和进出系统的数据流都画在一张图中。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/y9Atu4"><img src="https://s3.ax1x.com/2021/01/28/y9Atu4.png" alt="Context图实例" /></a><br />
  Context 图用来描述系统有什么输入、输出数据流，与哪些外部实体直接相关，可以把整个系统的范围勾画出来。</li>
<li>逐级分解<br />
  当完成了 Context 图的建模之后，就可以在此基础上进行进一步的分解。以Context图实例为例，进行再分解，在对原有流程了解的基础上，可以得到如下图所示的结果。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/y9AcKe"><img src="https://s3.ax1x.com/2021/01/28/y9AcKe.png" alt="DFD 0层图实例" /></a><br />
  上图是在 Context 图的基础上做的第一次分解，而在 Context 图中只有一个过程，那就是系统，将其编号为 0。而接下来对 Context 图进行的分解，其实就是对这个编号为0的过程进行更细化的描述，在这里引入了新的过程、数据存储，为了能够区分其位置的级别，在这层次上的过程将以 1、2、3 为序列进行编号。<br />
  由于这是对过程 0 的分解，因此也称之为 DFD 0 层图。而可以根据需要对 DFD 0 层图上的过程（编号为 1、2、3）进行类似的分解，那么就称之为 DFD 1 层图，在 DFD 1 层图中引入的新过程，其编号规则就是 1.1，1.2…，以及 2.1，2.2…，以此类推，直到完成分析工作。<br />
  另外，这里存在一个很关键的要点，那就是 DFD 0 层图是 Context 图的细化，因此所有的输入和输出应该与 Context 图完全一致，否则就说明存在着错误。</li>
<li>如何画 DFD<br />
  DFD 的绘制是一个自顶向下、由外到里的过程，通常按照以下几个步骤进行。
<ul>
<li>画系统的输入和输出<br />
  就是在图的边缘标出系统的输入、输出数据流。这一步其实是决定研究的内容和系统的范围。在画的时候，可以先将尽可能多的输入、输出画出来，然后再删除多余的，增加遗漏的。</li>
<li>画数据流图的内部<br />
  将系统的输入、输出用一系列的处理连接起来，可以从输入数据流画向输出数据流，也可以从中间画出去。</li>
<li>为每一个数据流命名<br />
  命名的好坏与数据流图的可理解性密切相关，应避免使用空洞的名字。</li>
<li>为加工命名<br />
  注意应该使用动宾短语。</li>
</ul>
</li>
</ol>
<h4 id="3细化记录-dfd-部件"><a class="markdownIt-Anchor" href="#3细化记录-dfd-部件"></a> 3.细化记录 DFD 部件</h4>
<p>  为了更好地描述 DFD 的部件，结构化分析方法还引入了数据字典、结构化语言及决策树、决策表等方法。通过使用这些工具，能对数据流图中描述不够清晰的地方进行有效的补充。其中数据字典应用最为广泛，下面将详细说明数据字典的相关使用方法。<br />
  数据字典技术是一种很实用、有效的表达数据格式的手段。它是对所有与系统相关的数据元素的一个有组织的列表和精确严格的定义，使得用户和系统分析员对于输入、输出、存储成分和中间计算机有共同的理解。通常数据字典的每一个条目中包括以下信息。</p>
<ol>
<li>名称<br />
  数据或控制项、数据存储或外部实体的主要名称，如果有别名的还应该将别名列出来。</li>
<li>何处使用/如何使用<br />
  使用数据或控制项的加工列表，以及如何使用。</li>
<li>内容描述<br />
  说明该条目的内容组成，通常采用以下符号进行说明。
<ul>
<li>=：由…构成</li>
<li>+：和，代表顺序连接的关系</li>
<li>[ | ]：或，代表从中选择一个</li>
<li>{}*：n 次重复</li>
<li>（）：代表可选的数据项</li>
<li>*…*：表示特定限制的注释</li>
</ul>
</li>
<li>补充信息<br />
  关于数据类型、默认值、限制等信息。</li>
</ol>
<p>下面就是一个数据字典的实例：</p>
<blockquote>
<p>客户基本信息=客户编号+客户名称+身份证号码+手机+家庭电话<br />
客户编号 = {0…9}8<br />
客户名称 = {字}4<br />
身份证号码 = [{0…9}15|{0…9}18]<br />
手机 = [{0…9}11|{0…9}12]<br />
家庭电话 =（区号）+本地号区号 = {0…9}4<br />
本地号 = [{0…9}7|{0…9}8]</p>
</blockquote>
<h3 id="832-结构化设计"><a class="markdownIt-Anchor" href="#832-结构化设计"></a> 8.3.2 结构化设计</h3>
<p>  结构化设计包括架构设计、接口设计、数据设计和过程设计等任务。它是一种面向数据流的设计方法，是以结构化分析阶段所产生的成果为基础，进一步自顶而下、逐步求精和模块化的过程。</p>
<h4 id="1概要设计与详细设计的主要任务"><a class="markdownIt-Anchor" href="#1概要设计与详细设计的主要任务"></a> 1．概要设计与详细设计的主要任务</h4>
<p>  概要设计阶段的主要任务是设计软件的结构、确定系统是由哪些模块组成，以及每个模块之间的关系。它采用结构图（包括模块、调用、数据）来描述程序的结构，此外还可以使用层次图和 HIPO（层次图加输入/处理/输出图）。<br />
  整个过程主要包括：复查基本系统模型、复查并精化数据流图、确定数据流图的信息流类型（包括交换流和事务流）、根据流类型分别实施变换分析或事务分析、根据软件设计原则对得到的软件结构图进一步优化。<br />
  而详细设计阶段的主要任务则是确定应该如何具体地实现所要求的系统，得出对目标系统的精确描述。它采用自顶向下、逐步求精的设计方式和单入口单出口的控制结构。常使用的工具包括程序流程图、盒图、PAD（Problem Analysis Diagram，问题分析图）、PDL（ProgramDesign Language，程序设计语言）。</p>
<h4 id="2结构图"><a class="markdownIt-Anchor" href="#2结构图"></a> 2．结构图</h4>
<p>  如下图所示，结构图的基本成分包括模块、调用（模块之间的调用关系）和数据（模块间传递及处理数据信息）。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/y98F1J"><img src="https://s3.ax1x.com/2021/01/28/y98F1J.png" alt="结构图的基本成分" /></a></p>
<p>  结构图是在需求分析阶段产生的数据流图的基础上进行进一步的设计。它将 DFD 图中的信息流分为两种类型。</p>
<ul>
<li>变换流<br />
  信息首先沿着输入通路进入系统，并将其转换为内部表示，然后通过变换中心（加工）的处理，再沿着输出转换为外部形式离开系统。具有这种特性的加工流就是变换流。</li>
<li>事务流<br />
  信息首先沿着输入通路进入系统，事务中心根据输入信息的类型在若干个动作序列（活动流）中选择一个执行，这种信息流称为事务流。</li>
</ul>
<h4 id="3程序流程图和盒图"><a class="markdownIt-Anchor" href="#3程序流程图和盒图"></a> 3．程序流程图和盒图</h4>
<p>  程序流程图和盒图都是用来描述程序的细节逻辑的，其符号如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/y98JBt"><img src="https://s3.ax1x.com/2021/01/28/y98JBt.png" alt="程序流程图和盒图基本符号示意图" /></a></p>
<p>  程序流程图的特点是简单、直观、易学，但它的缺点也正是由于其随意性而使得画出来的流程图容易成为非结构化的流程图。而盒图正是为了解决这一问题设计的，它是一种符合结构化程序设计原则的图形描述工具。<br />
  盒图的主要特点是功能域明确、无法任意转移控制、容易确定全局数据和局部数据的作用域、容易表示嵌套关系、可以表示模块的层次结构。但它也带来了一个副作用，那就是修改相对比较困难。</p>
<h4 id="4pad-和-pdl"><a class="markdownIt-Anchor" href="#4pad-和-pdl"></a> 4．PAD 和 PDL</h4>
<p>  PAD 是问题分析图的缩写，它符合自顶向下、逐步求精的原则，也符合结构化程序设计的思想，它最大的特点在于能够很方便地转换为程序语言的源程序代码。<br />
  PDL 则是语言描述工具的缩写，它和高级程序语言很相似，也包括数据说明部分和过程部分，还可以带注解等成分，但它是不可执行的。PDL 是一种形式化语言，其控制结构的描述是确定的，但内部的描述语法是不确定的。PDL 通常也被称为伪码。</p>
<h3 id="833-模块设计"><a class="markdownIt-Anchor" href="#833-模块设计"></a> 8.3.3 模块设计</h3>
<p>  在结构化方法中，模块化是一个很重要的概念，它是将一个待开发的软件分解成为若干个小的简单部分——模块，每个模块可以独立地开发、测试。这是一种复杂问题的“分而治之”原则，其目的是使程序的结构清晰、易于测试与修改。<br />
  具体来说，模块是指执行某一特定任务的数据结构和程序代码。通常将模块的接口和功能定义为其外部特性，将模块的局部数据和实现该模块的程序代码称为内部特性。而在模块设计时，最重要的原则就是实现信息隐蔽和模块独立。模块经常具有连续性，也就意味着作用于系统的小变动将导致行为上的小变化，同时规模说明的小变动也将影响到一小部分模块。</p>
<h4 id="1信息隐蔽原则"><a class="markdownIt-Anchor" href="#1信息隐蔽原则"></a> 1．信息隐蔽原则</h4>
<p>  信息隐蔽是开发整体程序结构时使用的法则，即将每个程序的成分隐蔽或封装在一个单一的设计模块中，并且尽可能少地暴露其内部的处理。通常将难的决策、可能修改的决策、数据结构的内部连接以及对它所做的操作细节、内部特征码、与计算机硬件有关的细节等隐蔽起来。通过信息隐蔽可以提高软件的可修改性、可测试性和可移植性，它也是现代软件设计的一个关键性原则。</p>
<h4 id="2模块独立性原则"><a class="markdownIt-Anchor" href="#2模块独立性原则"></a> 2．模块独立性原则</h4>
<p>  模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系最简单。保持模块的高度独立性，也是设计过程中的一个很重要的原则。通常用耦合（模块之间联系的紧密程度）和内聚（模块内部各元素之间联系的紧密程度）两个标准来衡量，设计的目标是高内聚、低耦合。<br />
模块的内聚类型通常可以分为 7 种，根据内聚度从高到低排序，如下表所示。</p>
<table>
<thead>
<tr>
<th>内聚类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能内聚</td>
<td>完成单一功能，各个部分协同工作，缺一不可</td>
</tr>
<tr>
<td>顺序内聚</td>
<td>处理元素相关，而且必须顺序执行</td>
</tr>
<tr>
<td>通信内聚</td>
<td>所有处理元素集中在一个数据结构的区域上</td>
</tr>
<tr>
<td>过程内聚</td>
<td>处理元素相关，而且必须按特定的次序执行</td>
</tr>
<tr>
<td>瞬时内聚</td>
<td>所包含的任务必须在同一时间间隔内执行（如初始化模块）</td>
</tr>
<tr>
<td>逻辑内聚</td>
<td>完成逻辑上相关的一组任务</td>
</tr>
<tr>
<td>偶然内聚</td>
<td>完成一组没有关系或松散关系的任务</td>
</tr>
</tbody>
</table>
<p>  与此相对应的，模块的耦合性类型通常也分为 7 种，根据耦合度从低到高排序，如下表所示。</p>
<table>
<thead>
<tr>
<th>耦合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>非直接耦合</td>
<td>没有直接联系，互相不依赖对方</td>
</tr>
<tr>
<td>数据耦合</td>
<td>借助参数表传递简单数据</td>
</tr>
<tr>
<td>标记耦合</td>
<td>一个数据结构的一部分借助于接口来传递</td>
</tr>
<tr>
<td>控制耦合</td>
<td>模块间传递的信息中包含用于控制模块内部逻辑的信息</td>
</tr>
<tr>
<td>外部耦合</td>
<td>与软件以外的环境有关</td>
</tr>
<tr>
<td>公共耦合</td>
<td>多个模块引用同一个全局数据区</td>
</tr>
<tr>
<td>内容耦合</td>
<td>一个模块访问另一个模块的内部数据<br>一个模块不通过正常入口转到另一个模块的内部<br>两个模块有一部分代码重叠<br>一个模块有多个入口</td>
</tr>
</tbody>
</table>
<p>  除了满足以上两大基本原则之外，通常在模块分解时还需要注意：保持模块的大小适中，尽可能减少调用的深度，直接调用该模块的个数应该尽量大，但调用其他模块的个数则不宜过大；保证模块是单入口、单出口的；模块的作用域应该在控制域之内；功能应该是可预测的。</p>
<h2 id="84-面向对象的分析与设计"><a class="markdownIt-Anchor" href="#84-面向对象的分析与设计"></a> 8.4 面向对象的分析与设计</h2>
<p>  面向对象方法是一种非常实用的软件开发方法，它一出现就受到软件技术人员的青睐，现已成为计算机科学研究的一个重要领域，并逐渐成为软件开发的一种主要方法。面向对象方法以客观世界中的对象为中心，其分析和设计思想符合人们的思维方式，分析和设计的结构与客观世界的实际比较接近，容易被人们接受。在面向对象方法中，分析和设计的界面并不明显，它们采用相同的符号表示，能够方便地从分析阶段平滑地过渡到设计阶段。此外，在现实生活中，用户的需求经常会发生变化，但客观世界的对象及对象间的关系比较稳定，因此用面向对象方法分析和设计的结构也相对比较稳定。</p>
<h3 id="841-面向对象的基本概念"><a class="markdownIt-Anchor" href="#841-面向对象的基本概念"></a> 8.4.1 面向对象的基本概念</h3>
<h4 id="1对象和类"><a class="markdownIt-Anchor" href="#1对象和类"></a> 1．对象和类</h4>
<p>  对象是系统中用来描述客观事物的一个实体，它由<code>对象标识</code>（名称）、<code>属性</code>（状态、数据、成员变量）和<code>服务</code>（操作、行为、方法）三个要素组成，它们被封装为一个整体，以接口的形式对外提供服务。<br />
  在现实世界中，每个实体都是对象，如学生、书籍、收音机等；每个对象都有它的操作，例如书籍的页数，收音机的频道、按钮等属性，以及收音机的切换频道等操作。<br />
  而类则是对具有相同属性和服务的一个或一组对象的抽象。类与对象是抽象描述和具体实例的关系，一个具体的对象被称为类的一个实例。在系统设计过程中，类可以分为三种类型，分别是实体类、边界类和控制类。</p>
<ol>
<li>实体类<br />
  实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息，例如，在线教育平台系统可以提取出学员类和课程类，它们都属于实体类。实体类通常都是永久性的，它们所具有的属性和关系是长期需要的，有时甚至在系统的整个生存期都需要。<br />
  实体类是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词，在用例模型向领域模型的转化中，一个参与者一般对应于实体类。通常可以从 SRS 中的那些与数据库表（需要持久存储）对应的名词着手来找寻实体类。通常情况下，实体类一定有属性，但不一定有操作。</li>
<li>控制类<br />
  控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词，例如，用例“身份验证”可以对应于一个控制类“身份验证器”，它提供了与身份验证相关的所有操作。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象（控制类的实例）通常控制其他对象，因此，它们的行为具有协调性。<br />
  控制类将用例的特有行为进行封装，控制对象的行为与特定用例的实现密切相关，当系统执行用例的时候，就产生了一个控制对象，控制对象经常在其对应的用例执行完毕后消亡。<br />
  通常情况下，控制类没有属性，但一定有方法。</li>
<li>边界类<br />
  边界类用于封装在用例内、外流动的信息或数据流。边界类位于系统与外界的交接处，包括所有窗体、报表、打印机和扫描仪等硬件的接口，以及与其他系统的接口。要寻找和定义边界类，可以检查用例模型，每个参与者和用例交互至少要有一个边界类，<code>边界类使参与者能与系统交互</code>。边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。常见的边界类有窗口、通信协议、打印机接口、传感器和终端等。实际上，在系统设计时，产生的报表都可以作为边界类来处理。<br />
  边界类用于系统接口与系统外部进行交互，边界对象将系统与其外部环境的变更（例如，与其他系统的接口的变更、用户需求的变更等）分隔开，使这些变更不会对系统的其他部分造成影响。通常情况下，边界类可以既有属性也有方法。</li>
</ol>
<h4 id="2继承与泛化"><a class="markdownIt-Anchor" href="#2继承与泛化"></a> 2．继承与泛化</h4>
<p>  继承是面向对象方法中重要的概念，用来说明特殊类（子类）与一般类（父类）的关系，而通常用泛化来说明一般类与特殊类的关系，也就是说它们是一对多关系。<br />
  如下图所示，“交通工具”是“自行车”和“小轿车”的泛化；“自行车”和“小轿车”从“交通工具”中继承。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yCquzq"><img src="https://s3.ax1x.com/2021/01/29/yCquzq.png" alt="继承与泛化示意图" /></a></p>
<h4 id="3多态与重载"><a class="markdownIt-Anchor" href="#3多态与重载"></a> 3．多态与重载</h4>
<p>  多态（即多种形式）性是指一般类中定义的属性或服务被特殊类继承后，可以具有不同的数据类型或表现出不同的行为，通常是使用重载和改写两项技术来实现的。一般有 4 种不同形式的多态，如下表所示。</p>
<table>
<thead>
<tr>
<th>多态类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载（专用多态）</td>
<td>描述一个函数名称有多种不同的实现方式，通常可以在编译时基于类型签名来区分各个重载函数的名称</td>
</tr>
<tr>
<td>改写（包含多态）</td>
<td>是重载的一种特殊情况，只发生在有关父类和子类之间关系中。通常签名相同，内容不一样</td>
</tr>
<tr>
<td>多态变量（赋值多态强制多态）</td>
<td>声明为一种类型，但实际上却可以包含另一种类型数值的变量</td>
</tr>
<tr>
<td>泛型（模板、参数多态）</td>
<td>它提供了一种创建通用工具的方法，可以在特定场合将其特化</td>
</tr>
</tbody>
</table>
<p>  注 1：重载也称为过载、重置；<br />
  注 2：参数多态和包含多态称为通用多态，重载多态和强制多态称为特定多态。</p>
<blockquote>
<p>虽然重载和改写都是在多种潜在的函数体中，选择和调用某一个函数或方法并对其进行执行，但它们的本质区别在于：重载是编译时执行的（静态绑定），而改写则是运行时选择的（动态绑定）。</p>
</blockquote>
<h4 id="4模板类"><a class="markdownIt-Anchor" href="#4模板类"></a> 4．模板类</h4>
<p>  也称为类属类，它用来实现参数多态机制。一个类属类是关于一组类的一个特性抽象，它强调的是这些类的成员特征中与具体类型无关的那些部分，而用变元来表示与具体类型有关的那些部分。</p>
<h4 id="5消息和消息通信"><a class="markdownIt-Anchor" href="#5消息和消息通信"></a> 5．消息和消息通信</h4>
<p>  消息就是向对象发出的服务请求，它通常包括提供服务的对象标识、消息名、输入信息和回答信息。消息通信则是面向对象方法学中的一个重要原则，它与对象的封装原则密不可分，为对象间提供了唯一合法的动态联系的途径。</p>
<h3 id="842-面向对象分析"><a class="markdownIt-Anchor" href="#842-面向对象分析"></a> 8.4.2 面向对象分析</h3>
<p>  面向对象分析的目标是开发一系列模型，这些模型描述计算机软件，当它工作时以满足一组客户定义的需求。对象技术的流行，演化出了数十种不同的 OOA 方法，每个方法都引入了一个产品或系统分析的过程、一组过程演化的模型及使软件工程师能够以一致的方式创建每个模型的符号体系。其中比较流行的方法包括 OMT、OOA、OOSE、Booch 方法等，而OMT、OOSE、Booch 最后则统一成为 UML。</p>
<h4 id="1ooaood-方法"><a class="markdownIt-Anchor" href="#1ooaood-方法"></a> 1．OOA/OOD 方法</h4>
<p>  这是由 Peter Coad 和 Edward Yourdon 提出的，OOA 模型中包括主题、对象类、结构、属性和服务 5 个层次，需经过标识对象类、标识结构与关联（包括继承、聚合、组合、实例化等）、划分主题、定义属性、定义服务 5 个步骤来完成整个分析工作。<br />
  OOD 中将继续贯穿 OOA 中的 5 个层次和 5 个活动，它由人机交互部件、问题域部件、任务管理部件、数据管理部件 4 个部分组成，其主要的活动就是这 4 个部件的设计工作。</p>
<ol>
<li>设计问题域部分<br />
  OOA 的结果恰好是 OOD 的问题域部件，分析的结果在 OOD 中可以被改动或增补，但基于问题域的总体组织框架是长时间稳定的。</li>
<li>设计人机交互部件<br />
  人机交互部件在上述结果中加入人机交互的设计和交互的细节，包括窗口和输出报告的设计。可以用原型来帮助实际交互机制进行开发和选择。</li>
<li>设计任务管理部分<br />
  这部分主要是识别事件驱动任务，识别时钟驱动任务，识别优先任务和关键任务，识别协调者，审查每个任务并定义每个任务。</li>
<li>设计数据管理部分<br />
  数据管理部分提供了在数据管理系统中存储和检索对象的基本结构，其目的是隔离数据管理方法对其他部分的影响。</li>
</ol>
<h4 id="2booch-方法"><a class="markdownIt-Anchor" href="#2booch-方法"></a> 2．Booch 方法</h4>
<p>  Booch 认为软件开发是一个螺旋上升的过程，每个周期中包括标识类和对象、确定类和对象的含义、标识关系、说明每个类的接口和实现 4 个步骤。它的模型中主要包括如下表所示的几种图形。</p>
<table>
<thead>
<tr>
<th></th>
<th>静态模型</th>
<th>动态模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑模型</td>
<td>类图<br>对象图</td>
<td>状态转换图<br>时序图</td>
</tr>
<tr>
<td>物理模型</td>
<td>模块图<br>进程图</td>
<td></td>
</tr>
</tbody>
</table>
<p>  Booch 方法的开发过程是一个迭代的、渐进式的系统开发过程，它可以分为宏过程和微过程两类。宏过程用于控制微过程，是覆盖几个月或几周所进行的活动，它包括负责建立核心需求的概念化，为所期望的行为建立模型的分析，建立架构的设计，形成实现的进化，以及管理软件交付使用的维护等 5 个主要活动。<br />
  而微过程则基本上代表了开发人员的日常活动，它由 4 个重要、没有顺序关系的步骤组成：在给定的抽象层次上识别出类和对象，识别出这些类和对象的语义，识别出类间和对象间的关系，实现类和对象。</p>
<h4 id="3omt-方法"><a class="markdownIt-Anchor" href="#3omt-方法"></a> 3．OMT 方法</h4>
<p>  OMT 是对象建模技术的缩写，它是由 Jam Rambaugh 及其同事合作开发的，它主要用于分析、系统设计和对象设计。包括对象模型（静态的、结构化的系统的“数据”性质，通常采用类图）、动态模型（瞬时的、行为化的系统“控制”性质，通常使用状态图）和功能模型（表示变化的系统的“功能”性质，通常使用数据流图）。OMT 方法的三大模型如下表所示。</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>说明</th>
<th>主要技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象模型</td>
<td>描述系统中对象的静态结构，对象之间的关系、属性、操作。它表示静态的、结构上的、系统的“数据”特征</td>
<td>对象图</td>
</tr>
<tr>
<td>动态模型</td>
<td>描述与时间和操作顺序有关的系统特征，如激发事件、事件序列、确定事件先后关系的状态。它表示瞬时、行为上的、系统的“控制”特征</td>
<td>状态图</td>
</tr>
<tr>
<td>功能模型</td>
<td>描述与值的变换有关的系统特征：功能、映射、约束和函数依赖</td>
<td>数据流图</td>
</tr>
</tbody>
</table>
<h4 id="4oose-方法"><a class="markdownIt-Anchor" href="#4oose-方法"></a> 4.OOSE 方法</h4>
<p>  OOSE 是面向对象软件工程的缩写，它是由 Ivar Jacobson 提出的。它在 OMT 的基础上，对功能模型进行了补充，提出了“用例”的概念，最终取代数据流图进行需求分析和建立功能模型。</p>
<h3 id="843-统一建模语言"><a class="markdownIt-Anchor" href="#843-统一建模语言"></a> 8.4.3 统一建模语言</h3>
<p>  统一建模语言（Unified Modeling Language，UML）是用于系统的可视化建模语言，它将OMT、OOSE 和 Booch 方法中的建模语言和方法有机地融合在一起，是国际统一的软件建模标准。虽然它源于 OO 软件系统建模领域，但由于其内建了大量扩展机制，也可以应用于更多的领域中，例如工作流程、业务领域等。</p>
<h4 id="1uml-是什么"><a class="markdownIt-Anchor" href="#1uml-是什么"></a> 1．UML 是什么</h4>
<p>  UML是一种语言：UML 在软件领域中的地位与价值就像“1、2、3、+、 、…”等符号在数学领域中的地位一样。它为软件开发人员之间提供了一种用于交流的词汇表和一种用于软件蓝图的标准语言。<br />
  UML是一种可视化语言：UML 只是一组图形符号，它的每个符号都有明确语义，是一种直观、可视化的语言。<br />
  UML是一种可用于详细描述的语言：UML 所建的模型是精确的、无歧义和完整的，因此适合于对所有重要的分析、设计和实现决策进行详细描述。<br />
  UML是一种构造语言：UML 虽然不是一种可视化的编程语言，但其与各种编程语言直接相连，而且有较好的映射关系，这种映射允许进行正向工程、逆向工程。<br />
  UML是一种文档化语言：它适合于建立系统架构及其所有的细节文档。</p>
<h4 id="2uml-的结构"><a class="markdownIt-Anchor" href="#2uml-的结构"></a> 2．UML 的结构</h4>
<p>  UML由<code>构造块</code>、<code>公共机制</code>和<code>架构</code>三个部分组成。</p>
<ol>
<li>构造块<br />
  构造块也就是基本的 UML 建模元素（事物）、关系和图。<br />
  建模元素：包括结构事物（类、接口、协作、用例、活动类、组件、节点等）、行为事物（交互、状态机）、分组事物（包）、注释事物。<br />
  关系：包括关联关系、依赖关系、泛化关系、实现关系。<br />
  图：UML 2.0 包括 14 种不同的图，分为表示系统静态结构的静态模型（包括类图、对象图、包图、构件图、部署图、制品图），以及表示系统动态结构的动态模型（包括对象图、用例图、顺序图、通信图、定时图、状态图、活动图、交互概览图）。</li>
<li>公共机制<br />
  公共机制是指达到特定目标的公共 UML 方法，主要包括规格说明、修饰、公共分类和扩展机制 4 种。<br />
  规格说明：规格说明是元素语义的文本描述，它是模型的重要组成部分。<br />
  修饰：UML 为每一个模型元素设置了一个简单的记号，还可以通过修饰来表达更多的信息。<br />
  公共分类：包括类元与实体（类元表示概念，而实体表示具体的实体）、接口和实现（接口用来定义契约，而实现就是具体的内容）两组公共分类。<br />
  扩展机制：包括约束（添加新规则来扩展元素的语义）、构造型（用于定义新的 UML建模元素）、标记值（添加新的特殊信息来扩展模型元素的规格说明）。</li>
<li>架构<br />
  UML 对系统架构的定义是：系统的组织结构，包括系统分解的组成部分、它们的关联性、交互、机制和指导原则，这些提供系统设计的信息。而具体来说，就是指 5个系统视图。<br />
  逻辑视图：以问题域的语汇组成的类和对象集合。<br />
  进程视图：可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例。<br />
  实现视图：对组成基于系统的物理代码的文件和组件进行建模。<br />
  部署视图：把组件物理地部署到一组物理的、可计算的节点上。<br />
  用例视图：最基本的需求分析模型。</li>
</ol>
<h4 id="3用例图基础"><a class="markdownIt-Anchor" href="#3用例图基础"></a> 3．用例图基础</h4>
<p>  用例是什么呢？Ivar Jacobson 是这样描述的：“用例实例是在系统中执行的一系列动作，这些动作将生成特定参与者可见的价值结果。一个用例定义一组用例实例。”首先，从定义中得知用例是由一组用例实例组成的，用例实例也就是常说的“使用场景”，就是用户使用系统的一个实际的、特定的场景。其次，可以知道，用例应该给参与者带来可见的价值，这点很关键。最后，用例是在系统中的。<br />
  而用例模型描述的是外部参与者所理解的系统功能。用例模型用于需求分析阶段，它的建立是系统开发者和用户反复讨论的结果，表明了开发者和用户对需求规格达成的共识。下图是一个用例图的例子。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yCvNMn"><img src="https://s3.ax1x.com/2021/01/29/yCvNMn.png" alt="用例图示例" /></a></p>
<ol>
<li>参与者<br />
  参与者代表与系统接口的任何事物或人，它是指代表某一种特定功能的角色，因此，参与者都是虚拟的概念。在 UML 中，用一个小人表示参与者。<br />
  用例图示例中的“图书管理员”就是参与者。对于该系统来说，可能可以充当图书管理员角色的有多个人，由于他们对系统均起着相同的作用，扮演相同的角色，因此只用一个参与者来表示。切忌不要为每一个可能与系统交互的真人画出一个参与者。</li>
<li>用例<br />
  用例是对系统行为的动态描述，它可以促进设计人员、开发人员与用户的沟通，理解正确的需求，还可以划分系统与外部实体的界限，是系统设计的起点。在识别出参与者之后，可以使用下列问题帮助识别用例。<br />
  每个参与者的任务是什么？<br />
  有参与者将要创建、存储、修改、删除或读取系统中的信息吗？<br />
  什么用例会创建、存储、修改、删除或读取这个信息？<br />
  参与者需要通知系统外部的突然变化吗？<br />
  需要通知参与者系统中正在发生的事情吗？<br />
  什么用例将支持和维护系统？<br />
  所有的功能需求都对应到用例中了吗？<br />
  系统需要何种输入/输出？输入从何处来？输出到何处？<br />
  当前运行系统的主要问题是什么？</li>
<li>包含和扩展<br />
  两个用例之间的关系可以主要概括为两种情况。一种是用于重用的包含关系，用构造型<code>&lt;&lt;include&gt;&gt;</code>或者<code>&lt;&lt;use&gt;&gt;</code>表示；另一种是用于分离出不同的行为，用构造型<code>&lt;&lt;extend&gt;&gt;</code>表示。<br />
  包含关系：当可以从两个或两个以上的原始用例中提取公共行为，或者发现能够使用一个组件来实现某一个用例的部分功能是很重要的事时，应该使用包含关系来表示。所提取出来的公共行为称为抽象用例。包含关系的例子如下图所示。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yCzDgJ"><img src="https://s3.ax1x.com/2021/01/29/yCzDgJ.png" alt="包含关系示例" /></a><br />
  扩展关系：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种事情。可以将这个用例分为一个主用例和一个或多个辅用例，描述可能更加清晰。扩展关系的例子如下图所示。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yCzyuR"><img src="https://s3.ax1x.com/2021/01/29/yCzyuR.png" alt="拓展关系示例" /></a></li>
</ol>
<h4 id="4类图和对象图基础"><a class="markdownIt-Anchor" href="#4类图和对象图基础"></a> 4．类图和对象图基础</h4>
<p>  在面向对象建模技术中，将客观世界的实体映射为对象，并归纳成一个个类。类、对象和它们之间的关联是面向对象技术中最基本的元素。对于一个想要描述的系统，其类模型和对象模型揭示了系统的结构。在 UML 中，类和对象模型分别由类图和对象图表示。类图技术是 OO 方法的核心。下图是一个类图的实例。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yCzTKA"><img src="https://s3.ax1x.com/2021/01/29/yCzTKA.png" alt="类图示例" /></a></p>
<ol>
<li>类和对象<br />
  对象与人们对客观世界的理解相关。人们通常用对象描述客观世界中某个具体的实体。所谓类是对一类具有相同特征的对象的描述。而对象是类的实例。在 UML中，类的可视化表示为一个划分成三个格子的长方形（下面两个格子可省略）。在类图示例图中，“书籍”、“借阅记录”等都是一个类。<br />
  类的获取和命名：最顶部的格子包含类的名字。类的命名应尽量用应用领域中的术语，应明确、无歧义，以利于开发人员与用户之间的相互理解和交流。<br />
  类的属性：中间的格子包含类的属性，用以描述该类对象的共同特点。该项可省略。类图示例图中“书籍”类有“书名”、“书号”等属性。UML 规定类的属性的语法为： “可见性 属性名：类型 = 默认值 {约束特性}”。<br />
  可见性包括 Public、Private 和 Protected，分别用+、-、#号表示。<br />
  类型表示该属性的种类：它可以是基本数据类型，例如整数、实数、布尔型等，也可以是用户自定义的类型。一般它由所涉及的程序设计语言确定。约束特性则是用户对该属性性质的一个约束说明。例如“{只读}”说明该属性是只读属性。<br />
  类的操作（Operation）：该项可省略。操作用于修改、检索类的属性或执行某些动作。操作通常也被称为功能，但是它们被约束在类的内部，只能作用到该类的对象上。操作名、返回类型和参数表组成操作界面。UML 规定操作的语法为：“可见性：操作名（参数表）：返回类型 {约束特性}”。<br />
  类图描述了类和类之间的静态关系。定义了类之后，就可以定义类之间的各种关系了。</li>
<li>类之间的关系<br />
  在建立抽象模型时，会发现很少有类会单独存在，大多数都将会以某种方式互相协作，因此还需要描述这些类之间的关系。关系是事物间的连接，在面向对象建模中，有 4 个很重要的关系。
<ul>
<li>依赖关系<br />
  有两个元素 X、Y，如果修改元素 X 的定义可能会引起对另一个元素 Y 的定义的修改，则称元素 Y 依赖于元素 X。在 UML 中，使用带箭头的虚线表示依赖关系。<br />
  在类中，依赖由多种原因引起，如：一个类向另一个类发消息；一个类是另一个类的数据成员；一个类是另一个类的某个操作参数。如果一个类的界面改变，它发出的任何消息可能不再合法。</li>
<li>泛化关系<br />
  泛化关系描述了一般事物与该事物中的特殊种类之间的关系，也就是父类与子类之间的关系。继承关系是泛化关系的反关系，也就是说子类是从父类中继承的，而父类则是子类的泛化。在 UML 中，使用带空心箭头的实线表示，箭头指向父类。<br />
  在 UML 中，对泛化关系有 3 个要求：<br />
  子类应与父类完全一致，父类所具有的关联、属性和操作，子类都应具有。<br />
  子类中除了与父类一致的信息外，还包括额外的信息。<br />
  可以使用子父类实例的地方，也可以使用子类实例。</li>
<li>关联关系<br />
  关联表示两个类之间存在某种语义上的联系。例如，一个人为一家公司工作，一家公司有许多办公室。就认为人和公司、公司和办公室之间存在某种语义上的联系。<br />
  关联关系提供了通信的路径，它是所有关系中最通用的、语义最弱的。在 UML 中，用一条实线来表示关联关系。</li>
<li>聚合关系<br />
  聚合是一种特殊形式的关联。聚合表示类之间的关系是整体与部分的关系。例如一辆轿车包含四个车轮、一个方向盘、一个发动机和一个底盘，就是聚合的一个例子。在 UML中，用一个带空心菱形的实线表示，空心菱形指向的是代表“整体”的类。<code>部分与整体的生命周期可以不相同</code></li>
<li>组合关系<br />
  如果聚合关系中的表示“部分”的类的存在，与表示“整体”的类有着紧密的关系，例如“公司”与“部门”之间的关系，那么就应该使用“组合”关系来表示。在 UML 中，用带有实心菱形的实线表示，菱形指向的是代表“整体”的类。<code>部分与整体的生命周期是相同的</code></li>
<li>实现关系<br />
  实现关系是用来规定接口和实现接口的类或组件之间的关系的。接口是操作的集合，这些操作用于规定类或组件的服务。在 UML 中，用一个带空心箭头的虚线表示。</li>
</ul>
</li>
<li>多重性问题<br />
  重复度又称多重性，多重性表示为一个整数范围 n…m，整数 n 定义所连接的最少对象的数目，而 m 则为最多对象数（当不知道确切的最大数时，最大数用*号表示）。最常见的多重性有：0…1；0…*；1…1；1…*；*。<br />
多重性是用来说明关联的两个类之间的数量关系的，例如：<br />
  书与借书记录之间的关系，就应该是 1 对 0…1 的关系，也就是一本书可以有 0 个或 1 个借书记录。<br />
  经理与员工之间的关系，则应为 1 对 0…*的关系，也就是一个经理可以领导 0 个或多个员工。<br />
  学生与选修课程之间的关系，就可以表示为 0…*对 1…*的关系，也就是一个学生可以选择1 门或多门课程，而一门课程可以有 0 个或多个学生选修。</li>
<li>类图<br />
  对于软件系统，其类模型和对象模型类图描述类和类之间的静态关系。与数据模型不同，它不仅显示了信息的结构，同时还描述了系统的行为。类图是定义其他图的基础。</li>
<li>对象图<br />
  UML 中对象图与类图具有相同的表示形式。对象图可以看作是类图的一个实例。对象是类的实例；对象之间的链（Link）是类之间的关联的实例。对象与类的图形表示相似，均为划分成两个格子的长方形（下面的格子可省略）。上面的格子是对象名，对象名下有下画线；下面的格子记录属性值。链的图形表示与关联相似。对象图常用于表示复杂类图的一个实例。</li>
</ol>
<h4 id="5交互图基础"><a class="markdownIt-Anchor" href="#5交互图基础"></a> 5．交互图基础</h4>
<p>  交互图是表示各组对象如何依某种行为进行协作的模型。通常可以使用一个交互图来表示和说明一个用例的行为。在 UML 中，包括 3 种不同形式的交互图，强调对象交互行为顺序的顺序图，强调对象协作的通信图（UML1.X 版本中称为“协作图”），强调消息的具体时间的定时图，它们之间没有什么本质不同，只是排版不尽相同而已。</p>
<ol>
<li>顺序图<br />
  顺序图用来描述对象之间动态的交互关系，着重体现对象间消息传递的时间顺序。顺序图允许直观地表示出对象的生存期，在生存期内，对象可以对输入消息做出响应，并且可以发送信息。下图是一个顺序图的示例。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yPgGbq"><img src="https://s3.ax1x.com/2021/01/29/yPgGbq.png" alt="顺序图示例" /></a><br />
  如上图所示，顺序图存在两个轴，水平轴表示不同的对象，即图中的 Client、Factory、Product 等；而垂直轴表示时间，表示对象及类的生命周期。<br />
  对象间的通信通过在对象的生命线间画消息来表示。消息的箭头指明消息的类型。顺序图中的消息可以是信号、操作调用或类似于 C++中的 RPC（Remote Procedure Calls）和 Java中的 RMI（Remote Method Invocation）。当收到消息时，接收对象立即开始执行活动，即对象被激活了。通过在对象生命线上显示一个细长矩形框来表示激活。<br />
  消息可以用消息名及参数来标识，消息也可带有顺序号。消息还可带有条件表达式，表示分支或决定是否发送消息。如果用于表示分支，则每个分支是相互排斥的，即在某一时刻仅可发送分支中的一个消息。</li>
<li>通信图<br />
  通信图用于描述相互合作的对象间的交互关系和链接关系。虽然顺序图和通信图都用来描述对象间的交互关系，但侧重点不一样。顺序图着重体现交互的时间顺序，通信图则着重体现交互对象间的静态链接关系。下图就是与顺序图示例相对应的通信图，可以从下图中很明显地发现它与顺序图之间的异同点。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yPfylD"><img src="https://s3.ax1x.com/2021/01/29/yPfylD.png" alt="通信图示例" /></a></li>
<li>定时图<br />
  如果要表示的交互具有很强的时间特性（例如，现实生活中的电子工程、实时控制等系统中），在 UML 1.X 中是无法有效地表示出来的。而在 UML 2.0 中引入了一种新的交互图来解决这类问题，这就是着重表示定时约束的定时图。<br />
  根据 UML 的定义，定时图实际上是一种特殊形式的顺序图（即一种变化），它与顺序图的区别主要体现在以下几个方面。<br />
  坐标轴交换了位置，改为从左到右来表示时间的推移。<br />
  用生命线的“凹下凸起”来表示状态的变化，每个水平位置代表一种不同的状态，状态的顺序可以有意义、也可以没有意义。<br />
  生命线可以跟在一根线后面，在这根线上显示一些不同的状态值。<br />
  可以显示一个度量时间值的标尺，用刻度来表示时间间隔。<br />
  下图是一个定时图的实际例子，其中小黑点加曲线表示的是注释。它用来表示一个电子门禁系统的控制逻辑，该门禁系统包括门（物理的门）、智能读卡器（读取用户的智能卡信息）、处理器（用来处理是否开门的判断）。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yPhZh6"><img src="https://s3.ax1x.com/2021/01/29/yPhZh6.png" alt="yPhZh6.png" /></a><br />
  在这个例子中，它所表示的意思是一开始读卡器是启用的（等用户来刷卡）、处理器是空闲的（没有验证的请求）、门是关的；接着，当用户刷卡时，读卡器就进入了“等待校验”的状态，并发一个消息给处理器，处理器就进入了校验状态。如果校验通过，就发送一个“禁用”消息给读卡器（因为门开的时候，读卡器就可以不工作），使读卡器进入禁用状态；并且自己转入启用状态，这时门的状态变成了“开”。而门“开”了 30 秒钟（根据时间刻度得知）之后，处理器将会把它再次“关”上，并且发送一个“启用”消息给读卡器（门关了，读卡器开始重新工作），这时读卡器再次进入启用状态，而处理器已经又回到了空闲状态。<br />
  从上面的例子中，不难看出定时图所包含的图元并不多，主要包括生命线、状态、状态变迁、消息、时间刻度，可以根据自身的需要来使用它。</li>
</ol>
<h4 id="6状态图基础状态图"><a class="markdownIt-Anchor" href="#6状态图基础状态图"></a> 6．状态图基础状态图</h4>
<p>  用来描述一个特定对象的所有可能状态及其引起状态转移的事件。大多数面向对象技术都用状态图表示单个对象在其生命周期中的行为。一个状态图包括一系列的状态及状态之间的转移。下图是一个数码冲印店的订单状态图实例。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yP54t1"><img src="https://s3.ax1x.com/2021/01/29/yP54t1.png" alt="状态图示例" /></a></p>
<p>  状态图包括以下部分。<br />
  状态：又称为中间状态，用圆角矩形框表示；<br />
  初始状态：又称为初态，用一个黑色的实心圆圈表示，在一张状态图中只能够有一个初始状态；<br />
  结束状态：又称为终态，在黑色的实心圆圈外面套上一个空心圆，在一张状态图中可能有多个结束状态；<br />
  状态转移：用箭头说明状态的转移情况，并用文字说明引发这个状态变化的相应事件是什么。<br />
  一个状态也可能被细分为多个子状态，那么如果将这些子状态都描绘出来的话，那这个状态就是复合状态。<br />
  状态图适合用于表述在不同用例之间的对象行为，但并不适合用于表述包括若干用例协作的对象行为。通常不会需要对系统中的每一个类绘制相应的状态图，而通常会在业务流程、控制对象、用户界面的设计方面使用状态图。</p>
<h4 id="7活动图基础"><a class="markdownIt-Anchor" href="#7活动图基础"></a> 7．活动图基础</h4>
<p>  活动图的应用非常广泛，它既可用来描述操作（类的方法）的行为，也可以描述用例和对象内部的工作过程。活动图是由状态图变化而来的，它们各自用于不同的目的。活动图依据对象状态的变化来捕获动作（将要执行的工作或活动）与动作的结果。活动图中一个活动结束后将立即进入下一个活动（在状态图中状态的变迁可能需要事件的触发）。</p>
<ol>
<li>基本活动图<br />
  下图是一个基本活动图的例子。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yP5HXD"><img src="https://s3.ax1x.com/2021/01/29/yP5HXD.png" alt="活动图示例" /></a><br />
  如图所示，活动图与状态图类似，包括了初始状态、终止状态，以及中间的活动状态，每个活动之间，也就是一种状态的变迁。在活动图中，还引入了以下几个概念。<br />
  判定：说明基于某些表达式的选择性路径，在 UML 中使用菱形表示。<br />
  分支与组合：由于活动图建模时，经常会遇到并发流，因此在 UML 中引入了如上图所示的粗线来表示分支和组合。</li>
<li>带泳道的活动图<br />
  在前面说明的基本活动图中，虽然能够描述系统发生了什么，但没有说明该项活动由谁来完成。而针对 OOP 而言，这就意味着活动图没有描述出各个活动由哪个类来完成。要想解决这个问题，可以通过泳道来解决这一问题。它将活动图的逻辑描述与顺序图、协作图的责任描述结合起来。下图是一个使用了泳道的例子。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yP5xht"><img src="https://s3.ax1x.com/2021/01/29/yP5xht.png" alt="带泳道的活动图示例" /></a></li>
<li>对象流<br />
  在活动图中可以出现对象。对象可以作为活动的输入或输出，对象与活动间的输入/输出关系由虚线箭头来表示。如果仅表示对象受到某一活动的影响，则可用不带箭头的虚线来连接对象与活动。</li>
<li>信号<br />
  在活动图中可以表示信号的发送与接收，分别用发送和接收标识来表示。<br />
  发送和接收标识也可与对象相连，用于表示消息的发送者和接收者。</li>
</ol>
<h4 id="8构件图基础"><a class="markdownIt-Anchor" href="#8构件图基础"></a> 8．构件图基础</h4>
<p>  构件图是面向对象系统的物理方面进行建模要用的两种图之一。它可以有效地显示一组构件，以及它们之间的关系。构件图中通常包括构件、接口及各种关系。下图是一个构件图的例子。<br />
<a target="_blank" rel="noopener" href="https://imgchr.com/i/yPIwuD"><img src="https://s3.ax1x.com/2021/01/29/yPIwuD.png" alt="构件图示例" /></a><br />
  通常构件指的是源代码文件、二进制代码文件和可执行文件等。而构件图就是用来显示编译、链接或执行时构件之间的依赖关系的。例如，在上图中，就是说明 QueryClient.exe将通过调用 QueryServer.exe 来完成相应的功能，而 QueryServer.exe 则需要 Find.exe 的支持， Find.exe 在实现时调用了 Query.dll。<br />
  通常来说，可以使用构件图完成以下工作。<br />
  对源代码进行建模：这样可以清晰地表示出各个不同源程序文件之间的关系。<br />
  对可执行体的发布建模：如图所示，将清晰地表示出各个可执行文件、DLL 文件之间的关系。<br />
  对物理数据库建模：用来表示各种类型的数据库、表之间的关系。<br />
  对可调整的系统建模：例如对应用了负载均衡、故障恢复等系统的建模。<br />
  在绘制构件图时，应该注意侧重于描述系统的静态实现视图的一个方面，图形不要过于简化，应该为构件图取一个直观的名称，在绘制时避免产生线的交叉。</p>
<h4 id="9部署图基础"><a class="markdownIt-Anchor" href="#9部署图基础"></a> 9．部署图基础</h4>
<p>  部署图，也称为实施图，它和构件图一样，是面向对象系统的物理方面建模的两种图之一。构件图是说明构件之间的逻辑关系，而部署图则是在此基础上更进一步地描述系统硬件的物理拓扑结构及在此结构上执行的软件。部署图可以显示计算结点的拓扑结构和通信路径、结点上运行的软件构件，常用于帮助理解分布式系统。<br />
  下图就是与构件图示例对应的部署图，这样的图示可以使系统的安装、部署更为简单。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yPTy1P"><img src="https://s3.ax1x.com/2021/01/29/yPTy1P.png" alt="部署图示例" /></a></p>
<p>  在部署图中，通常包括以下一些关键的组成部分。</p>
<ol>
<li>节点和连接<br />
  节点代表一个物理设备及其上运行的软件系统，如一台 UNIX 主机、一个 PC 终端、一台打印机、一个传感器等。<br />
  如上图所示，“客户端：个人 PC”和“服务器”就是两个节点。在 UML 中，使用一个立方体表示一个节点，节点名放在左上角。节点之间的连线表示系统之间进行交互的通信路径，在 UML 中被称为连接。通信类型则放在连接旁边的“《》”之间，表示所用的通信协议或网络类型。</li>
<li>构件和接口<br />
  在部署图中，构件代表可执行的物理代码模块，如一个可执行程序。<br />
  逻辑上它可以与类图中的包或类对应。例如，在部署图示例中，“服务器”结点中包含“QueryServer.exe”、“Find.exe”和“Query.dll”3 个构件。<br />
  在面向对象方法中，类和构件等元素并不是所有的属性和操作都对外可见。它们对外提供了可见操作和属性，称之为类和构件的接口。界面可以表示为一头是小圆圈的直线。在部署图示例中，“Query.dll”构件提供了一个“查询”接口。</li>
</ol>
<h2 id="85-用户界面设计"><a class="markdownIt-Anchor" href="#85-用户界面设计"></a> 8.5 用户界面设计</h2>
<p>  接口设计主要包括三个方面的内容：一是设计软件构件间的接口；二是设计模块和其他非人的信息生产者和消费者（如外部实体）的接口；三是人（如用户）和计算机间界面设计。<br />
  软件构件间接口的设计与架构的设计紧密相关���而设计模块和外部实体的接口则与详细设计相关，人机界面接口是相当容易被忽视的环节，在此就对其重点内容进行一个概要性描述。</p>
<h3 id="851-用户界面设计的原则"><a class="markdownIt-Anchor" href="#851-用户界面设计的原则"></a> 8.5.1 用户界面设计的原则</h3>
<p>  用户界面设计必须考虑软件使用者的体力和脑力，根据 Theo Mandel 的总结，设计时必须遵从三个黄金法则。<br />
  置用户于控制之下：具体来说就是以不强迫用户进入不必要的或不希望的动作的方式来定义交互模式、提供灵活的交互、允许用户交互可以被中断和撤销、当技能级别增长时可以使交互流水化并允许定制交互、使用户隔离内部技术细节、设计应允许用户和出现在屏幕上的对象直接交互。<br />
  减少用户的记忆负担：具体来说就是减少对短期记忆的要求、建立有意义的默认、定义直觉性的捷径、界面的视觉布局应该基于对真实世界的隐喻、以不断进展的方式提示信息。<br />
  保持界面的一致：具体来说，就是允许用户将当前任务放入有意义的语境、在应用系列内保持一致性，如果过去的交互模型已经建立了用户期望，除非有不得已的理由，否则不要改变它。<br />
  除此之外，还应该考虑下表所示的设计原则。</p>
<table>
<thead>
<tr>
<th>原则</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户熟悉</td>
<td>界面所使用的术语和概念应该来自于用户的体验，这些用户是将要使用系统最多的人</td>
</tr>
<tr>
<td>意外最小化</td>
<td>永远不要让用户对系统的行为感到吃惊</td>
</tr>
<tr>
<td>可恢复性</td>
<td>界面应该有一种机制来允许用户从错误中回复</td>
</tr>
<tr>
<td>用户指南</td>
<td>在错误发生时，界面应该提供有意义的反馈，并有上下文感知能力的用户帮助功能</td>
</tr>
<tr>
<td>用户差异性</td>
<td>界面应该为不同类型用户提供合适的交互功能</td>
</tr>
</tbody>
</table>
<h3 id="852-用户界面设计过程"><a class="markdownIt-Anchor" href="#852-用户界面设计过程"></a> 8.5.2 用户界面设计过程</h3>
<p>  用户界面的设计过程也应该是迭代的，它通常包括 4 个不同的框架活动，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yVxGxf"><img src="https://s3.ax1x.com/2021/02/01/yVxGxf.png" alt="用户界面设计过程" /></a></p>
<ol>
<li>用户、任务和环境分析<br />
  着重于分析将和系统交互的用户的特点。记录下技术级别、业务理解及对新系统的一般感悟，并定义不同的用户类别。然后对用户将要完成什么样的任务进行详细的标识和描述。最后对用户的物理工作环境进行了解与分析。</li>
<li>界面设计<br />
  主要包括建立任务的目标和意图，为每个目标或意图制定特定的动作序列，按在界面上执行的方式对动作序列进行规约，指明系统状态，定义控制机制，指明控制机制如何影响系统状态，指明用户如何通过界面上的信息来解释系统状态。</li>
<li>实现<br />
  就是根据界面设计进行实现，前期可以通过原型工具来快速实现，减少返工的工作量。</li>
<li>界面确认<br />
  界面实现后就可以进行一些定性和定量的数据收集，以进行界面的评估，以调整界面的设计。</li>
</ol>
<h2 id="86-工作流设计"><a class="markdownIt-Anchor" href="#86-工作流设计"></a> 8.6 工作流设计</h2>
<p>  工作流技术的发展，经过多年的努力，取得了一定的成果。但在实际应用中，应用的企业还是较少，应用的范围窄，效果不理想。<br />
  流程的设计是对设计者更高的挑战，现实中对计算机所管理的流程需要灵活的定义、方便的路径修改、容易使用，可是这几个目标是矛盾的。更严重的是，如何分析现实中的流程本身就是个困难的问题，更不用谈如何来设计实现了。流程设计的主要困难实际上也就是软件的主要困难：现实复杂性。<br />
  任何对现实的描述（图形也罢，文字也罢）都是不完美的，“不识庐山真面目”是设计面临的共同难题。设计者不得不意识到所有的流程模型都是对现实的简化，计算机只根据确定的信息作判断，而现实中的流程存在大量的不确定性，虽然计算机专家们自信地告诉企业管理者这是管理的问题，信誓旦旦地保证可以用计算机系统来“完善”企业的管理，但他们似乎没有意识到企业管理已经发展了几百年，而计算机还没有百年的历史。<br />
  人们常常抱怨计算机系统的流程设计太过刻板，因为许多时候，标准流程是先于应用构造的且由一些集中的权威强制执行的，所以这种刻板性是不可避免的。同时，对参与者而言缺乏自由度导致工作流管理系统显得很不友好。结果是它们经常被忽略或绕过，甚至最终被放弃。<br />
  另外的困难是：对于流程处理，不但名称众多，例如，动态模型、工作流等，而且对流程的定义也是千姿百态。面对这些困难，设计者无疑需要巨大的勇气来进行流程设计。</p>
<h3 id="861-工作流设计概述"><a class="markdownIt-Anchor" href="#861-工作流设计概述"></a> 8.6.1 工作流设计概述</h3>
<p>  限于篇幅，这里只列出工作流管理联盟对于工作流的定义：“工作流是一类能够完全或者部分自动执行的经营过程，根据一系列过程规则、文档、信息或任务在不同的执行者之间传递、执行”。</p>
<ol>
<li>工作流<br />
  简单地说，工作流是现实中的具体工作从开始到结束过程的抽象和概括。这个过程包括了众多因素：任务顺序、路线规则、时间时限约束等。</li>
<li>流程定义<br />
  流程定义是指对业务过程的形式化表示，它定义了过程运行中的活动和所涉及的各种信息。这些信息包括过程的开始和完成条件、构成过程的活动及进行活动间导航的规则、用户所需要完成的任务、可能被调用的应用、工作流间的引用关系，以及工作流数据的定义。这个定义的过程可能是由设计者用纸和笔来完成的，但越来越多的设计者倾向于使用流程定义工具来完成这个工作。</li>
<li>流程实例<br />
  也常常称为工作，是一个流程定义的运行实例。例如客户的一次订购过程，客服中心受理的一次客户投诉过程等。</li>
<li>工作流管理系统<br />
  和数据库管理系统类似，是一个软件系统。这个程序存储流程的定义，按照所使用的流程定义来触发流程状态的改变，推动流程的运转。这个推动的依据常常称为工作流引擎。</li>
<li>流程定义工具<br />
  同样是一套软件系统，这个软件和工作流管理系统的关系就如同数据库设计工具和数据库管理系统的关系一样。它可能是独立的软件，也可能是工作流管理系统的一部分。如前所说，设计者常常使用流程定义工具来完成流程定义的工作。它提供一些常用的工作流元素素材，以提高设计者的效率。</li>
<li>参与者<br />
  回答业务流程中“谁”这个问题。它可以是具体的人或者角色（企业内部有特别共同作用的多个人），也可以是自动化系统，甚至是其他系统。</li>
<li>活动<br />
  活动是流程定义中的一个元素，一次活动可能改变流程处理数据的内容、流程的状态，并可能将流程推动到其他活动中去。活动可以由人来完成，也可以是系统自动的处理过程，典型的自动处理是当活动超过了这个活动可以容忍的时限时，自动过程将向流程定义中指定的参与者发出一条消息。</li>
<li>活动所有者<br />
  参与者之一，他有权决定该活动是否结束，当他决定活动结束时，将活动推动到其他活动中，可能是下一个活动，也可能是前一个活动。</li>
<li>工作所有者<br />
  工作所有者是有权整体控制流程实例执行过程的参与者。</li>
<li>工作项<br />
  代表流程实例中活动的参与者将要执行的工作。</li>
</ol>
<p>  要分析现实中的处理流程，必须首先描述目标系统的流程，这个过程也可以称为建模。流程是个复杂的事务，必须从多方面才可以描述一个流程，包括：<code>“谁”</code>，流程的参与者；<code>“什么”</code>，参与者做什么工作；<code>“何时”</code>，工作完成的时间限制，还需要说明工作的数据流和完成工作的控制流。人们认为自然语言在描述如此复杂的事务时容易引起歧义，所以人们定义了一些形式化语言试图在自然语言中挑选一个子集，这个子集既可以真正描述流程，又能够摆脱自然语言的复杂和多变，实际上想在人和机器在理解处理流程上架起一座桥梁，如同其他计算机语言及后来发展的统一建模语言一样，这些形式化的语言也称为“工作流定义语言”。<br />
  同样，为了描述实际中的处理流程，人们也想到了图形的方式。有限状态自动机是一种分析状态和改变状态的良好工具，这种方法需要完全列出流程中所有状态及这些状态的组合，当处理流程变得庞大时，自动机所对应的状态图膨胀得太厉害。由于 Petri 网有严格的数学基础和图形化的规范语义，在描述离散事件动态系统方面的能力已经得到公认，具有较强的模型分析能力，在工作流的描述和分析中已经是人们广泛采用的一种方法。虽然有人认为图形并非工作流的最佳表示方法，但由于图形的直观性，大多数设计者都愿意采用图形的描述方式。有关有限状态自动机和 Petri 网的论述请参考其他书籍。</p>
<h3 id="862-工作流管理系统"><a class="markdownIt-Anchor" href="#862-工作流管理系统"></a> 8.6.2 工作流管理系统</h3>
<p>  根据工作流管理联盟（Workflow Management Coalition，WFMC）的定义，工作流管理系统是一种“在工作流形式化表示的驱动下，通过软件的执行而完成工作流定义、管理及执行的系统”，其主要目标是对业务过程中各活动发生的先后次序及与活动相关的相应人力或信息资源的调用进行管理，而实现业务过程的自动化。<br />
  如同关系数据库一样，现在已经出现了专门的工作流管理系统，这些系统经过专门的设计，从不同的角度负责解决设计者在流程设计中遇到的共同问题：节点定义、路径选择、数据流动等。不幸的是，和关系数据库共同基于关系代数、支持标准的 SQL 不同，这些工作流管理系统基于不同的数学模型，提供完全不同的接口。所以这些工作流管理系统各具特色，但在通用性和其他系统相互协作上的不足使得这些系统的应用受到了限制。<br />
  WFMC 给出了包含六个基本模块的参考模型，这六个模块被认为是工作流管理系统的最基本组成，这个参考模型同时包括了这些模块之间的接口标准。</p>
<ol>
<li>流程定义工具<br />
  这部分软件提供图形化或者其他方式的界面给设计者。由设计者将实际工作流程进行抽象，并将设计者提交的流程定义转换为形式化语言描述，提供给计算机工作流执行服务进行流程实例处理的依据。</li>
<li>工作流执行服务<br />
  这个服务程序是工作流管理系统的核心，它使用一种或者多种数据流引擎，对流程定义进行解释，激活有效的流程实例，推动流程实例在不同的活动中运转。和客户应用程序、其他工作流服务执行程序及其他应用程序进行交互，从而完成流程实例的创建、执行和管理工作。同时这部分软件为每个用户维护一个活动列表，告诉用户当前必须处理的任务。如果有必要，还可以通过电子邮件甚至是短消息的形式提醒用户任务的到达。</li>
<li>其他工作流执行服务<br />
  大型的企业工作流应用，往往包括多个工作流管理系统。这就需要这些工作流管理系统之间进行有效的交互，避免画地为牢、信息孤岛的现象出现。</li>
<li>客户应用程序<br />
  这是给最终用户的界面，用户通过使用这部分软件对工作流的数据进行必要的处理，如果用户是当前活动的拥有者，还可通过客户应用程序改变流程实例的活动，将流程实例推动到另外一个活动中。</li>
<li>被调用应用程序<br />
  这常常是对工作流所携带数据的处理程序，用得很多的是电子文档的处理程序。它们由工作流执行服务在流程实例的执行过程中调用，向最终用户展示待处理数据。在流程定义中应该定义这些应用程序的信息，包括名称、调用方式、参数等。</li>
<li>管理和监控工具<br />
  如同数据库管理系统或多或少地提供一些方式告诉管理员当前数据库的使用状态一样，工作流管理系统也应该提供对流程实例的状态查询、挂起、恢复、销毁等操作，同时提供系统参数、系统运行情况统计等数据。</li>
</ol>
<p>  看到这里，没有处理流程设计经验的设计者一定已经云里雾里了。确实，流程设计是系统设计中最困难的一部分，它的复杂性直接来源于现实世界的复杂性。而且直到现在，人们对流程的设计，仍然是在探索之中。</p>
<h2 id="87-简单分布式计算机应用系统的设计"><a class="markdownIt-Anchor" href="#87-简单分布式计算机应用系统的设计"></a> 8.7 简单分布式计算机应用系统的设计</h2>
<p>  网络极大地扩展了计算机的应用范围，同时，由于升级到更强的服务器的费用常常远远高于购买多台档次稍低的机器，更何况虽然计算机有了长足的发展，可是单台计算机的功能仍然十分有限，利用联网的计算机协同工作，共同完成复杂的工作成为相对成本较低的选择，而且可以完成单台计算机所无法完成的任务。分布式系统使得这一目标成为可能。另外，网络本质上并不可靠，特别是远程通信，分布式系统还带来了并发和同步的问题。<br />
  分布式系统可以由两种完全不同的方式来进行协同和合作，第一种是基于实例的协作。这种方式所有的实例都处理自己范围内的数据，这些对象实例的地位是相同的，当一个对象实例必须要处理不属于它自己范围的数据时，它必须和数据归宿的对象实例通信，请求另外一个对象实例进行处理。请求对象实例可以启动对象、调用远程对象的方法，以及停止运行远程实例。基于实例的协作具有良好的灵活性，但由于实例之间的紧密联系复杂的交互模型，使得开发成本提高，而且，由于实例必须能够通过网络找到，所以通信协议必须包括实例的生存周期管理，这使得基于实例的协作大多只限于统一的网络，对于复杂的跨平台的系统就难以应付。所以基于实例的协作适用于比较小范围内网络情况良好的环境中，这种环境常常被称为近连接。这种情况下对对象的生存周期管理所带来不寻常的网络流量是可以容忍的。<br />
  使用基于实例的协作常常使用被称为“代理”的方法，某个对象实例需要调用远程对象时，它可以只和代理打交道，由代理完成和远程对象实例的通信工作：创建远程对象，提交请求、得到结果，然后把结果提交给调用的对象实例。这样，这个对象实例甚至可以不知道自己使用了远程对象。当远程对象被替换掉（升级）时，对本地代码也没有什么需要修改的地方。<br />
  另外一种方式是基于服务的协作，该方法试图解决基于实例的协作的困难。它只提供远程对象的接口，用户可以调用这些方法，却无法远程创建和销毁远程对象实例。这样减少了交互，简化了编程，而且使得跨平台协作成为可能。同样由于只提供接口，这种协作方式使得对象间的会话状态难以确定，而且通信的数据类型也将有所限制，基本上很难使用自定义的类型。基于服务的协作适用于跨平台的网络，网络响应较慢的情况，这种环境常称为远连接，这时，简化交互性更为重要，而频繁的网络交换数据会带来难以容忍的延时。<br />
  基于服务的协作往往采用分层次的结构，高层次的应用依赖于低层次的对象，而低层次对象实例的实现细节则没有必要暴露给高层次对象，这种安排使得高层次的实现不受低层次如何实现的影响，同时，当低层次服务修改时，高层次的服务也不应该受到影响。<br />
  设计者在进行设计时，通常会倾向于比较细致的设计，对象往往提供了大量的操作和方法，响应许多不同的消息，以增加达到系统的灵活性、可维护性等。这在单个系统中没有什么问题，当考虑分布式系统的设计时，这种细致的设计所带来对对象方法的大量调用会比较严重地影响性能，所以在分布式系统中，倾向于使用大粒度的设计方式，往往在一个方法中包含了许多参数，每个方法基本上代表了一个独立的功能。当然这样的设计使得参数的传递变得复杂，当需要修改参数时，需要对比较大范围的一段过程代码进行修改，而不是像小粒度设计一样，只需要修改少量的代码。</p>
<h2 id="88-系统运行环境的集成与设计"><a class="markdownIt-Anchor" href="#88-系统运行环境的集成与设计"></a> 8.8 系统运行环境的集成与设计</h2>
<p>  在设计一个新的系统时，设计者必须考虑目标系统的运行环境问题，人们往往认为软件应该能够在任何环境中运行，常常看到这样的系统，硬件已经升级了多次，而软件还是原来的软件。软件的运行环境是指系统运行的设备、操作系统和网络配置。<br />
  本节给出软件运行的几个典型环境，设计者可以从这几种典型环境中选择适合自己的目标系统的环境，也可以将这些典型环境做一些组合，来满足自己设计的系统的特殊要求。</p>
<h3 id="1集中式系统"><a class="markdownIt-Anchor" href="#1集中式系统"></a> 1．集中式系统</h3>
<p>  早期的计算机系统没有什么可以选择的，除了集中式系统。所有的操作都集中于一台主机中，而操作员必须在主机的附近操作，结果也在附近给出。这种系统仍然广泛地应用于批处理应用系统及更大的分布式系统的一部分。集中式系统常见于银行、保险、证券行业，它们含有大规模的处理应用。而现在流行的电子商务又给大型处理机注入了新的活力，人们发现电子商务要面对大量的事务，需要大型处理机来处理。但是，实践中很少单独使用集中式系统，因为大量的系统需要处理在地理上分布得很远的连接请求，这些请求有的需要实时响应，并可能要发送到其他某个地方的一个集中式系统。所以，在现代的系统中，集中式系统通常是某个分布式系统的一个环节。<br />
  集中式系统由以下几个部分组成。</p>
<ol>
<li>单计算机结构<br />
  这种结构简单、容易维护，但是处理能力受到限制。</li>
<li>集群结构<br />
  由多个计算机组成，这些计算机具有类似的硬件平台、操作系统等。通常采用负载均衡、资源共享等方式实现更大的处理能力和容量。</li>
<li>多计算机结构<br />
  由多个计算机组成，这些计算机之间操作环境可能不同。适用于当系统可以分解成多个不同的子系统时。</li>
</ol>
<h3 id="2分布式系统"><a class="markdownIt-Anchor" href="#2分布式系统"></a> 2．分布式系统</h3>
<p>  分布式系统由于网络的普遍延伸，费用的不断降低而越来越成为大型系统的首选环境。分布式系统必须基于网络，这个网络可以是在一个地域内的局域网，也可以是跨越不同城市乃至国家的广域网。对比集中式的计算机环境，分布式系统有着多种多样的形式。这也给设计者在确定系统运行环境时带来一定的烦恼。</p>
<h3 id="3cs-结构"><a class="markdownIt-Anchor" href="#3cs-结构"></a> 3．C/S 结构</h3>
<p>  系统由提供服务的服务器和发起请求、接受结果的客户机构成。这种结构是一种可以使用很多方式实现的通用结构模型。并非只限于数据库的 C/S 结构，典型的还有网络打印服务系统，现在流行的网络游戏也显然是基于这种结构的。</p>
<h3 id="4多层结构"><a class="markdownIt-Anchor" href="#4多层结构"></a> 4．多层结构</h3>
<p>  这种结构是 C/S 结构的扩展，典型的分为由存储数据的数据库服务器作为数据层、实现商业规则的程序作为逻辑层、管理用户输入输出的视图层所组成的三层结构。当系统更复杂时，可以再增加其他层次构成多层结构。<br />
  多层结构形式复杂，功能多样。实现多层结构常常需要来实现不同层次间通信的专门程序——管件，也称为中间件。中间件大多数实现远程程序调用、对象请求调度等功能。<br />
现代企业级的计算机系统大量地基于分布式结构。支持分布式系统的软件也曾经如同雨后春笋。系统如何分层、如何处理分布带来的同步等问题也就同样在考验设计者。</p>
<h3 id="5internet-intranet-和-extranet"><a class="markdownIt-Anchor" href="#5internet-intranet-和-extranet"></a> 5.Internet、Intranet 和 Extranet</h3>
<p>  Internet 是全球的网络集合，使用通用的 TCP/IP 协议来相互连接。Internet 提供电子邮件、文件传输、远程登录等服务。Intranet 是私有网络，只限于内部使用，也使用 TCP/IP协议。Extranet 是一个扩展的 Intranet。它包括企业之外的和企业密切相关合作的其他企业。Extranet 允许分离的组织交换信息并进行合作，这样就形成了一个虚拟组织。现在的 VPN技术允许在公用网络上架构只对组织内部开发服务。<br />
  Web 同样基于 C/S 结构，实际上 Web 接口是一个通用的接口，不是只能使用浏览器的协议，它同样能够在普通的程序中使用。Internet 和 Web 已经给设计者提供了一个非常富有吸引力的选择方案。它的优势在于：它们已经成为网络的事实上的标准，支持它们的软件已经广泛地存在于全世界的计算机中，而且通信费用已经下降到很有竞争力的水平。从某种程度上来说，企业可以把 Internet 当作自己廉价的广域网。没有它们，电子商务还是水中月。<br />
  当然，事物有相反的一面，当设计者试图采用 Internet 时，必须考虑其不利的一面。Internet 的安全性过去是，现在是，以后仍然是设计者头痛的问题。其他诸如可靠性、系统吞吐量、不断发展的技术和标准都是影响系统选择它们作为运行环境的不利因素。设计者应该根据目标系统的实际需要来选择不同的运行环境。不过，已经有越来越多的公司提供支持 Internet 和电子商务的接口。</p>
<h2 id="89-系统过渡计划"><a class="markdownIt-Anchor" href="#89-系统过渡计划"></a> 8.9 系统过渡计划</h2>
<p>  当新系统似乎开发完毕，要取代原来的系统时，系统过渡就是设计者不得不面对的问题。不幸的是，这个问题比许多人想象得要复杂，和软件开发一样，存在着许多冲突和限制。例如，费用、客户关系、后勤保证和风险等。设计者需要考虑的问题也很多，其中比较重要的几个问题是：<br />
  如果同时运行两个系统，会给客户造成多大的开销；<br />
  如果直接运行新系统，客户面对的风险有多大；<br />
  对新系统试运行时的查错和纠错，以及出现严重错误而导致停止运行时的应急措施；<br />
  客户运行新系统将面临的不利因素有哪些；<br />
  人员的培训。</p>
<p>  使用不同的系统过渡方案意味着不同的风险，不同的费用及不同的复杂度。</p>
<h3 id="1直接过渡"><a class="markdownIt-Anchor" href="#1直接过渡"></a> 1．直接过渡</h3>
<p>  这是一种快速的系统过渡方式，当新系统运行时，立即关闭原来的系统。这种过渡方式非常简单，没有后勤保障的问题，也不要消耗很多资源。同时，它也意味着大风险，目标系统的特性决定了风险的大小。设计者主要要权衡当新系统失败时，系统停止运行或者勉强运行给客户带来的损失有多大。由于这种过渡方式简单而费用低廉，对于可以容忍停机一段时间的系统的实践者，可以采用这种方式。</p>
<h3 id="2并行过渡"><a class="markdownIt-Anchor" href="#2并行过渡"></a> 2．并行过渡</h3>
<p>  设计者采用并行过渡方式，让新系统和旧系统在一段时间里同时运行，通过这样的旧系统作为新系统的备份，可以大大降低系统过渡的风险。可是并行过渡显然比直接过渡要消耗更多的资源：现有的硬件资源必须保证能同时跑两套系统，这常常意味着增加服务器和额外的存储空间，需要增加人员来同时使用两套系统，或者增加现有员工的工作量，让他们同时操作两套系统。这种方式同时也增加了管理和后勤保障的复杂度。据统计，并行过渡时期的开销是旧系统单独运行时的 2.5～3 倍。<br />
  设计者还会发现有些系统无法使用并行过渡的方式，主要是客户没有足够的资源来维持两个系统同时运行，另外一种情况是新、旧系统差别太大，旧系统的数据无法为新系统采用。当客户无法使用并行过渡，又想尽可能地减少风险，设计者可以使用部分并行过渡的策略，使并行的开销减少到客户能够接受的范围内。</p>
<h3 id="3阶段过渡"><a class="markdownIt-Anchor" href="#3阶段过渡"></a> 3．阶段过渡</h3>
<p>  通常在系统非常复杂、过于庞大以至于无法一次性进行过渡时采用，也适用于分阶段开发的系统。设计者需要设计一系列步骤和过程来完成整个系统的过渡，这种过渡方式和系统的复杂程度相关，随着系统的不同往往有很大的不同。和并行过渡一样，阶段过渡也能够减少风险，显然局部的失败要比全体的失败更容易接受，带来的损失更小。阶段过渡也带来了复杂性，有时候比并行过渡更加复杂。</p>
<h1 id="第九章-软件架构设计"><a class="markdownIt-Anchor" href="#第九章-软件架构设计"></a> 第九章 软件架构设计</h1>
<p>  像学写文章一样，在学会字、词、句之后，就应上升到段落，就应追求文章的“布局谋篇”，这就是架构。通俗地讲，软件架构设计就是软件系统的“布局谋篇”。<br />
  人们在软件工程实践中，逐步认识到了软件架构的重要性，从而开辟了一个崭新的研究领域。软件架构的研究内容主要涉及软件架构描述、软件架构设计、软件架构风格、软件架构评价和软件架构的形成方法等。<br />
  软件设计人员学习软件架构知识旨在站在较高的层面上整体地解决好软件的设计、复用、质量和维护等方面的实际问题。</p>
<h2 id="91-软件架构概述"><a class="markdownIt-Anchor" href="#91-软件架构概述"></a> 9.1 软件架构概述</h2>
<p>  软件架构是软件抽象发展到一定阶段的产物，从编程的角度，可以清晰地看到软件抽象层次和表达工具的发展历史。<br />
  20 世纪 60 年代是子程序的年代：出现了原始的软件架构，即子程序，并以程序间的调用为连接关系。<br />
  20 世纪 70 年代是模块化的年代：出现了数据流分析、实体—关系图（E-R 图）、信息隐藏等工具和方法，软件的抽象层次发展到了模块级。<br />
  20 世纪 80 年代是面向对象的年代：基于模块化的编程语言进一步发展成面向对象的语言，继承性地增加了一种新元素之间的连接关系。<br />
  20 世纪 90 年代是框架的年代：标准的基于对象的架构以框架的形式出现了。如电子数据表、文档、图形图像、音频剪辑等可互换的黑箱对象，可以相互嵌入。<br />
  当前（最近 10 年来）：中间件和 IT 架构作为标准平台出现，用可购买可复用的元素来构建系统，同时，基于架构的开发方法和理论不断成熟。</p>
<h3 id="911-软件架构的定义"><a class="markdownIt-Anchor" href="#911-软件架构的定义"></a> 9.1.1 软件架构的定义</h3>
<p>  软件架构仍在不断发展中，还没有形成一个统一的、公认的定义，这里仅举出几个较权威的定义。</p>
<ul>
<li>定义 1<br />
  软件或计算机系统的软件架构是该系统的一个（或多个）结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。</li>
<li>定义 2<br />
  软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。</li>
<li>定义 3<br />
  软件架构是指一个系统的基础组织，它具体体现在：系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。（IEEE1471- 2000）<br />
  前两个定义都是按“元素—结构—架构”这一抽象层次来描述的，它们的基本意义相同，其中定义 1 较通俗，因此，本章采用这一定义。该定义中的“软件元素”是指比“构件”更一般的抽象，元素的“外部可见属性”是指其他元素对该元素所做的假设，如它所提供的服务、性能特征等。</li>
</ul>
<p>  为了更好地理解软件架构的定义，特作如下说明：</p>
<ol>
<li>架构是对系统的抽象<br />
  它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的“外部可见”属性。</li>
<li>架构由多个结构组成<br />
  结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。</li>
<li>任何软件都存在架构，但不一定有对该架构的具体表述文档<br />
  即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。</li>
<li>元素及其行为的集合构成架构的内容<br />
  体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。</li>
<li>架构具有“基础”性<br />
  它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。</li>
<li>架构隐含有“决策”<br />
  架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。</li>
</ol>
<p>  在设计软件架构时也必须考虑硬件特性和网络特性，因此，软件架构与系统架构二者间的区别其实不大。但是，在大多情况下，架构设计师在软件方面的选择性较之硬件方面，其自由度大得多。因此，使用“软件架构”这一术语，也表明了一个观点：架构设计师通常将架构的重点放在软件部分。<br />
  将软件架构置于商业背景中进行观察，可以发现软件架构对企业非常重要。</p>
<ol>
<li>影响架构的因素<br />
  软件系统的项目干系人（客户、用户、项目经理、程序员、测试人员、市场人员等）对软件系统有不同的要求开发组织（项目组）有不同的人员知识结构、架构设计师的素质与经验、当前的技术环境等方面都是影响架构的因素。<br />
  这些因素通过功能性需求、非功能性需求、约束条件及相互冲突的要求，影响架构设计师的决策，从而影响架构。</li>
<li>架构对上述诸因素具有反作用<br />
  例如，影响开发组织的结构。架构描述了系统的大粒度（宏观）总体结构，因此可以按架构进行分工，将项目组为几个工作组，从而使开发有序；影响开发组织的目标，即成功的架构为开发组织提供了新的商机，这归功于：系统的示范性、架构的可复用性及团队开发经验的提升，同时，成功的系统将影响客户对下一个系统的要求等。这种反馈机制构成了架构的商业周期。</li>
</ol>
<h3 id="912-软件架构的重要性"><a class="markdownIt-Anchor" href="#912-软件架构的重要性"></a> 9.1.2 软件架构的重要性</h3>
<p>  从技术角度看，软件架构的重要性表现为如下几方面。</p>
<ol>
<li>项目关系人之间交流的平台<br />
  软件系统的项目关系人分别关注系统的不同特性，而这些特性都由架构所决定，因此，架构提供了一个共同语言（公共的参考点），项目关系人以此作为彼此理解、协商、达成共识或相互沟通的基础。架构分析既依赖于又促进了这个层次上的交流。</li>
<li>早期设计决策<br />
  从软件生命周期来看，软件架构是所开发系统的最早设计决策的体现，主要表现为：<br />
  架构明确了对系统实现的约束条件：架构是架构设计师对系统实现的各方面进行权衡的结果，是总体设计的体现，因此，在具体实现时必须按架构的设计进行。<br />
  架构影响着系统的质量属性：要保证系统的高质量，具有完美的架构是必要的（虽然不充分）。<br />
  架构可以用来预测系统的质量，例如，可以根据经验对该架构的质量（如性能）作定性的判断。<br />
  架构为维护的决策提供根据。在架构层次上能为日后的更改决策提供推理、判断的依据。一个富有生命力的架构，应该是在最有可能更改的地方有所考虑（架构的柔性），使其在此点最容易进行更改。<br />
  架构有助于原型开发。可以按架构构造一个骨架系统（原型），例如，在早期实现一个可执行的特例，确定潜在的性能问题。<br />
  借助于架构进行成本与进度的估计。</li>
<li>在较高层面上实现软件复用<br />
  软件架构作为系统的抽象模型，可以在多个系统间传递（复用），特别是比较容易地应用到具有相似质量属性和功能需求的系统中。产品线通常共享一个架构。产品线的架构是开发组织的核心资产之一，利用架构及其范例进行多系统的开发，在开发时间、成本、生产率和产品质量方面具有极大的回报。基于架构的开发强调对各元素的组合或装配。系统开发还可以使用其他组织开发的元素，例如购买商业构件。</li>
<li>架构对开发的指导与规范意义不容忽略<br />
  架构作为系统的总体设计，它指导后续的详细设计和编码。架构使基于模板的开发成为可能，有利于开发的规范化和一致性，减少开发与维护成本。架构可以作为培训的基础，有利于培养开发团队和培训相关人员。<br />
  从软件开发过程来看，如果采用传统的软件开发模型（生命周期模型），则软件架构的建立应位于概要设计之前，需求分析之后。基于架构的软件开发模型则明确地把整个软件过程划分为架构需求、设计、文档化、评审（评估）、实现、演化等 6 个子过程。本章各节将分别对这些子过程进行讨论。</li>
</ol>
<h3 id="913-架构的模型"><a class="markdownIt-Anchor" href="#913-架构的模型"></a> 9.1.3 架构的模型</h3>
<p>  软件架构作为一个有机的整体，可以分解成多个侧面来认识，每个侧面强调它的不同方面的特征，从而使架构设计师能整体地把握它的重点。我们可以将软件架构归纳成 5 种模型：结构模型、框架模型、动态模型、过程模型和功能模型。最常用的是结构模型和动态模型。</p>
<ol>
<li>结构模型<br />
  这是一个最直观、最普遍的建模方法。这种方法以架构的构件、连接件和其他概念来刻画结构，并力图通过结构来反映系统的重要语义内容，包括系统的配置、约束、隐含的假设条件、风格、性质。研究结构模型的核心是架构描述语言。</li>
<li>框架模型<br />
  框架模型与结构模型类似，但它不太侧重描述结构的细节而更侧重于整体的结构。框架模型主要以一些特殊的问题为目标建立只针对和适应该问题的结构。</li>
<li>动态模型<br />
  动态模型是对结构或框架模型的补充，研究系统“大颗粒”的行为性质。例如，描述系统的重新配置或演化。动态可能指系统总体结构的配置、建立或拆除通信通道或计算的过程。</li>
<li>过程模型<br />
  过程模型研究构造系统的步骤和过程。因而结构是遵循某些过程脚本的结果。</li>
<li>功能模型<br />
  该模型认为架构由一组功能构件按层次组成，且下层向上层提供服务。它可以看作是一种特殊的框架模型。</li>
</ol>
<p>  这 5 种模型各有所长，也许将 5 种模型有机地统一在一起，形成一个完整的模型来刻画软件架构更合适。即将软件架构视为这些模型的统一体，通过这些模型的表述（文档）来完整反映软件架构。例如，Kruchten 在 1995 年提出了一个“4+1”的视图模型。“4+1” 视图模型从 5 个不同的视角包括逻辑视图、进程视图、物理视图、开发视图和场景视图来描述软件架构。每一个视图只关心系统的一个侧面，5 个视图结合在一起才能反映系统的软件架构的全部内容。“4+1”视图模型如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yM6WeP"><img src="https://s3.ax1x.com/2021/02/03/yM6WeP.png" alt="“4+1”视图模型" /></a></p>
<ol>
<li>逻辑视图<br />
  主要支持系统的功能需求，即系统提供给最终用户的服务。在逻辑视图中，系统分解成一系列的功能抽象，这些抽象主要来自问题领域。这种分解不但可以用来进行功能分析，而且可用作标识在整个系统的各个不同部分的通用机制和设计元素。在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图。逻辑视图中使用的风格为面向对象的风格，逻辑视图设计中要注意的主要问题是要保持一个单一的、内聚的对象模型贯穿整个系统。</li>
<li>开发视图<br />
  也称为模块视图，主要侧重于软件模块的组织和管理。软件可通过程序库或子系统进行组织，这样，对于一个软件系统，就可以由不同的人进行开发。开发视图要考虑软件内部的需求，如软件开发的容易性、软件的重用和软件的通用性，要充分考虑由于具体开发工具的不同而带来的局限性。开发视图通过系统输入输出关系的模型图和子系统图来描述。可以在确定了软件包含的所有元素之后描述完整的开发角度，也可以在确定每个元素之前，列出开发视图原则。</li>
<li>进程视图<br />
  侧重于系统的运行特性，主要关注一些非功能性的需求，例如系统的性能和可用性。进程视图强调并发性、分布性、系统集成性和容错能力，以及逻辑视图中的主要抽象的进程结构。它也定义逻辑视图中的各个类的操作具体是在哪一个线程中被执行的。进程视图可以描述成多层抽象，每个级别分别关注不同的方面。</li>
<li>物理视图<br />
  主要考虑如何把软件映射到硬件上，它通常要考虑到解决系统拓扑结构、系统安装、通信等问题。当软件运行于不同的节点上时，各视图中的构件都直接或间接地对应于系统的不同节点上。因此，从软件到节点的映射要有较高的灵活性，当环境改变时，对系统其他视图的影响最小。</li>
<li>场景<br />
  可以看作是那些重要系统活动的抽象，它使四个视图有机地联系起来，从某种意义上说，场景是最重要的需求抽象。在开发架构时，它可以帮助设计者找到架构的构件和它们之间的作用关系。同时，也可以用场景来分析一个特定的视图，或描述不同视图构件间是如何相互作用的。场景可以用文本表示，也可以用图形表示。</li>
</ol>
<blockquote>
<p>  逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构。对于不同的软件系统来说，侧重的角度也有所不同。例如，对于管理信息系统来说，比较侧重于从逻辑视图和开发视图来描述系统，而对于实时控制系统来说，则比较注重于从进程视图和物理视图来描述系统。</p>
</blockquote>
<h2 id="92-架构需求与软件质量属性"><a class="markdownIt-Anchor" href="#92-架构需求与软件质量属性"></a> 9.2 架构需求与软件质量属性</h2>
<p>  架构的基本需求主要是在满足功能属性的前提下，关注软件质量属性，架构设计则是为满足架构需求（质量属性）寻找适当的“战术”。<br />
  软件属性包括功能属性和质量属性，但是，软件架构（及软件架构设计师）重点关注的是质量属性。因为，在大量的可能结构中，可以使用不同的结构来实现同样的功能性，即功能性在很大程度上是独立于结构的，架构设计师面临着决策（对结构的选择），而功能性所关心的是它如何与其他质量属性进行交互，以及它如何限制其他质量属性。</p>
<h3 id="921-软件质量属性"><a class="markdownIt-Anchor" href="#921-软件质量属性"></a> 9.2.1 软件质量属性</h3>
<p>  《GB/T16260-1996(idt ISO／IEC9126：1991)信息技术软件产品评价质量特性及其使用指南》中描述的软件质量特性包括<code>功能性</code>、<code>可靠性</code>、<code>易用性</code>、<code>效率</code>、<code>可维护性</code>、<code>可移植性</code>等6个方面，每个方面都包含若干个子特性。<br />
  功能性：适合性、准确性、互操作性、依从性、安全性；<br />
  可靠性：成熟性、容错性、易恢复性；<br />
  易用性：易理解性、易学性、易操作性；<br />
  效率：时间特性、资源特性；<br />
  可维护性：易分析性、易改变性、稳定性、易测试性；<br />
  可移植性：适应性、易安装性、遵循性、易替换性；</p>
<p>  正如上述列举与分类，软件的质量属性很多，也有各种不同的分类法和不同的表述。虽然术语没有统一的定义，但其含义可以认为业界已有共识。下面选取常用的质量属性术语，并做逐一说明。</p>
<h4 id="1运行期质量属性"><a class="markdownIt-Anchor" href="#1运行期质量属性"></a> 1．运行期质量属性</h4>
<p>  性能：性能是指软件系统及时提供相应服务的能力。包括<code>速度</code>、<code>吞吐量</code>和<code>持续高速性</code>三方面的要求。<br />
  安全性：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。<br />
  易用性：指软件系统易于被使用的程度。<br />
  可伸缩性：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。<br />
  互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。<br />
  可靠性：软件系统在一定的时间内无故障运行的能力。<br />
  持续可用性：指系统长时间无故障运行的能力。与可靠性相关联，常将其纳入可靠性中。<br />
  鲁棒性：是指软件系统在一些非正常情况（如用户进行了非法操作、相关的软硬件系统发生了故障等）下仍能够正常运行的能力。也称健壮性或容错性。</p>
<h4 id="2开发期质量属性"><a class="markdownIt-Anchor" href="#2开发期质量属性"></a> 2.开发期质量属性</h4>
<p>  易理解性：指设计被开发人员理解的难易程度。<br />
  可扩展性：软件因适应新需求或需求变化而增加新功能的能力。也称为灵活性。<br />
  可重用性：指重用软件系统或某一部分的难易程度。<br />
  可测试性：对软件测试以证明其满足需求规范的难易程度。<br />
  可维护性：当需要修改缺陷、增加功能、提高质量属性时，定位修改点并实施修改的难易程度；<br />
  可移植性：将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。</p>
<p>  在实践中，架构设计师追求质量属性常常陷入“鱼和熊掌”的两难境地，这就需要架构设计师的决策智慧了。下表反映了质量属性之间的相互制约关系（正相关或负相关），其中“+”代表“行属性”能促进“列属性”；而“-”则相反。例如，第一列符号说明许多属性（行）对性能（列）有副作用，第一行符号说明性能（行）对许多属性（列）有副作用，认识这一点，对于架构决策的权衡很重要。</p>
<table>
<thead>
<tr>
<th></th>
<th>性能</th>
<th>安全性</th>
<th>持续可用性</th>
<th>可互操作性</th>
<th>可靠性</th>
<th>鲁棒性</th>
<th>易用性</th>
<th>可测试性</th>
<th>可重用性</th>
<th>可维护性</th>
<th>可扩展性</th>
<th>可移植性</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td></td>
<td></td>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>安全性</td>
<td>-</td>
<td></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>持续可用性</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>可互操作性</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>可靠性</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>鲁棒性</td>
<td>-</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>易用性</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>可测试性</td>
<td>-</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>可重用性</td>
<td>-</td>
<td>-</td>
<td></td>
<td>+</td>
<td>-</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>可维护性</td>
<td>-</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>可扩展性</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>可移植性</td>
<td>-</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="922-6个质量属性及实现"><a class="markdownIt-Anchor" href="#922-6个质量属性及实现"></a> 9.2.2 6个质量属性及实现</h3>
<p>  本节从架构关注点来研究质量属性实现，将质量属性分为 6 种：可用性、可修改性、性能、安全性、可测试性、易用性。其他的质量属性一般可纳入这几个属性中（在其他文献中为了强调常单列出来），例如，可扩充性可归入可修改性中（修改系统容量），可移植性也可以作为平台的可修改性来获得。对于未能纳入的其他质量属性，可以用本章的方法进行研<br />
究。<br />
  那么，如何描述质量属性需求呢？采用质量属性场景作为一种描述规范，它由以下6个部分组成，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/y1X7fU"><img src="https://s3.ax1x.com/2021/02/04/y1X7fU.png" alt="质量属性场景" /></a></p>
<p>  刺激源：生成该刺激的实体（人、计算机系统或其他激励器）；<br />
  刺激：刺激到达系统时可能产生的影响（即需要考虑和关注的情况）；<br />
  环境：该刺激在某条件内发生。如系统可能正处于过载情况；<br />
  制品：系统中受刺激的部分（某个制品被刺激）；<br />
  响应：刺激到达后所采取的行动；<br />
  响应度量：当响应发生时，应能够以某种方式对应其度量，用于对是否满足需求的测试。</p>
<p>  需要将一般的质量属性场景（一般场景）与具体的质量属性场景（具体场景）区别开来，前者是指独立于具体系统、适合于任何系统的一般性场景；而后者是指适合于正在考虑的某个特定系统的场景，具体场景通常是指从一般场景中抽取特定的、面向具体系统的内容。下面几个小节中为每个质量属性提供一张表，该表中给出了质量属性场景每部分的一些可能取值，整体上形成一个一般场景的表格描述。在实际应用时，根据系统的具体情况，从该表中选取适当的值，就能变成具体场景（可读性强、可应用），可以把具体场景的集合作为系统的质量属性需求。<br />
  实现这些质量属性的基本设计决策，称为“战术”，而把战术的集合称为“架构策略”。<br />
  这些架构策略供架构设计师选择。下面几个小节将对各质量属性的战术进行示例性的总结。<br />
  “战术”作为逻辑部件位于质量属性场景图的制品中，它旨在控制对刺激的响应。</p>
<h4 id="1可用性及其实现战术"><a class="markdownIt-Anchor" href="#1可用性及其实现战术"></a> 1．可用性及其实现战术</h4>
<h5 id="1-可用性的描述"><a class="markdownIt-Anchor" href="#1-可用性的描述"></a> 1. 可用性的描述</h5>
<p>  可用性的描述如下表所示。</p>
<table>
<thead>
<tr>
<th>场景的部分</th>
<th>可能的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>刺激源</td>
<td>系统内部、系统外部</td>
</tr>
<tr>
<td>刺激</td>
<td>错误：疏忽（构建对某输入未做出反应）、崩溃、时间不当（响应时间太早或太迟）、响应不当（以一个不正确的值来响应）</td>
</tr>
<tr>
<td>制品</td>
<td>系统的处理器、通信通道、存储器、进程</td>
</tr>
<tr>
<td>环境</td>
<td>正常操作、降级模式</td>
</tr>
<tr>
<td>响应</td>
<td>系统应记录检测事件，并进行如下一个或多个活动：<br> * 将其记录下来<br>* 通知适当的各方，包括用户和其他系统<br>* 根据规则屏蔽导致错误或故障的事件源<br>* 不可用（进入修理状态）<br>* 继续在正常或降级模型下运行</td>
</tr>
<tr>
<td>响应度量</td>
<td>可用时间、修复时间、各种情况的时间间隔</td>
</tr>
</tbody>
</table>
<p>  可用性一般场景可以用下图表示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/y1xdOJ"><img src="https://s3.ax1x.com/2021/02/04/y1xdOJ.png" alt="可用性一般场景" /></a></p>
<p>  对一般场景进行具体化可以得到可用性具体场景，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/y1xhmd"><img src="https://s3.ax1x.com/2021/02/04/y1xhmd.png" alt="可用性的一个具体场景（示例）" /></a></p>
<h5 id="2-可用性战术"><a class="markdownIt-Anchor" href="#2-可用性战术"></a> 2. 可用性战术</h5>
<p>  可用性战术的目标是阻止错误发展成故障，至少能够把错误的影响限制在一定范围内，从而使修复成为可能。战术分为：错误检测、错误恢复、错误预防。</p>
<ol>
<li>错误检测<br />
  命令/响应：一个构件发出一个命令，并希望在预定义的时间内收到一个来自审查构件的响应，例如远程错误的检测。<br />
  心跳（计时器）：一个构件定期发出一个心跳消息，另一个构件收听到消息，如果未收到心跳消息，则假定构件失败，并通知错误纠正构件。<br />
  异常：当出现异常时，异常处理程序开发执行。</li>
<li>错误恢复<br />
  表决：通过冗余构件（或处理器）与表决器连接，构件按相同的输入及算法计算输出值交给表决器，由表决器按表决算法（如多数规则）确定是否有构件出错，表决通常用在控制系统中。<br />
  主动冗余（热重启、热备份）：所有的冗余构件都以并行的方式对事件做出响应。它们都处在相同的状态，但仅使用一个构件的响应，丢弃其余构件的响应。错误发生时通过切换的方式使用另一个构件的响应。<br />
被动冗余（暧重启/双冗余/三冗余）：一个构件（主构件）对事件做出响应，并通知其他构件（备用的）必须进行的状态更新（同步）。当错误发生时，备用构件从最新同步点接替主构件的工作。<br />
  备件：备件是计算平台配置用于更换各种不同的故障构件。<br />
  状态再同步：主动和被动冗余战术要求所恢复的构件在重新提供服务前更新其状态。更新方法取决于可以承受的停机时间、更新的规模及更新的内容多少。<br />
  检查点/回滚：检查点就是使状态一致的同步点，它或者是定期进行，或者是对具体事件做出响应。当在两检查点之间发生故障时，则以这个一致状态的检查点（有快照）和之后发生的事务日志来恢复系统（数据库中常使用）。</li>
<li>错误预防<br />
  从服务中删除：如删除进程再重新启动，以防止内存泄露导致故障的发生。<br />
  事务：使用事务来保证数据的一致性，即几个相关密切的步骤，要么全成功，要么都不成功。<br />
  进程监视器：通过监视进程来处理进程的错误。</li>
</ol>
<h4 id="2可修改性及其实现战术"><a class="markdownIt-Anchor" href="#2可修改性及其实现战术"></a> 2．可修改性及其实现战术</h4>
<h5 id="1-可修改性的描述"><a class="markdownIt-Anchor" href="#1-可修改性的描述"></a> 1. 可修改性的描述</h5>
<p>  可修改性的描述如下表所示。</p>
<table>
<thead>
<tr>
<th>场景的部分</th>
<th>可能的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>刺激源</td>
<td>最终用户、开发人员、系统管理员</td>
</tr>
<tr>
<td>刺激</td>
<td>增加/删除/修改/改变：功能、质量属性、容量</td>
</tr>
<tr>
<td>制品</td>
<td>用户界面、平台、环境或关联系统</td>
</tr>
<tr>
<td>环境</td>
<td>运行时、编译时、构建时、设计时</td>
</tr>
<tr>
<td>响应</td>
<td>查找要修改的位置，进行修改（不影响其他功能），进行测试，部署所修改的内容</td>
</tr>
<tr>
<td>响应度量</td>
<td>对修改的成本进行度量，对修改的影响进行度量</td>
</tr>
</tbody>
</table>
<h5 id="2-可修改性战术"><a class="markdownIt-Anchor" href="#2-可修改性战术"></a> 2. 可修改性战术</h5>
<p>  包括局部化修改、防止连锁反应、推迟绑定时间。</p>
<ol>
<li>局部化修改<br />
  在设计期间为模块分配责任，以便把预期的变更限制在一定的范围内，从而降低修改的成本。<br />
  维持语义的一致性：语义的一致性指的是模块中责任之间的关系，使这些责任能够协同工作，不需要过多地依赖其他模块。耦合和内聚指标反映一致性，应该根据一组预期的变更来度量语义一致性。使用“抽象通用服务”（如应用框架的使用和其他中间软件的使用）来支持可修改性是其子战术。<br />
  预期期望的变更：通过对变更的预估，进行预设、准备，从而使变更的影响最小。<br />
  泛化该模块：使一个模块更通用、更广泛的功能。<br />
  限制可能的选择：如在更换某一模块（如处理器）时，限制为相同家族的成员。</li>
<li>防止连锁反应<br />
  由于模块之间有各种依赖性，因此，修改会产生连锁反应。防止连锁反应的战术如下。<br />
  信息隐藏：就是把某个实体的责任分解为更小的部分，并选择哪些信息成为公有的，哪些成为私有的，通过接口获得公有责任。<br />
  维持现有的接口：尽可能维持现有接口的稳定性。例如通过添加接口（通过新的接口提供新的服务）可以达到这一目的。<br />
  限制通信路径：限制与一个给定的模块共享数据的模块。这样可以减少由于数据产生/使用引入的连锁反应。<br />
  仲裁者的使用：在具有依赖关系的两个模块之间插入一个仲裁者，以管理与该依赖相关的活动。仲裁者有很多种类型，例如：桥、调停者、代理等就是可以提供把服务的语法从一种形式转换为另一种形式的仲裁者。</li>
<li>推迟绑定时间<br />
  系统具备在运行时进行绑定并允许非开发人员进行修改（配置）。<br />
  运行时注册：支持即插即用。<br />
  配置文件：在启动时设置参数。<br />
  多态：在方法调用的后期绑定。<br />
  构件更换：允许载入时绑定。</li>
</ol>
<h4 id="3性能及其实现战术"><a class="markdownIt-Anchor" href="#3性能及其实现战术"></a> 3．性能及其实现战术</h4>
<h5 id="1-性能的描述"><a class="markdownIt-Anchor" href="#1-性能的描述"></a> 1. 性能的描述</h5>
<p>  性能描述如下表所示。</p>
<table>
<thead>
<tr>
<th>场景的部分</th>
<th>可能的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>刺激源</td>
<td>系统内部或外部</td>
</tr>
<tr>
<td>刺激</td>
<td>定期事件、随机事件、偶然事件</td>
</tr>
<tr>
<td>制品</td>
<td>系统</td>
</tr>
<tr>
<td>环境</td>
<td>正常模式、超载模式</td>
</tr>
<tr>
<td>响应</td>
<td>处理刺激、改变服务级别</td>
</tr>
<tr>
<td>响应度量</td>
<td>度量等待、期限、吞吐量、缺失率、数据丢失等</td>
</tr>
</tbody>
</table>
<h5 id="2-性能战术"><a class="markdownIt-Anchor" href="#2-性能战术"></a> 2. 性能战术</h5>
<p>  性能与时间相关，影响事件的响应时间有两个基本因素。<br />
  资源消耗：事件到达后进入一系列的处理程序，每一步处理都要占用资源，而且在处理过程中消息在各构件之间转换，这些转换也需要占用资源。<br />
  闭锁时间：指对事件处理时碰到了资源争用、资源不可用或对其他计算的依赖等情况，就产生了等待时间。<br />
  性能的战术有如下几种。</p>
<ol>
<li>资源需求<br />
  减少处理事件流所需的资源：提高计算效率（如改进算法）、减少计算开销（如在可修改性与性能之间权衡，减少不必要的代理构件）。<br />
  减少所处理事件的数量：管理事件率、控制采样频率。<br />
  控制资源的使用：限制执行时间（如减少迭代次数）、限制队列大小。</li>
<li>资源管理<br />
  引入并发：引入并发对负载平衡很重要。<br />
  维持数据或计算的多个副本：C/S 结构中客户机 C 就是计算的副本，它能减少服务器计算的压力；高速缓存可以存放数据副本（在不同速度的存储库之间的缓冲）。<br />
  增加可用资源：在成本允许时，尽量使用速度更快的处理器、内存和网络。</li>
<li>资源仲裁<br />
  资源仲裁战术是通过如下调度策略来实现的：<br />
  先进/先出（FIFO）；<br />
  固定优先级调度：先给事件分配特定的优先级，再按优先级高低顺序分配资源；<br />
  动态优先级调度：轮转调度、时限时间最早优先；<br />
  静态调度：可以离线确定调度。</li>
</ol>
<h4 id="4安全性及其实现战术"><a class="markdownIt-Anchor" href="#4安全性及其实现战术"></a> 4．安全性及其实现战术</h4>
<h5 id="1-安全性的描述"><a class="markdownIt-Anchor" href="#1-安全性的描述"></a> 1. 安全性的描述</h5>
<p>  安全性的描述如下表所示。</p>
<table>
<thead>
<tr>
<th>场景的部分</th>
<th>可能的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>刺激源</td>
<td>对敏感资源进行访问的人或系统（合法的、非法的）</td>
</tr>
<tr>
<td>刺激</td>
<td>试图：显示数据、改变/删除数据、访问系统服务、降低系统服务的可用性</td>
</tr>
<tr>
<td>制品</td>
<td>系统服务、系统中的数据</td>
</tr>
<tr>
<td>环境</td>
<td>在线或离线、联网或断网、有或无防火墙</td>
</tr>
<tr>
<td>响应</td>
<td>对用户身份验证、阻止或允许对数据或服务的访问、授予可回收访问权、加密信息、限制服务的可用性、通知用户或系统</td>
</tr>
<tr>
<td>响应度量</td>
<td>增加安全性的成本、检测或确定攻击的可能性、降低服务级别后的成功率、恢复数据/服务</td>
</tr>
</tbody>
</table>
<h5 id="2-安全性战术"><a class="markdownIt-Anchor" href="#2-安全性战术"></a> 2. 安全性战术</h5>
<p>  包括抵抗攻击、检测攻击和从攻击中恢复。</p>
<ol>
<li>抵抗攻击<br />
  对用户进行身份验证：包括动态密码、一次性密码、数字证书及生物识别等；<br />
  对用户进行授权：即对用户的访问进行控制管理；<br />
  维护数据的机密性：一般通过对数据和通信链路进行加密来实现；<br />
  维护完整性：对数据添加校验或哈希值；<br />
  限制暴露的信息；<br />
  限制访问：如用防火墙、DMZ 策略。</li>
<li>检测攻击<br />
  一般通过“入侵检测”系统进行过滤、比较通信模式与历史基线等方法。</li>
<li>从攻击中恢复<br />
  恢复：与可用性中的战术相同；<br />
  识别攻击者：作为审计追踪，用于预防性或惩罚性目的。</li>
</ol>
<h4 id="5可测试性及其实现战术"><a class="markdownIt-Anchor" href="#5可测试性及其实现战术"></a> 5．可测试性及其实现战术</h4>
<h5 id="1-可测试性的描述"><a class="markdownIt-Anchor" href="#1-可测试性的描述"></a> 1. 可测试性的描述</h5>
<p>  可测试性的描述如下表所示。</p>
<table>
<thead>
<tr>
<th>场景的部分</th>
<th>可能的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>刺激源</td>
<td>各类测试人员（单元测试、集成测试、验收、用户）</td>
</tr>
<tr>
<td>刺激</td>
<td>一种测试</td>
</tr>
<tr>
<td>制品</td>
<td>设计、代码段、完整的应用</td>
</tr>
<tr>
<td>环境</td>
<td>设计时、开发时、编译时、部署时</td>
</tr>
<tr>
<td>响应</td>
<td>提供测试的状态值、测试环境与案例的准备</td>
</tr>
<tr>
<td>响应度量</td>
<td>测试成本、出现故障的概率、执行时间等</td>
</tr>
</tbody>
</table>
<h5 id="2-可测试性战术"><a class="markdownIt-Anchor" href="#2-可测试性战术"></a> 2. 可测试性战术</h5>
<p>  包括输入/输出和内部监控。</p>
<ol>
<li>输入/输出<br />
  记录/回放：指捕获跨接口的信息，并将其作为测试专用软件的输入；<br />
  将接口与实现分离：允许使用实现的替代（模拟器）来支持各种测试目的；<br />
  优化访问线路/接口：用测试工具来捕获或赋予构件的变量值。</li>
<li>内部监控<br />
  当监视器处于激活状态时，记录事件（如通过接口的信息）。</li>
</ol>
<h4 id="6易用性及其实现战术"><a class="markdownIt-Anchor" href="#6易用性及其实现战术"></a> 6．易用性及其实现战术</h4>
<h5 id="1-易用性的描述"><a class="markdownIt-Anchor" href="#1-易用性的描述"></a> 1. 易用性的描述</h5>
<p>  易用性的描述如下表所示。</p>
<table>
<thead>
<tr>
<th>场景的部分</th>
<th>可能的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>刺激源</td>
<td>最终用户</td>
</tr>
<tr>
<td>刺激</td>
<td>学习系统特性、有效使用系统、使错误的影响最低、适配系统、对系统满意</td>
</tr>
<tr>
<td>制品</td>
<td>系统</td>
</tr>
<tr>
<td>环境</td>
<td>运行时或配置时</td>
</tr>
<tr>
<td>响应</td>
<td>支持“学习系统特性”的相应：界面为用户所熟悉或使用帮助系统<br>支持“有效使用系统”的相应：数据/命令聚合或复用、界面是导航、操作的一致性、多个活动同时进行<br>支持“使错误的影响最低”的相应：撤销/取消、从故障中恢复、<br>支持“适配系统”的相应：界面为用户所熟悉或使用帮助系统<br>支持“对系统满意”的相应：界面为用户所熟悉或使用帮助系统</td>
</tr>
<tr>
<td>响应度量</td>
<td>测试成本、出现故障的概率、执行时间等</td>
</tr>
</tbody>
</table>
<h5 id="2-易用性战术"><a class="markdownIt-Anchor" href="#2-易用性战术"></a> 2. 易用性战术</h5>
<p>  包括运行时战术、设计时战术和支持用户主动操作。</p>
<ol>
<li>运行时战术<br />
  任务的模型：维护任务的信息，使系统了解用户试图做什么，并提供各种协助；<br />
  用户的模型：维护用户的信息，例如使系统以用户可以阅读页面的速度滚动页面；<br />
  系统的模型：维护系统的信息，它确定了期望的系统行为，并向用户提供反馈。</li>
<li>设计时战术<br />
  将用户接口与应用的其余部分分离开来，预计用户接口会频繁发生变化，因此，单独维护用户接口代码将实现变更局部化。这与可修改性相关。</li>
<li>支持用户主动操作<br />
  支持用户的主动操作，如支持“取消”、“撤销”、“聚合”和 “显示多个视图”。</li>
</ol>
<h2 id="93-软件架构风格"><a class="markdownIt-Anchor" href="#93-软件架构风格"></a> 9.3 软件架构风格</h2>
<p>  软件架构设计的一个核心问题是能否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。基于这个目的，学者们开始研究和实践软件架构的风格和类型问题。<br />
  软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式（ idiomatic paradigm）。架构风格定义了一个系统家族，即一个架构定义一个词汇表和一组约束。词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。按这种方式理解，软件架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。<br />
  对软件架构风格的研究和实践促进了对设计的重用，一些经过实践证实的解决方案也可以可靠地用于解决新的问题。架构风格不变的部分使不同的系统可以共享同一个实现代码。只要系统是使用常用的、规范的方法来组织，就可使别的设计者很容易地理解系统的架构。例如，如果某人把系统描述为客户/服务器模式，则不必给出设计细节，我们立刻就会明白<br />
系统是如何组织和工作的。<br />
  软件架构风格为大粒度的软件重用提供了可能。然而，对于应用架构风格来说，由于视点的不同，系统设计师有很大的选择余地。要为系统选择或设计某一个架构风格，必须根据特定项目的具体特点，进行分析比较后再确定，架构风格的使用几乎完全是特定的。</p>
<h3 id="931-软件架构风格分类"><a class="markdownIt-Anchor" href="#931-软件架构风格分类"></a> 9.3.1 软件架构风格分类</h3>
<p>  讨论架构风格时要回答的问题是：</p>
<ol>
<li>设计词汇表是什么？</li>
<li>构件和连接件的类型是什么？</li>
<li>可容许的结构模式是什么？</li>
<li>基本的计算模型是什么？</li>
<li>风格的基本不变性是什么？</li>
<li>其使用的常见例子是什么？</li>
<li>使用此风格的优缺点是什么？</li>
<li>其常见的特例是什么？<br />
  这些问题的回答包括了架构风格的最关键的四要素内容，即提供一个词汇表、定义一套配置规则、定义一套语义解释原则和定义对基于这种风格的系统所进行的分析。Garlan 和Shaw 根据此框架给出了通用架构风格的分类：</li>
<li>数据流风格<br />
  批处理序列；管道/过滤器。</li>
<li>调用/返回风格<br />
  主程序/子程序；面向对象风格；层次结构。</li>
<li>独立构件风格<br />
  进程通信；事件系统。</li>
<li>虚拟机风格<br />
  解释器；基于规则的系统。</li>
<li>仓库风格<br />
  数据库系统；超文本系统；黑板系统。</li>
</ol>
<h3 id="932-数据流风格"><a class="markdownIt-Anchor" href="#932-数据流风格"></a> 9.3.2 数据流风格</h3>
<p>  数据流风格的软件架构是一种最常见，结构最为简单的软件架构。这样的架构下，所有的数据按照流的形式在执行过程中前进，不存在结构的反复和重构，就像工厂中的汽车流水线一样，数据就像汽车零部件一样在流水线的各个节点上被加工，最终输出所需要的结果（一部完整的汽车）。在流动过程中，数据经过序列间的数据处理组件进行处理，然后将处理结果向后传送，最后进行输出。<br />
  数据流风格架构主要包括两种具体的架构风格：批处理序列和管道-过滤器。</p>
<h4 id="1-批处理序列"><a class="markdownIt-Anchor" href="#1-批处理序列"></a> 1. 批处理序列</h4>
<p>批  处理风格的每一步处理都是独立的，并且每一步是顺序执行的。只有当前一步处理完，后一步处理才能开始。数据传送在步与步之间作为一个整体。（组件为一系列固定顺序的计算单元，组件间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在前一步结束后才能开始，数据必须是完整的，以整体的方式传递）批处理的典型应用：</p>
<ol>
<li>经典数据处理；</li>
<li>程序开发；</li>
<li>Windows 下的 BAT 程序就是这种应用的典型实例。</li>
</ol>
<h4 id="2-管道和过滤器"><a class="markdownIt-Anchor" href="#2-管道和过滤器"></a> 2. 管道和过滤器</h4>
<p>  在管道/过滤器风格的软件架构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常通过对输入流的变换及增量计算来完成，所以在输入被完全消费之前，输出便产生了。因此，这里的构件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。此风格特别重要的过滤器必须是独立的实体，它不能与其他的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。一个管道/过滤器网络输出的正确性并不依赖于过滤器进行增量计算过程的顺序。<br />
  下图是管道/过滤器风格的示意图。一个典型的管道/过滤器架构的例子是以 UNIX shell 编写的程序。UNIX 既提供一种符号，以连接各组成部分（UNIX 的进程），又提供某种进程运行时机制以实现管道。另一个著名的例子是传统的编译器。传统的编译器一直被认为是一种管道系统，在该系统中，一个阶段（包括词法分析、语法分析、语义分析和代码生成）的输出是另一个阶段的输入。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yhiFF1"><img src="https://s3.ax1x.com/2021/02/19/yhiFF1.png" alt="管道/过滤器风格的架构" /></a></p>
<p>  管道/过滤器风格的软件架构具有许多很好的特点：</p>
<ol>
<li>使得软构件具有良好的隐蔽性和高内聚、低耦合的特点；</li>
<li>允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成；</li>
<li>支持软件重用。只要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来；</li>
<li>系统维护和增强系统性能简单。新的过滤器可以添加到现有系统中来；旧的可以被改进的过滤器替换掉；</li>
<li>允许对一些如吞吐量、死锁等属性的分析；</li>
<li>支持并行执行。每个过滤器是作为一个单独的任务完成，因此可与其他任务并行执行。</li>
</ol>
<p>  但是，这样的系统也存在着若干不利因素。</p>
<ol>
<li>通常导致进程成为批处理的结构。这是因为虽然过滤器可增量式地处理数据，但它们是独立的，所以设计者必须将每个过滤器看成一个完整的从输入到输出的转换；</li>
<li>不适合处理交互的应用。当需要增量地显示改变时，这个问题尤为严重；</li>
<li>因为在数据传输上没有通用的标准，每个过滤器都增加了解析和合成数据的工作，这样就导致了系统性能下降，并增加了编写过滤器的复杂性。</li>
</ol>
<h4 id="3-批处理序列风格与管道过滤器风格对比"><a class="markdownIt-Anchor" href="#3-批处理序列风格与管道过滤器风格对比"></a> 3. 批处理序列风格与管道过滤器风格对比</h4>
<p>  共同点：把任务分成一系列固定顺序的计算单元（组件）。组件间只通过数据传递交互。<br />
  区别：批处理是全部的、高潜伏性的，输入时可随机存取，无合作性、无交互性。而管道过滤器是递增的，数据结果延迟小，输入时处理局部化，有反馈、可交互。批处理强调数据传送在步与步之间作为一个整体，而管理过滤器无此要求。</p>
<h3 id="933-调用返回风格"><a class="markdownIt-Anchor" href="#933-调用返回风格"></a> 9.3.3 调用/返回风格</h3>
<p>  调用返回风格顾名思义，就是指在系统中采用了调用与返回机制。利用调用-返回实际上是一种分而治之的策略，其主要思想是将一个复杂的大系统分解为一些子系统，以便降低复杂度，并且增加可修改性。程序从其执行起点开始执行该构件的代码，程序执行结束，将控制返回给程序调用构件。<br />
  调用/返回风格架构主要包括三种具体的架构风格：主程序/子程序；面向对象风格；层次结构。</p>
<h4 id="1-主程序子程序"><a class="markdownIt-Anchor" href="#1-主程序子程序"></a> 1. 主程序/子程序</h4>
<p>  主程序/子程序风格是结构化开发时期的经典架构风格。这种风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。子程序通常可合成为模块。过程调用作为交互机制，即充当连接件。调用关系具有层次性，其语义逻辑表现为子程序的正确性，取决于它调用的子程序的正确性。</p>
<h4 id="2-面向对象风格"><a class="markdownIt-Anchor" href="#2-面向对象风格"></a> 2. 面向对象风格</h4>
<p>  抽象数据类型概念对软件系统有着重要作用，目前软件界已普遍使用面向对象系统。这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，因为它负责保持资源的完整性。对象是通过函数和过程的调用来交互的。<br />
  下图是数据抽象和面向对象风格的示意图。</p>
<p><img src="https://www.853tv.cn/imgs/2021/03/bb10ec06b2d5bf85.png" alt="数据抽象和面向对象风格的架构" /></p>
<p>  这种风格的两个重要特征为：</p>
<ol>
<li>对象负责维护其表示的完整性；</li>
<li>对象的表示对其他对象而言是隐蔽的。因为一个对象对它的客户隐藏了自己的表示，所以这些对象可以不影响它的客户就能改变其实现方法。</li>
</ol>
<p>  面向对象的系统有许多优点，并早已为人所知：</p>
<ol>
<li>因为对象对其他对象隐藏它的表示，所以可以改变一个对象的表示，而不影响其他的对象；</li>
<li>设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。</li>
</ol>
<p>  但是，面向对象的系统也存在着某些问题：</p>
<ol>
<li>为了使一个对象和另一个对象通过过程调用等进行交互，必须知道对象的标识。只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象；</li>
<li>必须修改所有显式调用它的其他对象，并消除由此带来的一些副作用。例如，如果 A 使用了对象 B，C 也使用了对象 B，那么，C 对 B 的使用所造成的对 A 的影响可能是料想不到的。</li>
</ol>
<h4 id="3-层次结构风格"><a class="markdownIt-Anchor" href="#3-层次结构风格"></a> 3. 层次结构风格</h4>
<p>  层次系统组织成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的输出函数外，内部的层只对相邻的层可见。这样的系统中构件在一些层实现了虚拟机（在另一些层次系统中层是部分不透明的）。连接件通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层间交互的约束。<br />
  这种风格支持基于可增加抽象层的设计。这样，允许将一个复杂问题分解成一个增量步骤序列的实现。由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件重用提供了强大的支持。<br />
  下图是层次系统风格的示意图。层次系统最广泛的应用是分层通信协议。在这一应用领域中，每一层提供一个抽象的功能，作为上层通信的基础。较低的层次定义低层的交互，最低层通常只定义硬件物理连接。</p>
<p><img src="https://www.853tv.cn/imgs/2021/03/2bc86053168c7ea1.png" alt="层次系统风格的架构" /></p>
<p>  层次系统有许多可取的属性：</p>
<ol>
<li>支持基于抽象程度递增的系统设计，使设计者可以把一个复杂系统按递增的步骤进行分解；</li>
<li>支持功能增强，因为每一层至多和相邻的上下层交互，因此功能的改变最多影响相邻的上下层；</li>
<li>支持重用。只要提供的服务接口定义不变，同一层的不同实现可以交换使用。这样，就可以定义一组标准的接口，而允许各种不同的实现方法。</li>
</ol>
<p>  但是，层次系统也有其不足之处：</p>
<ol>
<li>并不是每个系统都可以很容易地划分为分层的模式，甚至即使一个系统的逻辑结构是层次化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来；</li>
<li>很难找到一个合适的、正确的层次抽象方法。</li>
</ol>
<!-- 

### 1.1.3 数据表示
1. 原码  
如果机器字长为n，那么原码的定义如下：  
若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^(n-1) + |X|。  
若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2^0 + |X|。  
`负数首位为1`
2. 反码
如果机器字长为n，那么反码的定义如下：  
若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^n - 1 + |X|。  
若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2-2^-(n-1) + |X|。  
`负数按位取反`
3. 补码
如果机器字长为n，那么补码的定义如下：  
若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^n + |X|。  
若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2 + |X|。 
`负数按位取反+1`
4. 移码
在机器字长为n，偏移量为2^(n-1)的情况下，纯整数的移码为2^(n-1)+X,纯小数的移码为1+X。`补码符号位取反即可得到移码`  

### 1.1.4 校验码
计算机通常使用校验码的方法来检测传送的数据是否出问题。  
`码距`:一个编码系统中任意两个合法编码之间至少有多少个二进制位不同  
1. 奇偶校验码  
通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）或者偶数（偶校验），从而使码距变为2。  
常见的有：`水平奇偶校验码`，`垂直奇偶校验码`，`水平垂直校验码`
2. 海明码
海明码利用奇偶性来检错和纠错。在数据位之间的特定位置上插入K个校验位，通过扩大码距来实现检错和纠错。
3. 循环冗余校验码
利用多项式为K个数据位产生R个校验位，编码长度K+R记为N，N为CRC码的字长，又称为(n,k)码。   --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lufer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coder.lufer.cc/2020/12/24/系统架构设计师教程/">https://coder.lufer.cc/2020/12/24/系统架构设计师教程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coder.lufer.cc">Lufer</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/28/%E4%B8%AD%E5%85%B1%E4%B8%AD%E5%A4%AE%E5%85%B3%E4%BA%8E%E5%88%B6%E5%AE%9A%E5%9B%BD%E6%B0%91%E7%BB%8F%E6%B5%8E%E5%92%8C%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E7%AC%AC%E5%8D%81%E5%9B%9B%E4%B8%AA%E4%BA%94%E5%B9%B4%E8%A7%84%E5%88%92%E5%92%8C%E4%BA%8C%E3%80%87%E4%B8%89%E4%BA%94%E5%B9%B4%E8%BF%9C%E6%99%AF%E7%9B%AE%E6%A0%87%E7%9A%84%E5%BB%BA%E8%AE%AE/"><i class="fa fa-chevron-left">  </i><span>中共中央关于制定国民经济和社会发展第十四个五年规划和二〇三五年远景目标的建议</span></a></div><div class="next-post pull-right"><a href="/2020/12/21/%E4%BD%BF%E7%94%A8Valine%E4%BD%9C%E4%B8%BAHexo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BF%AE%E5%A4%8D%E7%9B%AE%E5%89%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"><span>使用Valine作为Hexo评论系统并修复目前存在的问题</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'VqMxq8YhQKdt87hjlDYA4UDq-MdYXbMMI',
  appKey:'jMbPNFw1782lMDtEz6mIwhx4',
  placeholder:'早8点-晚11点会自动发送邮件提醒',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2021 By Lufer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>