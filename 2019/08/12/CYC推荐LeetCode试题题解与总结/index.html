<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="CYC推荐LeetCode试题题解与总结"><meta name="keywords" content="Java,算法,数据结构"><meta name="author" content="Lufer"><meta name="copyright" content="Lufer"><title>CYC推荐LeetCode试题题解与总结 | Lufer</title><link rel="shortcut icon" href="https://s2.ax1x.com/2019/08/07/eI1NJH.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e2cd7e52254704223bd3b9c0461bc06e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script src="https://www.googletagmanager.com/gtag/js?id=G-T5L2KPFS29"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-T5L2KPFS29');</script><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"D3K0O2R6F2","apiKey":"4e808ae377111360493e99d31970584c","indexName":"BLOG_LUFER","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text"> 第一部分 算法思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 一、双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum"><span class="toc-text"> 1. 有序数组的 Two Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E4%B8%A4%E6%95%B0%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="toc-text"> 2.两数平方和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6"><span class="toc-text"> 3.反转字符串中的元音字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-ii"><span class="toc-text"> 4.验证回文字符串 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text"> 5. 归并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF"><span class="toc-text"> 6. 判断链表是否存在环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 7. 最长子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%8E%92%E5%BA%8F"><span class="toc-text"> 二、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text"> 1.数组中的第K个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E5%A4%9A%E7%9A%84-k-%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text"> 2. 出现频率最多的 k 个元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%89%E7%85%A7%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F"><span class="toc-text"> 3. 按照字符出现次数对字符串排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%89%E9%A2%9C%E8%89%B2%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-text"> 4. 按颜色进行排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E8%B4%AA%E5%BF%83"><span class="toc-text"> 三、贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E9%85%8D%E9%A5%BC%E5%B9%B2"><span class="toc-text"> 1. 分配饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%8C%BA%E9%97%B4%E4%B8%AA%E6%95%B0"><span class="toc-text"> 2. 不重叠的区间个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8A%95%E9%A3%9E%E9%95%96%E5%88%BA%E7%A0%B4%E6%B0%94%E7%90%83"><span class="toc-text"> 3. 投飞镖刺破气球</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E5%92%8C%E5%BA%8F%E5%8F%B7%E9%87%8D%E7%BB%84%E9%98%9F%E5%88%97"><span class="toc-text"> 4. 根据身高和序号重组队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E5%A4%A7%E7%9A%84%E6%94%B6%E7%9B%8A"><span class="toc-text"> 5. 买卖股票最大的收益</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text"> 代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A-ii"><span class="toc-text"> 6. 买卖股票的最大收益 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%A7%8D%E6%A4%8D%E8%8A%B1%E6%9C%B5"><span class="toc-text"> 7. 种植花朵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 8. 判断是否为子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-text"> 思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E6%88%90%E4%B8%BA%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E7%BB%84"><span class="toc-text"> 9. 修改一个数成为非递减数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C"><span class="toc-text"> 10. 子数组最大的和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%88%86%E9%9A%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E5%90%8C%E7%A7%8D%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text"> 11. 分隔字符串使同种字符出现在一起</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text"> 四、二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B1%82%E5%BC%80%E6%96%B9"><span class="toc-text"> 1. 求开方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-text"> 2. 大于给定元素的最小元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-single-element"><span class="toc-text"> 3. 有序数组的 Single Element</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-text"> 4. 第一个错误的版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-text"> 5. 旋转数组的最小数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4"><span class="toc-text"> 6. 查找区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%88%86%E6%B2%BB"><span class="toc-text"> 五、分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8A%A0%E6%8B%AC%E5%8F%B7"><span class="toc-text"> 1. 给表达式加括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text"> 2. 不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%90%9C%E7%B4%A2"><span class="toc-text"> 六、搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E7%9F%AD%E5%8D%95%E8%AF%8D%E8%B7%AF%E5%BE%84"><span class="toc-text"> 1. 最短单词路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E7%9A%84%E8%BF%9E%E9%80%9A%E9%9D%A2%E7%A7%AF"><span class="toc-text"> 2. 查找最大的连通面积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%95%B0%E7%9B%AE"><span class="toc-text"> 3. 矩阵中的连通分量数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%95%B0%E7%9B%AE"><span class="toc-text"> 4. 好友关系的连通分量数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A1%AB%E5%85%85%E5%B0%81%E9%97%AD%E5%8C%BA%E5%9F%9F"><span class="toc-text"> 5. 填充封闭区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%83%BD%E5%88%B0%E8%BE%BE%E7%9A%84%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%92%8C%E5%A4%A7%E8%A5%BF%E6%B4%8B%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text"> 6. 能到达的太平洋和大西洋的区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text"> 七、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text"> 1. 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%BA%E7%9B%97%E6%8A%A2%E5%8A%AB"><span class="toc-text"> 2. 强盗抢劫</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%BA%E7%9B%97%E5%9C%A8%E7%8E%AF%E5%BD%A2%E8%A1%97%E5%8C%BA%E6%8A%A2%E5%8A%AB"><span class="toc-text"> 3. 强盗在环形街区抢劫</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text"> 4. 矩阵的最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%80%BB%E8%B7%AF%E5%BE%84%E6%95%B0"><span class="toc-text"> 5. 矩阵的总路径数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-text"> 6. 数组区间和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AD%89%E5%B7%AE%E9%80%92%E5%A2%9E%E5%AD%90%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text"> 7. 数组中等差递增子区间的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="toc-text"> 8. 分割整数的最大乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%8C%89%E5%B9%B3%E6%96%B9%E6%95%B0%E6%9D%A5%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0"><span class="toc-text"> 9. 按平方数来分割整数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-45"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0%E6%9E%84%E6%88%90%E5%AD%97%E6%AF%8D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> 10. 分割整数构成字母字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-46"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 11. 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-47"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%B8%80%E7%BB%84%E6%95%B4%E6%95%B0%E5%AF%B9%E8%83%BD%E5%A4%9F%E6%9E%84%E6%88%90%E7%9A%84%E6%9C%80%E9%95%BF%E9%93%BE"><span class="toc-text"> 12. 一组整数对能够构成的最长链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-48"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%9C%80%E9%95%BF%E6%91%86%E5%8A%A8%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 13. 最长摆动子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-49"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%A4%E9%83%A8%E5%88%86"><span class="toc-text"> 14. 划分数组为和相等的两部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-50"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%94%B9%E5%8F%98%E4%B8%80%E7%BB%84%E6%95%B0%E7%9A%84%E6%AD%A3%E8%B4%9F%E5%8F%B7%E4%BD%BF%E5%BE%97%E5%AE%83%E4%BB%AC%E7%9A%84%E5%92%8C%E4%B8%BA%E4%B8%80%E7%BB%99%E5%AE%9A%E6%95%B0"><span class="toc-text"> 15. 改变一组数的正负号使得它们的和为一给定数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-51"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-49"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-01-%E5%AD%97%E7%AC%A6%E6%9E%84%E6%88%90%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> 16. 01 字符构成最多的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-52"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-50"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%89%BE%E9%9B%B6%E9%92%B1%E7%9A%84%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E6%95%B0"><span class="toc-text"> 17. 找零钱的最少硬币数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-53"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-51"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%89%BE%E9%9B%B6%E9%92%B1%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%BB%84%E5%90%88"><span class="toc-text"> 18. 找零钱的硬币数组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-54"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-52"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E5%8D%95%E8%AF%8D%E5%88%97%E8%A1%A8%E5%88%86%E5%89%B2"><span class="toc-text"> 19. 字符串按单词列表分割</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-55"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-53"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text"> 20. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-56"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-54"><span class="toc-text"> 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text"> 背包问题总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%9C%80%E8%A6%81%E5%86%B7%E5%8D%B4%E6%9C%9F%E7%9A%84%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93"><span class="toc-text"> 21. 需要冷却期的股票交易</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-57"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-55"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%9C%80%E8%A6%81%E4%BA%A4%E6%98%93%E8%B4%B9%E7%94%A8%E7%9A%84%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93"><span class="toc-text"> 22. 需要交易费用的股票交易</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-58"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-56"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%8F%AA%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%B8%A4%E6%AC%A1%E7%9A%84%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93"><span class="toc-text"> 23. 只能进行两次的股票交易</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-59"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-57"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%8F%AA%E8%83%BD%E8%BF%9B%E8%A1%8C-k-%E6%AC%A1%E7%9A%84%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93"><span class="toc-text"> 24. 只能进行 k 次的股票交易</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-60"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-58"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%88%A0%E9%99%A4%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AE%83%E4%BB%AC%E7%9B%B8%E7%AD%89"><span class="toc-text"> 25. 删除两个字符串的字符使它们相等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-61"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-59"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text"> 26. 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-62"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-60"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%AD%97%E7%AC%A6"><span class="toc-text"> 27. 复制粘贴字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-63"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-61"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E6%95%B0%E5%AD%A6"><span class="toc-text"> 八、数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E7%B4%A0%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-text"> 1. 生成素数序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-64"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-62"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E8%BF%9B%E5%88%B6"><span class="toc-text"> 2. 7进制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-65"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-63"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-16-%E8%BF%9B%E5%88%B6"><span class="toc-text"> 3. 16 进制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-66"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-64"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-26-%E8%BF%9B%E5%88%B6"><span class="toc-text"> 4. 26 进制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-67"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-65"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%9F%E8%AE%A1%E9%98%B6%E4%B9%98%E5%B0%BE%E9%83%A8%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA-0"><span class="toc-text"> 5. 统计阶乘尾部有多少个 0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-68"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-66"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95"><span class="toc-text"> 6. 二进制加法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-69"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-67"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95"><span class="toc-text"> 7. 字符串加法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-70"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-68"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BD%BF%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%83%BD%E7%9B%B8%E7%AD%89"><span class="toc-text"> 8. 改变数组元素使所有的数组元素都相等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-71"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-69"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%9A%E4%BA%8E-n-2-%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text"> 9. 数组中出现次数多于 n &#x2F; 2 的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-72"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-70"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text"> 10. 平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-73"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-71"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E7%9A%84-n-%E6%AC%A1%E6%96%B9"><span class="toc-text"> 11. 3 的 n 次方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-74"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-72"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-text"> 12. 乘积数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-75"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-73"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0"><span class="toc-text"> 13. 找出数组中的乘积最大的三个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-76"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-74"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3"><span class="toc-text"> 第二部分 数据结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%93%BE%E8%A1%A8"><span class="toc-text"> 一、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9"><span class="toc-text"> 1. 找出两个链表的交点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-77"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-75"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="toc-text"> 2. 链表反转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-78"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-76"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-text"> 3. 归并两个有序的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-79"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-77"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-text"> 4. 从有序链表中删除重复节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-80"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-78"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text"> 5. 删除链表的倒数第 n 个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-81"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-79"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E7%BB%93%E7%82%B9"><span class="toc-text"> 6. 交换链表中的相邻结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-82"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-80"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C"><span class="toc-text"> 7. 链表求和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-83"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-81"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text"> 8. 回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-84"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-82"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="toc-text"> 9. 分隔链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-85"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-83"><span class="toc-text"> 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E6%8C%89%E5%A5%87%E5%81%B6%E8%81%9A%E9%9B%86"><span class="toc-text"> 10. 链表元素按奇偶聚集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-86"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-84"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%A0%91"><span class="toc-text"> 二、树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-text"> 1. 树的高度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-87"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-85"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-text"> 2. 平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-88"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-86"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84"><span class="toc-text"> 3. 两节点的最长路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-89"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-87"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BF%BB%E8%BD%AC%E6%A0%91"><span class="toc-text"> 4. 翻转树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-90"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-88"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BD%92%E5%B9%B6%E4%B8%A4%E6%A3%B5%E6%A0%91"><span class="toc-text"> 5. 归并两棵树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-91"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-89"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%A4%E6%96%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0"><span class="toc-text"> 6. 判断路径和是否等于一个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-92"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-90"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BB%9F%E8%AE%A1%E8%B7%AF%E5%BE%84%E5%92%8C%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F"><span class="toc-text"> 7. 统计路径和等于一个数的路径数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-93"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-91"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AD%90%E6%A0%91"><span class="toc-text"> 8. 子树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-94"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-92"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%A0%91%E7%9A%84%E5%AF%B9%E7%A7%B0"><span class="toc-text"> 9. 树的对称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-95"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-93"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84"><span class="toc-text"> 10. 最小路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-96"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-94"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BB%9F%E8%AE%A1%E5%B7%A6%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C"><span class="toc-text"> 11. 统计左叶子节点的和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-97"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-95"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-text"> 12. 相同节点值的最大路径长度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-98"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-96"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E9%97%B4%E9%9A%94%E9%81%8D%E5%8E%86"><span class="toc-text"> 13. 间隔遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-99"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-97"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text"> 14. 找出二叉树中第二小的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-100"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-98"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%80%E6%A3%B5%E6%A0%91%E6%AF%8F%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0"><span class="toc-text"> 15. 一棵树每层节点的平均数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-101"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-99"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%BE%97%E5%88%B0%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text"> 16. 得到左下角的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-102"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-100"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86"><span class="toc-text"> 17. 非递归实现二叉树的三种遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-103"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-101"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text"> 18. 修剪二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-104"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-102"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text"> 19. 寻找二叉查找树的第 k 个元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-105"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-103"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E9%83%BD%E5%8A%A0%E4%B8%8A%E6%AF%94%E5%AE%83%E5%A4%A7%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC"><span class="toc-text"> 20. 把二叉查找树每个节点的值都加上比它大的节点的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-106"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-104"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text"> 21. 二叉查找树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-107"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-105"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text"> 22. 二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-108"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-106"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BB%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text"> 23. 从有序数组中构造二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-109"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-107"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%A0%B9%E6%8D%AE%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%9E%84%E9%80%A0%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text"> 24. 根据有序链表构造平衡的二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-110"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-108"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%BD%BF%E5%AE%83%E4%BB%AC%E7%9A%84%E5%92%8C%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%BB%99%E5%AE%9A%E5%80%BC"><span class="toc-text"> 25. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-111"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-109"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E5%B7%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="toc-text"> 26. 在二叉查找树中查找两个节点之差的最小绝对值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-112"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-110"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%80%BC"><span class="toc-text"> 27. 寻找二叉查找树中出现次数最多的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-113"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-111"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-trie"><span class="toc-text"> 28. 实现一个 Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-114"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-112"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-trie%E7%94%A8%E6%9D%A5%E6%B1%82%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text"> 29. 实现一个 Trie，用来求前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-115"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-113"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text"> 三、栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text"> 1. 用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-116"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-114"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-text"> 2. 用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-117"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-115"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E5%B0%8F%E5%80%BC%E6%A0%88"><span class="toc-text"> 3. 最小值栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-118"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-116"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-text"> 4. 用栈实现括号匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-119"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-117"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E4%B8%8E%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%AF%94%E5%AE%83%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="toc-text"> 5. 数组中元素与下一个比它大的元素之间的距离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-120"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-118"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%A4%A7%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text"> 6. 循环数组中比当前元素大的下一个元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-121"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-119"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text"> 四、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC"><span class="toc-text"> 1. 数组中两个数的和为给定值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-122"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-120"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text"> 2. 判断数组是否含有重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-123"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-121"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 3. 最长和谐序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-124"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-122"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text"> 4. 最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-125"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-123"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> 五、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E7%9A%84%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C"><span class="toc-text"> 1. 两个字符串包含的字符是否完全相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-126"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-124"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%97%E4%B8%80%E7%BB%84%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88%E5%8F%AF%E4%BB%A5%E7%BB%84%E6%88%90%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-text"> 2. 计算一组字符集合可以组成的回文字符串的最大长度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-127"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-125"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%8C%E6%9E%84"><span class="toc-text"> 3. 字符串同构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-128"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-126"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="toc-text"> 4. 回文子字符串个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-129"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-127"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-text"> 5. 判断一个整数是否是回文数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-130"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-128"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BB%9F%E8%AE%A1%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD-1-%E5%92%8C%E8%BF%9E%E7%BB%AD-0-%E6%95%B0%E9%87%8F%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="toc-text"> 6. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-131"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-129"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5"><span class="toc-text"> 六、数组与矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%8A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-0-%E7%A7%BB%E5%88%B0%E6%9C%AB%E5%B0%BE"><span class="toc-text"> 1. 把数组中的 0 移到末尾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-132"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-130"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%94%B9%E5%8F%98%E7%9F%A9%E9%98%B5%E7%BB%B4%E5%BA%A6"><span class="toc-text"> 2. 改变矩阵维度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-133"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-131"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%BF%9E%E7%BB%AD-1"><span class="toc-text"> 3. 找出数组中最长的连续 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-134"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-132"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE"><span class="toc-text"> 4. 有序矩阵查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-135"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-133"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E7%9A%84-kth-element"><span class="toc-text"> 5. 有序矩阵的 Kth Element</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-136"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-134"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%9C%A8-1-n-%E4%B9%8B%E9%97%B4%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E8%A2%AB%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%92%8C%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0"><span class="toc-text"> 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-137"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-135"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%95%B0%E7%BB%84%E5%80%BC%E5%9C%A8-1-n-%E4%B9%8B%E9%97%B4"><span class="toc-text"> 7. 找出数组中重复的数，数组值在 [1, n] 之间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-138"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-136"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E7%9B%B8%E9%82%BB%E5%B7%AE%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text"> 8. 数组相邻差值的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-139"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-137"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6"><span class="toc-text"> 9. 数组的度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-140"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-138"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AF%B9%E8%A7%92%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E7%9F%A9%E9%98%B5"><span class="toc-text"> 10. 对角元素相等的矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-141"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-139"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-text"> 11. 嵌套数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-142"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-140"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84"><span class="toc-text"> 12. 分隔数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-143"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-141"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%9B%BE"><span class="toc-text"> 七、图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-text"> 1. 判断是否为二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-144"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-142"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7"><span class="toc-text"> 2. 课程安排的合法性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-145"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-143"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text"> 3. 课程安排的顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-146"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-144"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text"> 4. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-147"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-145"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text"> 八、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%9F%E8%AE%A1%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BD%8D%E4%B8%8D%E5%90%8C"><span class="toc-text"> 1. 统计两个数的二进制表示有多少位不同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-148"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-146"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text"> 2. 数组中唯一一个不重复的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-149"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-147"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E9%82%A3%E4%B8%AA%E6%95%B0"><span class="toc-text"> 3. 找出数组中缺失的那个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-150"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-148"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text"> 4. 只出现一次的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-151"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-149"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text"> 5. 数组中不重复的两个元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-152"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-150"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BF%BB%E8%BD%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E6%AF%94%E7%89%B9%E4%BD%8D"><span class="toc-text"> 6. 翻转一个数的比特位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-153"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-151"><span class="toc-text"> 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9"><span class="toc-text"> 额外内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF-2-%E7%9A%84-n-%E6%AC%A1%E6%96%B9"><span class="toc-text"> 7. 判断一个数是不是 2 的 n 次方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-154"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-152"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF-4-%E7%9A%84-n-%E6%AC%A1%E6%96%B9"><span class="toc-text"> 8. 判断一个数是不是 4 的 n 次方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-153"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BD%8D%E7%BA%A7%E8%A1%A8%E7%A4%BA%E6%98%AF%E5%90%A6%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%9E%E7%BB%AD%E7%9A%84-0-%E5%92%8C-1"><span class="toc-text"> 9. 判断一个数的位级表示是否不会出现连续的 0 和 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-155"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-154"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E8%A1%A5%E7%A0%81"><span class="toc-text"> 10. 求一个数的补码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-156"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-155"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="toc-text"> 11. 实现整数的加法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-157"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-156"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="toc-text"> 12. 字符串数组最大乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-158"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-157"><span class="toc-text"> 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%BB%9F%E8%AE%A1%E4%BB%8E-0-~-n-%E6%AF%8F%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text"> 13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-159"><span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-158"><span class="toc-text"> 代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/08/07/eI1UWd.jpg"></div><div class="author-info__name text-center">Lufer</div><div class="author-info__description text-center">新的一天开始啦</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">16</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">大佬们</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yuque.com/grace-gu">Grace</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://1ogisk.cn/">Logik</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://legume.ltd">豆哥</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://esportnosave.cn/">EsportsNoSave</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Lufer</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">CYC推荐LeetCode试题题解与总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">29.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 137 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本篇文章主要记录来自CYC所推荐的200+LeetCode经典题目解题思路与题解。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode 题解 - 目录.md</a></p>
<h1 id="第一部分-算法思想"><a class="markdownIt-Anchor" href="#第一部分-算法思想"></a> 第一部分 算法思想</h1>
<h2 id="一-双指针"><a class="markdownIt-Anchor" href="#一-双指针"></a> 一、双指针</h2>
<h3 id="1-有序数组的-two-sum"><a class="markdownIt-Anchor" href="#1-有序数组的-two-sum"></a> 1. 有序数组的 Two Sum</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p>
<h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4>
<p>因为数组是有序的，所以用双指针首尾想加，结果偏大则尾部向前移动，结果偏小则头部向后移动。</p>
<h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;i&lt;j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=numbers[i]+numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(temp==target)</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">0</span>]=i+<span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>]=j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(temp&lt;target)</span><br><span class="line">                    i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2两数平方和"><a class="markdownIt-Anchor" href="#2两数平方和"></a> 2.两数平方和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/">https://leetcode-cn.com/problems/sum-of-square-numbers/</a></p>
<h4 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h4>
<p>如果一个数可以被两个数的平方和表示，那么这两个数一定都小于这个数的平方根，故可先求平方根，然后同样双指针前后夹逼。</p>
<h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=(<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">for</span>(;left&lt;=right;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=left*left+right*right;</span><br><span class="line">            <span class="keyword">if</span>(temp==c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(temp&gt;c)</span><br><span class="line">                    right--;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3反转字符串中的元音字符"><a class="markdownIt-Anchor" href="#3反转字符串中的元音字符"></a> 3.反转字符串中的元音字符</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/submissions/">https://leetcode-cn.com/problems/reverse-vowels-of-a-string/submissions/</a></p>
<h4 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h4>
<p>双指针前后寻找，找到元音后停止，当两个指针都停止时，交换字符，然后继续移动。</p>
<h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4>
<p>代码感觉写的比较繁琐，有待优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s!=<span class="keyword">null</span> &amp;&amp; s.length()!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>[] ch=<span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">            String letter=<span class="string">&quot;aieouAIEOU&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=s.length()-<span class="number">1</span>;i&lt;=j;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> left=s.charAt(i);</span><br><span class="line">                <span class="keyword">char</span> right=s.charAt(j);</span><br><span class="line">                <span class="keyword">int</span> flagleft=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> flagright=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[i]=left;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(letter.indexOf(left)==-<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[i]=left;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flagleft=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((letter.indexOf(right)==-<span class="number">1</span>)&amp;&amp;(i&lt;j))</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[j]=right;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flagright=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(flagleft==<span class="number">1</span>&amp;&amp;flagright==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[i]=right;</span><br><span class="line">                    ch[j]=left;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s=String.valueOf(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4验证回文字符串-ii"><a class="markdownIt-Anchor" href="#4验证回文字符串-ii"></a> 4.验证回文字符串 Ⅱ</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p>
<h4 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h4>
<p>前后指针同时移动，判断是否相等。当第一次判断不相等时，前后各移动一次通过子函数判断是否可行，如果依然构不成回文则返回false。</p>
<h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] != chars[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> validPalindrome(chars, i, j - <span class="number">1</span>) || validPalindrome(chars, i + <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[l] != chars[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-归并两个有序数组"><a class="markdownIt-Anchor" href="#5-归并两个有序数组"></a> 5. 归并两个有序数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p>
<h4 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h4>
<p>本意是二路归并，但是本题需要在nums1上进行修改。<br />
因为两个数组全是有序的，而nums1数组空间足够，后部用0填充，则可以从最后的0开始向前填充，双指针对比nums1与nums2的队尾，取较大者进行填充。<br />
如果结束时nums1的指针未移动到头部，则前部的较小元素无需移动，已经有序，直接结束。<br />
如果nums2指针未移动到头部，说明nums1所有较大元素已经移好，只需将剩下元素复制过去即可。</p>
<h4 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-判断链表是否存在环"><a class="markdownIt-Anchor" href="#6-判断链表是否存在环"></a> 6. 判断链表是否存在环</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
<h4 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h4>
<p>常用套路，快慢指针，慢指针位移1，快指针位移2，如果有环必会相遇。</p>
<p>骚套路：</p>
<ol>
<li>用Set存ListNode，如果已经contains，则存在环</li>
<li>每次给Node的value设定一个特殊值，如果检测到，则存在环</li>
</ol>
<h4 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针版</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别人写的骚套路，复制过来记一下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt;node = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.contains(head))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-最长子序列"><a class="markdownIt-Anchor" href="#7-最长子序列"></a> 7. 最长子序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/</a></p>
<h4 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h4>
<p>对于字典里的每一个字符串，分别判断其是否是s的子串，然后找最长的返回。<br />
双指针分别指向s和字典需要判断的串。</p>
<h4 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            String temp=d.get(i);</span><br><span class="line">            <span class="keyword">if</span>(issubstring(s,temp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.length()&lt;temp.length())</span><br><span class="line">                    res=temp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>((temp.length()==res.length())&amp;&amp;(temp.compareTo(res)&lt;<span class="number">0</span>))</span><br><span class="line">                        res=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issubstring</span><span class="params">(String s,String target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;s.length()&amp;&amp;j&lt;target.length();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==target.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==target.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-排序"><a class="markdownIt-Anchor" href="#二-排序"></a> 二、排序</h2>
<h3 id="1数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#1数组中的第k个最大元素"></a> 1.数组中的第K个最大元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>
<h4 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h4>
<p>利用Java的PriorityQueue来实现小顶堆，然后维护堆大小为K，堆顶元素就是第K大的。</p>
<h4 id="代码-8"><a class="markdownIt-Anchor" href="#代码-8"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(NlogK)，空间复杂度 O(K)。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k)</span><br><span class="line">                pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-出现频率最多的-k-个元素"><a class="markdownIt-Anchor" href="#2-出现频率最多的-k-个元素"></a> 2. 出现频率最多的 k 个元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p>
<h4 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h4>
<p>利用桶排序，每个桶存储每个元素的出现频率，然后维护一个小顶堆,手动实现comparator，通过获取频率来比较，就可以获得第K大,但是获取到的是反序的，再reverse一下。</p>
<h4 id="代码-9"><a class="markdownIt-Anchor" href="#代码-9"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            m.put(num, m.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> m.get(a)-m.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : m.keySet()) &#123;</span><br><span class="line">            pq.add(key);</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&gt;k)</span><br><span class="line">                pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-按照字符出现次数对字符串排序"><a class="markdownIt-Anchor" href="#3-按照字符出现次数对字符串排序"></a> 3. 按照字符出现次数对字符串排序</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">https://leetcode-cn.com/problems/sort-characters-by-frequency/</a></p>
<h4 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h4>
<p>用map统计频率，因为全部都需要，所以可以通过手动实现Comparator来维护一个大顶堆，然后遍历堆重复字符还原字符串。</p>
<h4 id="代码-10"><a class="markdownIt-Anchor" href="#代码-10"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c=s.charAt(i);</span><br><span class="line">            map.put(c,map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Character&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;Character&gt;(<span class="keyword">new</span> Comparator&lt;Character&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Character a,Character b)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(b)-map.get(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Character key : map.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            pq.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] res=<span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=pq.remove();</span><br><span class="line">            <span class="keyword">int</span> times=map.get(ch);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[j++]=ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-按颜色进行排序"><a class="markdownIt-Anchor" href="#4-按颜色进行排序"></a> 4. 按颜色进行排序</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/submissions/">https://leetcode-cn.com/problems/sort-colors/submissions/</a></p>
<h4 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h4>
<p>原地排序，三向切分，用三个指针进行排序，中间指针用来遍历，左指针指向已拍好的0的位置，右指针指向已排好的2的位置，然后两面夹逼swap。</p>
<h4 id="代码-11"><a class="markdownIt-Anchor" href="#代码-11"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=-<span class="number">1</span>,mid=<span class="number">0</span>,right=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(mid&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums,++left,mid++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==<span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(nums,mid,--right);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-贪心"><a class="markdownIt-Anchor" href="#三-贪心"></a> 三、贪心</h2>
<p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>
<h3 id="1-分配饼干"><a class="markdownIt-Anchor" href="#1-分配饼干"></a> 1. 分配饼干</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a></p>
<h4 id="思路-12"><a class="markdownIt-Anchor" href="#思路-12"></a> 思路</h4>
<p>要满足的孩子足够多，应从需求最低的孩子开始满足，这样可以用最小的代价来满足，从而使饼干可以满足更多的人。</p>
<p>CYC给了证明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</span><br></pre></td></tr></table></figure>
<h4 id="代码-12"><a class="markdownIt-Anchor" href="#代码-12"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gi=<span class="number">0</span>,si=<span class="number">0</span>;gi&lt;g.length&amp;&amp;si&lt;s.length;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[si]&gt;=g[gi])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                si++;</span><br><span class="line">                gi++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                si++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-不重叠的区间个数"><a class="markdownIt-Anchor" href="#2-不重叠的区间个数"></a> 2. 不重叠的区间个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p>
<h4 id="思路-13"><a class="markdownIt-Anchor" href="#思路-13"></a> 思路</h4>
<p>按区间尾部排序，尾部越小，后面的剩余空间越大，可以放置的区间越多。<br />
排序后查找不重叠区间数，就是最大区间数，从而可得移除的最小区间数。</p>
<h4 id="代码-13"><a class="markdownIt-Anchor" href="#代码-13"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(intervals,Comparator.comparingInt(o-&gt;o[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            right=intervals[i][<span class="number">1</span>];</span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length-total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-投飞镖刺破气球"><a class="markdownIt-Anchor" href="#3-投飞镖刺破气球"></a> 3. 投飞镖刺破气球</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p>
<h4 id="思路-14"><a class="markdownIt-Anchor" href="#思路-14"></a> 思路</h4>
<p>同样是求不重叠区间数，有多少不重叠区间就要多少个飞镖。</p>
<h4 id="代码-14"><a class="markdownIt-Anchor" href="#代码-14"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(points.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points,Comparator.comparingInt(o-&gt;o[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&lt;=right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            right=points[i][<span class="number">1</span>];</span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-根据身高和序号重组队列"><a class="markdownIt-Anchor" href="#4-根据身高和序号重组队列"></a> 4. 根据身高和序号重组队列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p>
<h4 id="思路-15"><a class="markdownIt-Anchor" href="#思路-15"></a> 思路</h4>
<p>按身高排序，相同身高按位置排序，位置大的在后面。<br />
然后开始重建队列，假设候选队列为 A，已经站好队的队列为 B。<br />
从 A 里挑身高最高的人 x 出来，插入到 B. 因为 B 中每个人的身高都比 x 要高，因此 x 插入的位置，就是看 x 前面应该有多少人就行了。比如 x 前面有 5 个人，那 x 就插入到队列 B 的第 5 个位置。</p>
<h4 id="代码-15"><a class="markdownIt-Anchor" href="#代码-15"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="keyword">if</span>(people==<span class="keyword">null</span>||people.length==<span class="number">0</span>||people[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        Arrays.sort(people,(a,b)-&gt;(a[<span class="number">0</span>]==b[<span class="number">0</span>]?a[<span class="number">1</span>]-b[<span class="number">1</span>]:b[<span class="number">0</span>]-a[<span class="number">0</span>]));</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(people[i][<span class="number">1</span>],people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[people.length][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-买卖股票最大的收益"><a class="markdownIt-Anchor" href="#5-买卖股票最大的收益"></a> 5. 买卖股票最大的收益</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/</a></p>
<h4 id="思路-16"><a class="markdownIt-Anchor" href="#思路-16"></a> 思路</h4>
<p>遍历每一天的价格，保存到目前为止的最小值，然后判断当天卖出的收益，寻找收益最大值。</p>
<h4 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmin=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curmin&gt;prices[i])</span><br><span class="line">                curmin=prices[i];</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-curmin&gt;max)</span><br><span class="line">                max=prices[i]-curmin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-买卖股票的最大收益-ii"><a class="markdownIt-Anchor" href="#6-买卖股票的最大收益-ii"></a> 6. 买卖股票的最大收益 II</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<h4 id="思路-17"><a class="markdownIt-Anchor" href="#思路-17"></a> 思路</h4>
<p>借用CYC的说法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于 [a, b, c, d]，如果有 a &lt;&#x3D; b &lt;&#x3D; c &lt;&#x3D; d ，那么最大收益为 d - a。而 d - a &#x3D; (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</span><br></pre></td></tr></table></figure>
<h4 id="代码-16"><a class="markdownIt-Anchor" href="#代码-16"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                res+=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-种植花朵"><a class="markdownIt-Anchor" href="#7-种植花朵"></a> 7. 种植花朵</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-place-flowers/">https://leetcode-cn.com/problems/can-place-flowers/</a></p>
<h4 id="思路-18"><a class="markdownIt-Anchor" href="#思路-18"></a> 思路</h4>
<p>有连续三个0就可以栽一个，所以针对每一位判断前后是否都是0，两头边界要增加一个判断。<br />
可以栽之后下一位不可再判断，要手动移位一次，或者把当前位置为1。</p>
<h4 id="代码-17"><a class="markdownIt-Anchor" href="#代码-17"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed==<span class="keyword">null</span>||flowerbed.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n==<span class="number">0</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flowerbed.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> pre=i==<span class="number">0</span>?<span class="number">0</span>:flowerbed[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> next=i==flowerbed.length-<span class="number">1</span>?<span class="number">0</span>:flowerbed[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="number">0</span>&amp;&amp;next==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">//flowerbed[i] = 1;往后移一位或者改为1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-判断是否为子序列"><a class="markdownIt-Anchor" href="#8-判断是否为子序列"></a> 8. 判断是否为子序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/">https://leetcode-cn.com/problems/is-subsequence/</a></p>
<h4 id="思路-19"><a class="markdownIt-Anchor" href="#思路-19"></a> 思路</h4>
<p>没弄明白这题放这干啥，不就是移动判断吗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动实现的慢版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si=<span class="number">0</span>,ti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;si&lt;s.length()&amp;&amp;ti&lt;t.length();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(si)==t.charAt(ti))</span><br><span class="line">            &#123;</span><br><span class="line">                si++;</span><br><span class="line">                ti++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ti++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(si!=s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//借助indexOf实现的快版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=s.charAt(i);</span><br><span class="line">            index=t.indexOf(ch,index+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(index==-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-修改一个数成为非递减数组"><a class="markdownIt-Anchor" href="#9-修改一个数成为非递减数组"></a> 9. 修改一个数成为非递减数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/">https://leetcode-cn.com/problems/non-decreasing-array/</a></p>
<h4 id="思路-20"><a class="markdownIt-Anchor" href="#思路-20"></a> 思路</h4>
<p>如果出现 a[i] &gt; a[i+1],改变一个数就面临两种选择</p>
<ol>
<li>把a[i]变大</li>
<li>把a[i+1] 变小</li>
</ol>
<p>而选择哪一种方式，还需要比较a[i-1] 与 a[i+1]的值<br />
如果a[i-1]比a[i+1]小，则需要把夹在中间的较大的a[i]变小，使a[i]=a[i+1]。<br />
如果a[i-1]比a[i+1]大，则a[i-1],a[i]已经非递减，需要把a[i+1]=a[i],来保持非递减。<br />
改变完之后，记录改变次数，再检测是否升序。<br />
如果次数大于1，至少改了两次 返回false。<br />
先让前两个有序<br />
因为没有左边没有数 所以对于前两个数来说，最佳选择就是把 a[0] 变小。<br />
此外还需要注意先确保前两个有序。</p>
<h4 id="代码-18"><a class="markdownIt-Anchor" href="#代码-18"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[<span class="number">0</span>]=nums[<span class="number">1</span>];</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i]=nums[i+<span class="number">1</span>];</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-子数组最大的和"><a class="markdownIt-Anchor" href="#10-子数组最大的和"></a> 10. 子数组最大的和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/submissions/">https://leetcode-cn.com/problems/maximum-subarray/submissions/</a></p>
<h4 id="思路-21"><a class="markdownIt-Anchor" href="#思路-21"></a> 思路</h4>
<p>O(n)的方法遍历一次，如果当前和已经小于0，则让其等于当前遍历值，否则加上当前遍历值。<br />
和Max比较，得最大值。</p>
<h4 id="代码-19"><a class="markdownIt-Anchor" href="#代码-19"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cursum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cursum&lt;=<span class="number">0</span>)</span><br><span class="line">                cursum=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cursum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(cursum&gt;max)</span><br><span class="line">                max=cursum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-分隔字符串使同种字符出现在一起"><a class="markdownIt-Anchor" href="#11-分隔字符串使同种字符出现在一起"></a> 11. 分隔字符串使同种字符出现在一起</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">https://leetcode-cn.com/problems/partition-labels/</a></p>
<h4 id="思路-22"><a class="markdownIt-Anchor" href="#思路-22"></a> 思路</h4>
<p>对于每一个字符，查找其最后出现位置last，然后从当前位置到last遍历字符，挨个查找最后出现位置last2，当last2比last大时，说明不能在last出分隔，用last2替换last。当一次子查询完成后，代表当前获得了一个可以分割的子串。</p>
<p><code>lastIndexOf(ch,index)的index是他娘的从后往前的索引，我以为是从前往后的，差点改疯了</code></p>
<h4 id="代码-20"><a class="markdownIt-Anchor" href="#代码-20"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=S.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> lastindex=S.lastIndexOf(ch);</span><br><span class="line">            <span class="keyword">if</span>(lastindex!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(i++;i&lt;=lastindex;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> ch2=S.charAt(i);</span><br><span class="line">                    <span class="keyword">int</span> lastindex2=S.lastIndexOf(ch2);</span><br><span class="line">                    <span class="keyword">if</span>(lastindex2&gt;lastindex)</span><br><span class="line">                        lastindex=lastindex2;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(i-start);</span><br><span class="line">                start=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-二分查找"><a class="markdownIt-Anchor" href="#四-二分查找"></a> 四、二分查找</h2>
<h3 id="1-求开方"><a class="markdownIt-Anchor" href="#1-求开方"></a> 1. 求开方</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/submissions/">https://leetcode-cn.com/problems/sqrtx/submissions/</a></p>
<h4 id="思路-23"><a class="markdownIt-Anchor" href="#思路-23"></a> 思路</h4>
<p>从1~X进行二分查找，判断平方与X的大小，并进行左右边界缩减。<br />
注意当左右相交还未找到x的平方根时，检查x的平方根与left的大小，如果x的平方根较大则取left，若left较大则取left-1</p>
<h4 id="代码-21"><a class="markdownIt-Anchor" href="#代码-21"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/mid==mid)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(x/mid&gt;mid)</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x/left&lt;left)</span><br><span class="line">            <span class="keyword">return</span> left-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-大于给定元素的最小元素"><a class="markdownIt-Anchor" href="#2-大于给定元素的最小元素"></a> 2. 大于给定元素的最小元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/</a></p>
<h4 id="思路-24"><a class="markdownIt-Anchor" href="#思路-24"></a> 思路</h4>
<p>常理来讲，二分查找，左右夹逼直到边界相交，如果到最后还没找到则直接输出最左。</p>
<h4 id="代码-22"><a class="markdownIt-Anchor" href="#代码-22"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> n = letters.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (letters[m] &lt;= target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l &lt; n ? letters[l] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-有序数组的-single-element"><a class="markdownIt-Anchor" href="#3-有序数组的-single-element"></a> 3. 有序数组的 Single Element</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/submissions/">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/submissions/</a></p>
<h4 id="思路-25"><a class="markdownIt-Anchor" href="#思路-25"></a> 思路</h4>
<p>因为数组是有序的，所以一定是<code>11,22,33,4,55,66,77</code>这样成对出现，中间夹一个单。<br />
故用二分法进行查找，看mid值是与左相等还是与右相等。<br />
如果与左相等，判断从left到mid有多少数，因为要去除与mid相等的mid-1，故如果mid-left是偶数的话，则left<sub>mid-1是奇数，其中必然加载要寻找的数值，故`right=mid-2`，如果是奇数的话，说明从left</sub>mid-1是偶数，则要寻找的数值在另一侧，则<code>left=mid+1</code>。如果与右相等，则同理。如果左右都不等，则mid即为要寻找的数值。</p>
<h4 id="代码-23"><a class="markdownIt-Anchor" href="#代码-23"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==nums[mid-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((mid-left)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    right=mid-<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((right-mid)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                        left=mid+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-第一个错误的版本"><a class="markdownIt-Anchor" href="#4-第一个错误的版本"></a> 4. 第一个错误的版本</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/submissions/">https://leetcode-cn.com/problems/first-bad-version/submissions/</a></p>
<h4 id="思路-26"><a class="markdownIt-Anchor" href="#思路-26"></a> 思路</h4>
<p>简单地二分查找，注意left和right的处理。</p>
<h4 id="代码-24"><a class="markdownIt-Anchor" href="#代码-24"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#5-旋转数组的最小数字"></a> 5. 旋转数组的最小数字</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p>
<h4 id="思路-27"><a class="markdownIt-Anchor" href="#思路-27"></a> 思路</h4>
<p>因为原来是有序的，旋转之后一定是要寻找的<code>N&lt;right&lt;left&lt;N-1</code> ，故如果mid比right大了，mid一定是在<code>left~N-1</code>这个区间，故缩减左边界；如果mid比right小，说明mid在<code>N~right</code>这个区间内，故缩减右边界。</p>
<h4 id="代码-25"><a class="markdownIt-Anchor" href="#代码-25"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= nums[h]) &#123;</span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-查找区间"><a class="markdownIt-Anchor" href="#6-查找区间"></a> 6. 查找区间</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<h4 id="思路-28"><a class="markdownIt-Anchor" href="#思路-28"></a> 思路</h4>
<p>分两步来找左右边界，以target的第一次出现位置作为条件二分查找来获取左边界，以target+1来二分查找来获取右边界，其-1就是左边界。</p>
<h4 id="代码-26"><a class="markdownIt-Anchor" href="#代码-26"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = binarySearch(nums, target);</span><br><span class="line">        <span class="keyword">int</span> last = binarySearch(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (first == nums.length || nums[first] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;first, Math.max(first, last)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= target) &#123;</span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-分治"><a class="markdownIt-Anchor" href="#五-分治"></a> 五、分治</h2>
<h3 id="1-给表达式加括号"><a class="markdownIt-Anchor" href="#1-给表达式加括号"></a> 1. 给表达式加括号</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">https://leetcode-cn.com/problems/different-ways-to-add-parentheses/</a></p>
<h4 id="思路-29"><a class="markdownIt-Anchor" href="#思路-29"></a> 思路</h4>
<p>从左往右遍历每一个符号，在每一个符号处分开进行分制，相当于对符号左右两侧加括号。<br />
分治之后对于每个子串再遍历，从而完成每一种加括号的情况。</p>
<h4 id="代码-27"><a class="markdownIt-Anchor" href="#代码-27"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;+&#x27;</span>||ch==<span class="string">&#x27;-&#x27;</span>||ch==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; left=diffWaysToCompute(input.substring(<span class="number">0</span>,i));</span><br><span class="line">                List&lt;Integer&gt; right=diffWaysToCompute(input.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> li=<span class="number">0</span>;li&lt;left.size();li++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ri=<span class="number">0</span>;ri&lt;right.size();ri++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ch==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                            res.add(left.get(li)+right.get(ri));</span><br><span class="line">                        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                            res.add(left.get(li)-right.get(ri));</span><br><span class="line">                        <span class="keyword">if</span>(ch==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                            res.add(left.get(li)*right.get(ri));</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==<span class="number">0</span>)</span><br><span class="line">            res.add(Integer.parseInt(input));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-不同的二叉搜索树"><a class="markdownIt-Anchor" href="#2-不同的二叉搜索树"></a> 2. 不同的二叉搜索树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p>
<h4 id="思路-30"><a class="markdownIt-Anchor" href="#思路-30"></a> 思路</h4>
<p>对于连续整数序列[left, right]中的一点i，若要生成以i为根节点的BST，则有如下规律：<br />
i左边的序列可以作为左子树结点，i右边的序列可以作为右子树结点，所以左右分治，生成子树的所有情况，然后遍历，加上根节点构建当前树。</p>
<h4 id="代码-28"><a class="markdownIt-Anchor" href="#代码-28"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> generateSubtrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateSubtrees</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; e) &#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= e; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generateSubtrees(s, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateSubtrees(i + <span class="number">1</span>, e);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> li=<span class="number">0</span>;li&lt;left.size();li++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ri=<span class="number">0</span>;ri&lt;right.size();ri++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left.get(li);</span><br><span class="line">                    root.right=right.get(ri);</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-搜索"><a class="markdownIt-Anchor" href="#六-搜索"></a> 六、搜索</h2>
<h3 id="1-最短单词路径"><a class="markdownIt-Anchor" href="#1-最短单词路径"></a> 1. 最短单词路径</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">https://leetcode-cn.com/problems/word-ladder/</a></p>
<h4 id="思路-31"><a class="markdownIt-Anchor" href="#思路-31"></a> 思路</h4>
<p>说实话，看题解思路看懂了，自己做还是没头绪。</p>
<ol>
<li>对给定的 wordList 做预处理，找出所有的通用状态。将通用状态记录在字典中，键是通用状态，值是所有具有通用状态的单词。</li>
<li>将包含 beginWord 和 1 的元组放入队列中，1 代表节点的层次。我们需要返回 endWord 的层次也就是从 beginWord 出发的最短距离。</li>
<li>为了防止出现环，使用访问数组记录。</li>
<li>当队列中有元素的时候，取出第一个元素，记为 current_word。</li>
<li>找到 current_word 的所有通用状态，并检查这些通用状态是否存在其它单词的映射，这一步通过检查 all_combo_dict 来实现。</li>
<li>从 all_combo_dict 获得的所有单词，都和 current_word 共有一个通用状态，所以都和 current_word 相连，因此将他们加入到队列中。</li>
<li>对于新获得的所有单词，向队列中加入元素 (word, level + 1) 其中 level 是 current_word 的层次。</li>
<li>最终当你到达期望的单词，对应的层次就是最短变换序列的长度。</li>
</ol>
<h4 id="代码-29"><a class="markdownIt-Anchor" href="#代码-29"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since all words are of same length.</span></span><br><span class="line">    <span class="keyword">int</span> L = beginWord.length();</span><br><span class="line">    <span class="comment">// Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">    <span class="comment">// from any given word. By changing one letter at a time.</span></span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; allComboDict = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    wordList.forEach(</span><br><span class="line">        word -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">            <span class="comment">// Key is the generic word</span></span><br><span class="line">            <span class="comment">// Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">            String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line">            ArrayList&lt;String&gt; transformations =</span><br><span class="line">                allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            transformations.add(word);</span><br><span class="line">            allComboDict.put(newWord, transformations);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue for BFS</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q = <span class="keyword">new</span> LinkedList&lt;Pair&lt;String, Integer&gt;&gt;();</span><br><span class="line">    Q.add(<span class="keyword">new</span> Pair(beginWord, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visited to make sure we don&#x27;t repeat processing same word.</span></span><br><span class="line">    HashMap&lt;String, Boolean&gt; visited = <span class="keyword">new</span> HashMap&lt;String, Boolean&gt;();</span><br><span class="line">    visited.put(beginWord, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;String, Integer&gt; node = Q.remove();</span><br><span class="line">      String word = node.getKey();</span><br><span class="line">      <span class="keyword">int</span> level = node.getValue();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intermediate words for current word</span></span><br><span class="line">        String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next states are all the words which share the same intermediate state.</span></span><br><span class="line">        <span class="keyword">for</span> (String adjacentWord : allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;String&gt;())) &#123;</span><br><span class="line">          <span class="comment">// If at any point if we find what we are looking for</span></span><br><span class="line">          <span class="comment">// i.e. the end word - we can return with the answer.</span></span><br><span class="line">          <span class="keyword">if</span> (adjacentWord.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">          <span class="keyword">if</span> (!visited.containsKey(adjacentWord)) &#123;</span><br><span class="line">            visited.put(adjacentWord, <span class="keyword">true</span>);</span><br><span class="line">            Q.add(<span class="keyword">new</span> Pair(adjacentWord, level + <span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-查找最大的连通面积"><a class="markdownIt-Anchor" href="#2-查找最大的连通面积"></a> 2. 查找最大的连通面积</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">https://leetcode-cn.com/problems/max-area-of-island/</a></p>
<h4 id="思路-32"><a class="markdownIt-Anchor" href="#思路-32"></a> 思路</h4>
<p>遍历所有节点，从当前节点出发上下左右开始寻找所有连同的1，来寻找最大值。已经查找过得点可以置为0，以免再次查找。</p>
<h4 id="代码-30"><a class="markdownIt-Anchor" href="#代码-30"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea = Math.max(maxArea, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            area += dfs(grid, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-矩阵中的连通分量数目"><a class="markdownIt-Anchor" href="#3-矩阵中的连通分量数目"></a> 3. 矩阵中的连通分量数目</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a></p>
<h4 id="思路-33"><a class="markdownIt-Anchor" href="#思路-33"></a> 思路</h4>
<p>与上题基本一样。</p>
<h4 id="代码-31"><a class="markdownIt-Anchor" href="#代码-31"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> islandsNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    islandsNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandsNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            dfs(grid, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-好友关系的连通分量数目"><a class="markdownIt-Anchor" href="#4-好友关系的连通分量数目"></a> 4. 好友关系的连通分量数目</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friend-circles/">https://leetcode-cn.com/problems/friend-circles/</a></p>
<h4 id="思路-34"><a class="markdownIt-Anchor" href="#思路-34"></a> 思路</h4>
<p>由于两个人互为好友，这个图一定是对角线对称的，我们可以从每个人出发遍历其朋友圈进行DFS，对于通过DFS遍历查找过得人，可以用一个标记数组来标记。</p>
<h4 id="代码-32"><a class="markdownIt-Anchor" href="#代码-32"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">                dfs(M, visited, i);</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                visited[j] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(m, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-填充封闭区域"><a class="markdownIt-Anchor" href="#5-填充封闭区域"></a> 5. 填充封闭区域</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">https://leetcode-cn.com/problems/surrounded-regions/</a></p>
<h4 id="思路-35"><a class="markdownIt-Anchor" href="#思路-35"></a> 思路</h4>
<p>先遍历上下左右边界，把所有连通的<code>O</code>用<code>N</code>来代替，然后遍历整个数组，把<code>N</code>换位<code>O</code>，把<code>O</code>换为<code>X</code>即可。</p>
<h4 id="代码-33"><a class="markdownIt-Anchor" href="#代码-33"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            dfs(board,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(board,<span class="number">0</span>,i);</span><br><span class="line">            dfs(board,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;N&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || board[i][j] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            dfs(board, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-能到达的太平洋和大西洋的区域"><a class="markdownIt-Anchor" href="#6-能到达的太平洋和大西洋的区域"></a> 6. 能到达的太平洋和大西洋的区域</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">https://leetcode-cn.com/problems/pacific-atlantic-water-flow/</a></p>
<h4 id="思路-36"><a class="markdownIt-Anchor" href="#思路-36"></a> 思路</h4>
<p>从上下左右边界出发，寻找递增路线从而找到每个大洋可以触及的节点，如果两个大洋都能触及，则满足要求。</p>
<h4 id="代码-34"><a class="markdownIt-Anchor" href="#代码-34"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">        <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">            dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">            dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                    List&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    temp.add(i);</span><br><span class="line">                    temp.add(j);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (canReach[r][c]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        canReach[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextR = d[<span class="number">0</span>] + r;</span><br><span class="line">            <span class="keyword">int</span> nextC = d[<span class="number">1</span>] + c;</span><br><span class="line">            <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n</span><br><span class="line">                    || matrix[r][c] &gt; matrix[nextR][nextC]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(nextR, nextC, canReach);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-动态规划"><a class="markdownIt-Anchor" href="#七-动态规划"></a> 七、动态规划</h2>
<h3 id="1-爬楼梯"><a class="markdownIt-Anchor" href="#1-爬楼梯"></a> 1. 爬楼梯</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<h4 id="思路-37"><a class="markdownIt-Anchor" href="#思路-37"></a> 思路</h4>
<p>如果用<code>dp[i]</code>代表到第i级台阶的跳法，由于一次可以跳一级或者两级，所以<code>dp[i]=dp[i-1]+dp[i-2]</code></p>
<h4 id="代码-35"><a class="markdownIt-Anchor" href="#代码-35"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-强盗抢劫"><a class="markdownIt-Anchor" href="#2-强盗抢劫"></a> 2. 强盗抢劫</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p>
<h4 id="思路-38"><a class="markdownIt-Anchor" href="#思路-38"></a> 思路</h4>
<p>如果用<code>dp[i]</code>代表在当前房屋所能获取的最大收益，那么对于房屋i，一共有两种选择，即偷和不偷。如果偷的话，获得的收益就是<code>dp[i-2]+nums[i]</code>,如果不偷，那么收益就是<code>dp[i-1]</code>，两者取大者，就是当前房屋的最大收益，随后遍历即可。</p>
<h4 id="代码-36"><a class="markdownIt-Anchor" href="#代码-36"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-强盗在环形街区抢劫"><a class="markdownIt-Anchor" href="#3-强盗在环形街区抢劫"></a> 3. 强盗在环形街区抢劫</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p>
<h4 id="思路-39"><a class="markdownIt-Anchor" href="#思路-39"></a> 思路</h4>
<p>与非环抢劫的区别就是要单独处理首尾，第一个与最后一个只能选一个抢。</p>
<h4 id="代码-37"><a class="markdownIt-Anchor" href="#代码-37"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>),rob(nums,<span class="number">1</span>,nums.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-矩阵的最小路径和"><a class="markdownIt-Anchor" href="#4-矩阵的最小路径和"></a> 4. 矩阵的最小路径和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>
<h4 id="思路-40"><a class="markdownIt-Anchor" href="#思路-40"></a> 思路</h4>
<p>对于矩阵每一行进行一次遍历，每行的每个格子都只有从上走下来和从左走过来两种选择，所以<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j]</code>。</p>
<h4 id="代码-38"><a class="markdownIt-Anchor" href="#代码-38"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=dp[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空间优化版本，一维dp数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] = dp[j];        <span class="comment">// 只能从上侧走到该位置</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>];    <span class="comment">// 只能从左侧走到该位置</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] += grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-矩阵的总路径数"><a class="markdownIt-Anchor" href="#5-矩阵的总路径数"></a> 5. 矩阵的总路径数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p>
<h4 id="思路-41"><a class="markdownIt-Anchor" href="#思路-41"></a> 思路</h4>
<p>对于每个<code>dp[i][j]</code>，到达该格子有从左和从上两个方式到达，最顶上和最左边的边界只有一种方式到达。</p>
<h4 id="代码-39"><a class="markdownIt-Anchor" href="#代码-39"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-数组区间和"><a class="markdownIt-Anchor" href="#6-数组区间和"></a> 6. 数组区间和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/">https://leetcode-cn.com/problems/range-sum-query-immutable/</a></p>
<h4 id="思路-42"><a class="markdownIt-Anchor" href="#思路-42"></a> 思路</h4>
<p>因为会多次调用，所以每次都累加是不合适的。遍历数组一遍，保存每次到i的累和，然后返回两个边界的累和差值即可。</p>
<h4 id="代码-40"><a class="markdownIt-Anchor" href="#代码-40"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-数组中等差递增子区间的个数"><a class="markdownIt-Anchor" href="#7-数组中等差递增子区间的个数"></a> 7. 数组中等差递增子区间的个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/arithmetic-slices/">https://leetcode-cn.com/problems/arithmetic-slices/</a></p>
<h4 id="思路-43"><a class="markdownIt-Anchor" href="#思路-43"></a> 思路</h4>
<p>用<code>dp[i]</code>代表以<code>A[i]</code>为结尾的等差数列的数量，那么只有两种情况：</p>
<ol>
<li>当前的A[i]与前面的数据项构不成等差数列，则此处为0。</li>
<li>当前的A[i]与前面的数据能构成等差数列，此时有<code>A[i]-A[i-1]=A[i-1]-A[i-2]</code>,那么此时的等差数列种数为<code>dp[i-1]+1</code></li>
</ol>
<h4 id="代码-41"><a class="markdownIt-Anchor" href="#代码-41"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt : dp) &#123;</span><br><span class="line">            total += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-分割整数的最大乘积"><a class="markdownIt-Anchor" href="#8-分割整数的最大乘积"></a> 8. 分割整数的最大乘积</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p>
<h4 id="思路-44"><a class="markdownIt-Anchor" href="#思路-44"></a> 思路</h4>
<p>如果用<code>dp[i]</code>代表正整数i拆分后的最大乘积，那么他有三种选择：</p>
<ol>
<li>dp[i]自身</li>
<li>从<code>1~dp[i]</code>遍历，然后获得j*dp[i-j]</li>
<li>从<code>1~dp[i]</code>遍历，然后获得j*(i-j)</li>
</ol>
<p>取三者最大值</p>
<h4 id="代码-42"><a class="markdownIt-Anchor" href="#代码-42"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-按平方数来分割整数"><a class="markdownIt-Anchor" href="#9-按平方数来分割整数"></a> 9. 按平方数来分割整数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p>
<h4 id="思路-45"><a class="markdownIt-Anchor" href="#思路-45"></a> 思路</h4>
<p>两个思路，一个是采用DP的方式，一个是采用数学定理的方式。</p>
<ol>
<li>DP<br />
定义一个函数f(n)表示我们要求的解。f(n)的求解过程为：<br />
f(n) = 1 + min{<br />
f(n-1^2), f(n-2^2), f(n-3^2), f(n-4^2), … , f(n-k^2) //(k为满足k^2&lt;=n的最大的k)<br />
}</li>
<li>数学定理<br />
四平方定理：任何一个正整数都可以表示成不超过四个整数的平方之和。<br />
推论：满足四数平方和定理的数n（四个整数的情况），必定满足 n=4^a(8b+7)</li>
</ol>
<h4 id="代码-43"><a class="markdownIt-Anchor" href="#代码-43"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DP版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; j++)&#123;</span><br><span class="line">                min = Math.min(min, res[i-j*j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数学定理版</span></span><br><span class="line"><span class="comment">// 由定理可知，结果只有 “1、2、3、4” 四种可能。依次判断下列情况：</span></span><br><span class="line"><span class="comment">// （1）ans = 4 ，判断是否满足推论；（在此过程中，以 4 的倍数缩小 n ，并不影响最后结果）</span></span><br><span class="line"><span class="comment">// （2）ans = 1 ，判断缩小后的 n 是否为平方数；</span></span><br><span class="line"><span class="comment">// （3）ans = 2 ，判断缩小后的 n 是否可以由两个平方数构成；</span></span><br><span class="line"><span class="comment">// （4）ans = 3， 以上都不满足，则结果为 3。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">            n/=<span class="number">4</span>;</span><br><span class="line">         <span class="keyword">if</span>(n%<span class="number">8</span>==<span class="number">7</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i*i&lt;n;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">int</span> j=(<span class="keyword">int</span>)Math.sqrt(n-i*i);</span><br><span class="line">             <span class="keyword">if</span>(j*j+i*i==n)</span><br><span class="line">                 <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-分割整数构成字母字符串"><a class="markdownIt-Anchor" href="#10-分割整数构成字母字符串"></a> 10. 分割整数构成字母字符串</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a></p>
<h4 id="思路-46"><a class="markdownIt-Anchor" href="#思路-46"></a> 思路</h4>
<p>本题与跳台阶本质上相同，如果我们用<code>dp[i]</code>代表当前位可以解码的方式，那么对于第i位有两种选择。</p>
<ol>
<li>第i位单独解码，此时<code>dp[i]=dp[i-1]</code></li>
<li>第i位与第i-1位共同解码，此时<code>dp[i]=dp[i-2]</code></li>
</ol>
<p>综上，所以<code>dp[i]=dp[i-1]+dp[i-2]</code>。<br />
但是要注意，0不能单独解码，所以如果s[i-1]是0，那么dp[i-1]也是0。<br />
如果s[i-2]是0，则不能加上前一位进行解码，即dp[i-2]是0。<br />
同时由于解码数字不会超过26，所以如果最近两位解码结果超过26，那么dp[i-2]也是0。</p>
<h4 id="代码-44"><a class="markdownIt-Anchor" href="#代码-44"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>||(s.length()==<span class="number">1</span>&amp;&amp;s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> onestep=s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;0&#x27;</span>?<span class="number">0</span>:dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> twostep=Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>)==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                twostep=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                twostep=twostep&gt;<span class="number">26</span>?<span class="number">0</span>:dp[i-<span class="number">2</span>];</span><br><span class="line">            dp[i]=onestep+twostep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-最长递增子序列"><a class="markdownIt-Anchor" href="#11-最长递增子序列"></a> 11. 最长递增子序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>
<h4 id="思路-47"><a class="markdownIt-Anchor" href="#思路-47"></a> 思路</h4>
<p>如果我们用<code>dp[i]</code>代表以第i个数字结尾的最长递增序列的长度，则我们从<code>0~i</code>遍历j，对于每一个比<code>nums[i]</code>小的<code>nums[j]</code>,都要比较<code>dp[i]=Max(dp[i],dp[j]+1)</code>。此处注意<code>dp[i]</code>的默认值是1，最后取dp数组最大值即可。</p>
<h4 id="代码-45"><a class="markdownIt-Anchor" href="#代码-45"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                    dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;dp[i])</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-一组整数对能够构成的最长链"><a class="markdownIt-Anchor" href="#12-一组整数对能够构成的最长链"></a> 12. 一组整数对能够构成的最长链</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">https://leetcode-cn.com/problems/maximum-length-of-pair-chain/</a></p>
<h4 id="思路-48"><a class="markdownIt-Anchor" href="#思路-48"></a> 思路</h4>
<p>与上一题基本一样，本题只是需要先将数对按起点排序，然后遍历找到可以与当前数对形成数链的数对，比较dp</p>
<h4 id="代码-46"><a class="markdownIt-Anchor" href="#代码-46"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pairs==<span class="keyword">null</span>||pairs.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(pairs,(a,b)-&gt;(a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[pairs.length];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pairs.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pairs[j][<span class="number">1</span>]&lt;pairs[i][<span class="number">0</span>])</span><br><span class="line">                    dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;dp[i])</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-最长摆动子序列"><a class="markdownIt-Anchor" href="#13-最长摆动子序列"></a> 13. 最长摆动子序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p>
<h4 id="思路-49"><a class="markdownIt-Anchor" href="#思路-49"></a> 思路</h4>
<p>用两个变量up和down分别计算向上摆动和向下摆动的数量，从头遍历数组，如果数组向上了，那么当前的up就是上一位的down+1，如果数组向下了，那么当前的down就是上一位的up+1。</p>
<h4 id="代码-47"><a class="markdownIt-Anchor" href="#代码-47"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-划分数组为和相等的两部分"><a class="markdownIt-Anchor" href="#14-划分数组为和相等的两部分"></a> 14. 划分数组为和相等的两部分</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>
<h4 id="思路-50"><a class="markdownIt-Anchor" href="#思路-50"></a> 思路</h4>
<p>对于背包问题，我们可以用<code>dp[i][j]</code>来表示从<code>0~i</code>中是否存在满足价值为j的组合。<br />
而是否满足主要有两种选择：</p>
<ol>
<li>如果不选择当前<code>nums[i]</code>的价值，则依赖于<code>dp[i-1][j]</code>，两者判断状态相同。</li>
<li>如果选择当前<code>nums[i]</code>的价值，则依赖于<code>dp[i-1][j-nums[i]]</code>,两者判断状态相同。</li>
</ol>
<p>如果有一种情况满足需求，则<code>dp[i][j]</code>可以实现。</p>
<h4 id="代码-48"><a class="markdownIt-Anchor" href="#代码-48"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=nums[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=dp[j]||dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-改变一组数的正负号使得它们的和为一给定数"><a class="markdownIt-Anchor" href="#15-改变一组数的正负号使得它们的和为一给定数"></a> 15. 改变一组数的正负号使得它们的和为一给定数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p>
<h4 id="思路-51"><a class="markdownIt-Anchor" href="#思路-51"></a> 思路</h4>
<p>引用CYC推理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将数组看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</span><br><span class="line">                  sum(P) - sum(N) &#x3D; target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) &#x3D; target + sum(nums)</span><br><span class="line">因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))&#x2F;2，就证明存在解。</span><br></pre></td></tr></table></figure>
<h4 id="代码-49"><a class="markdownIt-Anchor" href="#代码-49"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> W = (sum + S) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = W; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] = dp[i] + dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-01-字符构成最多的字符串"><a class="markdownIt-Anchor" href="#16-01-字符构成最多的字符串"></a> 16. 01 字符构成最多的字符串</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/?search=474">https://leetcode-cn.com/problemset/all/?search=474</a></p>
<h4 id="思路-52"><a class="markdownIt-Anchor" href="#思路-52"></a> 思路</h4>
<p>多维费用问题，我们用<code>dp[i][j]</code>表示使用i个0和j个1能表示的字符串的最大数量。<br />
则<code>dp[i][j]=Max(dp[i][j],dp[i-zero][j-one]+1)</code>,其中zero代表当前0的数量，1代表当前1的数量。</p>
<h4 id="代码-50"><a class="markdownIt-Anchor" href="#代码-50"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[][] dp =<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(String s :strs) &#123;</span><br><span class="line">			<span class="keyword">int</span> zeros  = <span class="number">0</span>,ones = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">					zeros++;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					ones++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;=zeros; i--) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= ones; j--) &#123;</span><br><span class="line">					dp[i][j] = Math.max(dp[i][j], <span class="number">1</span>+dp[i-zeros][j-ones]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-找零钱的最少硬币数"><a class="markdownIt-Anchor" href="#17-找零钱的最少硬币数"></a> 17. 找零钱的最少硬币数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p>
<h4 id="思路-53"><a class="markdownIt-Anchor" href="#思路-53"></a> 思路</h4>
<p>背包大小就是所给的amout，占据背包容量的就是硬币面额。<br />
<code>完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</code><br />
然后取最小数量，对于每个<code>dp[i][j]</code>,最小数量有三种情况：</p>
<ol>
<li>当前硬币就是容量大小，即<code>coins[i]==j</code>，那么使用这枚硬币即可完成任务，必然获得最小值1。</li>
<li>不使用当前硬币时，无法满足要求(即<code>dp[i-1][j]==0</code>)，但是使用当前硬币可以满足要求(即<code>dp[i][j-coins[i]]!=0</code>)，dp[i][j]为<code>dp[i][j-coins[i]]+1</code>。</li>
<li>使用当前硬币可以完成要求，不使用也可以完成要求，则要两者比较取最小值。</li>
</ol>
<h4 id="代码-51"><a class="markdownIt-Anchor" href="#代码-51"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span> || coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i];j&lt;=amount;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==coins[i])</span><br><span class="line">                    dp[j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[j]==<span class="number">0</span>&amp;&amp;dp[j-coins[i]]!=<span class="number">0</span>)</span><br><span class="line">                        dp[j]=dp[j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">0</span>)</span><br><span class="line">                        dp[j]=Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">0</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-找零钱的硬币数组合"><a class="markdownIt-Anchor" href="#18-找零钱的硬币数组合"></a> 18. 找零钱的硬币数组合</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/submissions/">https://leetcode-cn.com/problems/coin-change-2/submissions/</a></p>
<h4 id="思路-54"><a class="markdownIt-Anchor" href="#思路-54"></a> 思路</h4>
<p>与上题类似，只不过本题需要求可能获得的组合总数，对于每一个<code>dp[i][j]</code>，其状态转移方程为<code>dp[i][j]=dp[i-1][j]+dp[i][j-coins[i]]</code>。</p>
<h4 id="代码-52"><a class="markdownIt-Anchor" href="#代码-52"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> coin=coins[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coin;j&lt;=amount;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]+=dp[j-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-字符串按单词列表分割"><a class="markdownIt-Anchor" href="#19-字符串按单词列表分割"></a> 19. 字符串按单词列表分割</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a></p>
<h4 id="思路-55"><a class="markdownIt-Anchor" href="#思路-55"></a> 思路</h4>
<p>字典单词是可以重复使用的，故本题为一个完全背包问题，用字典单词来填充背包，所要对比的价值就是字符串。<br />
对于有序的背包问题，将物品的迭代放在最里层，背包的迭代放在外层。</p>
<h4 id="代码-53"><a class="markdownIt-Anchor" href="#代码-53"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict) &#123;   <span class="comment">// 对物品的迭代应该放在最里层</span></span><br><span class="line">                <span class="keyword">int</span> len = word.length();</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= i &amp;&amp; word.equals(s.substring(i - len, i))) &#123;</span><br><span class="line">                    dp[i] = dp[i] || dp[i - len];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-组合总和"><a class="markdownIt-Anchor" href="#20-组合总和"></a> 20. 组合总和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p>
<h4 id="思路-56"><a class="markdownIt-Anchor" href="#思路-56"></a> 思路</h4>
<p>依然是有序的完全背包问题。</p>
<h4 id="代码-54"><a class="markdownIt-Anchor" href="#代码-54"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length&amp;&amp;i&gt;=nums[j];j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]+=dp[i-nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="背包问题总结"><a class="markdownIt-Anchor" href="#背包问题总结"></a> 背包问题总结</h4>
<p>对于背包问题，主要有两种，即<code>0-1背包</code>or<code>完全背包</code>，这其中又可分为<code>元素有序</code>与<code>元素无序</code>两种。<br />
对于无序问题，则对于元素的遍历在外层，对于背包的遍历在内层。我们以<code>V[]</code>来代表元素数组，<code>target</code>来代表目标价值，则两层循环可以表示为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=V[i];j--)</span><br></pre></td></tr></table></figure>
<p>对于完全背包，则需要将内层循环的顺序反序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V[i];j&lt;=target;j++)</span><br></pre></td></tr></table></figure>
<p>而对于有序问题，需要将两层循环换位，可知循环条件需为<code>V[i]&lt;=j&lt;=target</code>,所以完全背包的双层循环可以表示为：、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;V.length&amp;&amp;j&gt;=V[i];j++)</span><br></pre></td></tr></table></figure>
<h3 id="21-需要冷却期的股票交易"><a class="markdownIt-Anchor" href="#21-需要冷却期的股票交易"></a> 21. 需要冷却期的股票交易</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
<h4 id="思路-57"><a class="markdownIt-Anchor" href="#思路-57"></a> 思路</h4>
<p>sell[i]表示截至第i天，最后一个操作是卖时的最大收益；<br />
buy[i]表示截至第i天，最后一个操作是买时的最大收益；<br />
cool[i]表示截至第i天，最后一个操作是冷冻期时的最大收益；<br />
递推公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sell[i] &#x3D; max(buy[i-1]+prices[i], sell[i-1]) (第一项表示第i天卖出，第二项表示第i天冷冻)  </span><br><span class="line">buy[i] &#x3D; max(cool[i-1]-prices[i], buy[i-1])  (第一项表示第i天买进，第二项表示第i天冷冻)  </span><br><span class="line">cool[i] &#x3D; max(sell[i-1], cool[i-1])          (第一项表示第i天卖出，从而变为冷冻期，第二项表示第i天冷冻)  </span><br></pre></td></tr></table></figure>
<p>此外还要注意数组长度只有1个的时候是不买的，利润为0。其他情况buy[0]一定是prices[0]的相反数。</p>
<h4 id="代码-55"><a class="markdownIt-Anchor" href="#代码-55"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sell=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] buy=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] cool=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sell[i]=Math.max(buy[i-<span class="number">1</span>]+prices[i],sell[i-<span class="number">1</span>]);</span><br><span class="line">            buy[i]=Math.max(cool[i-<span class="number">1</span>]-prices[i],buy[i-<span class="number">1</span>]);</span><br><span class="line">            cool[i]=Math.max(sell[i-<span class="number">1</span>], cool[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-需要交易费用的股票交易"><a class="markdownIt-Anchor" href="#22-需要交易费用的股票交易"></a> 22. 需要交易费用的股票交易</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p>
<h4 id="思路-58"><a class="markdownIt-Anchor" href="#思路-58"></a> 思路</h4>
<p>和上题差不多，只是本次在每次卖出时需要加手续费，以及没有冷却期</p>
<h4 id="代码-56"><a class="markdownIt-Anchor" href="#代码-56"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sell=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] buy=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sell[i]=Math.max(buy[i-<span class="number">1</span>]+prices[i]-fee,sell[i-<span class="number">1</span>]);</span><br><span class="line">            buy[i]=Math.max(sell[i-<span class="number">1</span>]-prices[i],buy[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-只能进行两次的股票交易"><a class="markdownIt-Anchor" href="#23-只能进行两次的股票交易"></a> 23. 只能进行两次的股票交易</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p>
<h4 id="思路-59"><a class="markdownIt-Anchor" href="#思路-59"></a> 思路</h4>
<p>对于任意一天考虑四个变量:<br />
fstBuy: 在该天第一次买入股票可获得的最大收益<br />
fstSell: 在该天第一次卖出股票可获得的最大收益<br />
secBuy: 在该天第二次买入股票可获得的最大收益<br />
secSell: 在该天第二次卖出股票可获得的最大收益<br />
分别对四个变量进行相应的更新, 最后secSell就是最大</p>
<h4 id="代码-57"><a class="markdownIt-Anchor" href="#代码-57"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fstBuy = Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> secBuy = Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=prices[i];</span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-只能进行-k-次的股票交易"><a class="markdownIt-Anchor" href="#24-只能进行-k-次的股票交易"></a> 24. 只能进行 k 次的股票交易</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<h4 id="思路-60"><a class="markdownIt-Anchor" href="#思路-60"></a> 思路</h4>
<p>对上一题进行推广，对每一个买卖次数进行遍历即可。<br />
但是由于K不固定，直接DP会MLE，所以对于K大于数组长度一半的情况下，即每天都可以考虑买入卖出的情况下，用贪心即可，既节省空间，又节省时间。</p>
<h4 id="代码-58"><a class="markdownIt-Anchor" href="#代码-58"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>) <span class="keyword">return</span> greedy(prices);</span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            t[i][<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=prices[i];</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">0</span>] = Math.max(t[<span class="number">0</span>][<span class="number">0</span>], -p);</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">1</span>] = Math.max(t[<span class="number">0</span>][<span class="number">1</span>], t[<span class="number">0</span>][<span class="number">0</span>] + p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                t[j][<span class="number">0</span>]=Math.max(t[j][<span class="number">0</span>],t[j-<span class="number">1</span>][<span class="number">1</span>]-p);</span><br><span class="line">                t[j][<span class="number">1</span>]=Math.max(t[j][<span class="number">1</span>],t[j][<span class="number">0</span>]+p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-删除两个字符串的字符使它们相等"><a class="markdownIt-Anchor" href="#25-删除两个字符串的字符使它们相等"></a> 25. 删除两个字符串的字符使它们相等</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">https://leetcode-cn.com/problems/delete-operation-for-two-strings/</a></p>
<h4 id="思路-61"><a class="markdownIt-Anchor" href="#思路-61"></a> 思路</h4>
<p>实际上还是求最长公共子序列，然后用两个字符串长度和减去就是最少删除步数。</p>
<h4 id="代码-59"><a class="markdownIt-Anchor" href="#代码-59"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m + n - <span class="number">2</span> * dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-编辑距离"><a class="markdownIt-Anchor" href="#26-编辑距离"></a> 26. 编辑距离</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p>
<h4 id="思路-62"><a class="markdownIt-Anchor" href="#思路-62"></a> 思路</h4>
<p>如果我们用<code>dp[i][j]</code>代表从<code>word1[0~i]</code>到<code>word2[0~j</code>所需的步数。那么如果要到达<code>dp[i][j]</code>的状态，一共可由三种状态转移而来:</p>
<ol>
<li><code>从dp[i-1][j-1]</code>转移而来，如果<code>从dp[i-1][j-1]=k</code>，那么如果<code>word1[i]=word2[j]</code>，那么仍然只需k步，否则需要替换一个字符，K+1步。</li>
<li><code>从dp[i][j-1]</code>转移而来，如果<code>从dp[i][j-1]=k</code>，那么我们需要插入一个<code>word2[j]</code>即可达到要求,故需要K+1步。</li>
<li><code>从dp[i-1][j]</code>转移而来，如果<code>从dp[i-1][j-1]=k</code>，那么我们需要删掉一个<code>word1[i]</code>即可达到要求，故需要K+1步。</li>
</ol>
<p>最后需要注意，将dp数组初始化时上边界和左边界都置为i，因为对于任意一个字符串为空的情况下，将另一个字符串转换过来或转换为另一个字符串，都需要进行字符串长度步数的操作。</p>
<h4 id="代码-60"><a class="markdownIt-Anchor" href="#代码-60"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-复制粘贴字符"><a class="markdownIt-Anchor" href="#27-复制粘贴字符"></a> 27. 复制粘贴字符</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/2-keys-keyboard/">https://leetcode-cn.com/problems/2-keys-keyboard/</a></p>
<h4 id="思路-63"><a class="markdownIt-Anchor" href="#思路-63"></a> 思路</h4>
<p>对于任意一个数，可以按照是否为质数来区分。</p>
<ol>
<li>如果他是质数，那就不能通过复制得到，只能每次粘贴1来打到，所以需要n步。</li>
<li>如果不是质数，就可以表示为两个数的乘积A*B，即构建长度为A的序列，然后复制B次(或者相反)，所以步数为A+B。</li>
<li>向下分解，如果AB中有不是质数的，例如B，依然可以表示为m*n，向下一直分解至质数。</li>
</ol>
<p>故实际上就是将n分解为m个质数的乘积，且这m个质数的和最小。</p>
<p>如果用DP的方式，那么对于<code>dp[i]</code>，可以转移过来的状态只有当其可以分为A*B时，其<code>dp[i]=dp[A]+dp[B]</code>。<br />
如果用递归的方式，需要从小到大找因数分解。</p>
<h4 id="代码-61"><a class="markdownIt-Anchor" href="#代码-61"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DP版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> h = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= h; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = dp[j] + dp[i / j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> i + minSteps(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八-数学"><a class="markdownIt-Anchor" href="#八-数学"></a> 八、数学</h2>
<h3 id="1-生成素数序列"><a class="markdownIt-Anchor" href="#1-生成素数序列"></a> 1. 生成素数序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/">https://leetcode-cn.com/problems/count-primes/</a></p>
<h4 id="思路-64"><a class="markdownIt-Anchor" href="#思路-64"></a> 思路</h4>
<p>埃拉托斯特尼筛法(sieve of Eratosthenes)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</span><br></pre></td></tr></table></figure>
<h4 id="代码-62"><a class="markdownIt-Anchor" href="#代码-62"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">boolean</span>[] notPrimes = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notPrimes[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = (<span class="keyword">long</span>) (i) * i; j &lt; n; j += i) &#123;</span><br><span class="line">                notPrimes[(<span class="keyword">int</span>) j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7进制"><a class="markdownIt-Anchor" href="#2-7进制"></a> 2. 7进制</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/base-7/">https://leetcode-cn.com/problems/base-7/</a></p>
<h4 id="思路-65"><a class="markdownIt-Anchor" href="#思路-65"></a> 思路</h4>
<p>与二进制一样，只需%7然后进位即可。</p>
<h4 id="代码-63"><a class="markdownIt-Anchor" href="#代码-63"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = num &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">            num = -num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(num % <span class="number">7</span>);</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ret = sb.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="string">&quot;-&quot;</span> + ret : ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(num, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-16-进制"><a class="markdownIt-Anchor" href="#3-16-进制"></a> 3. 16 进制</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/</a></p>
<h4 id="思路-66"><a class="markdownIt-Anchor" href="#思路-66"></a> 思路</h4>
<p>使用0x0b1111获取num的低4位。<br />
算数位移，其中正数右移左边补0，负数右移左边补1。<br />
位移运算并不能保证num==0，需要使用32位int保证（对应16进制小于等于8位）。</p>
<h4 id="代码-64"><a class="markdownIt-Anchor" href="#代码-64"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] map = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(map[num &amp; <span class="number">0b1111</span>]);</span><br><span class="line">            num &gt;&gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-26-进制"><a class="markdownIt-Anchor" href="#4-26-进制"></a> 4. 26 进制</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title/">https://leetcode-cn.com/problems/excel-sheet-column-title/</a></p>
<h4 id="思路-67"><a class="markdownIt-Anchor" href="#思路-67"></a> 思路</h4>
<p>类似7进制，但是数据是从1开始，要先减1。</p>
<h4 id="代码-65"><a class="markdownIt-Anchor" href="#代码-65"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) (n % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            n =n / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-统计阶乘尾部有多少个-0"><a class="markdownIt-Anchor" href="#5-统计阶乘尾部有多少个-0"></a> 5. 统计阶乘尾部有多少个 0</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">https://leetcode-cn.com/problems/factorial-trailing-zeroes/</a></p>
<h4 id="思路-68"><a class="markdownIt-Anchor" href="#思路-68"></a> 思路</h4>
<p>有一个10尾部就有一个0，而10必然可以分解为2*5，2的数量明显多于5的数量，因此只要统计有多少个5即可。</p>
<h4 id="代码-66"><a class="markdownIt-Anchor" href="#代码-66"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-二进制加法"><a class="markdownIt-Anchor" href="#6-二进制加法"></a> 6. 二进制加法</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/">https://leetcode-cn.com/problems/add-binary/</a></p>
<h4 id="思路-69"><a class="markdownIt-Anchor" href="#思路-69"></a> 思路</h4>
<p>从后向前遍历，用一个变量代表当前位的值，分别加两个字符串的该位置，然后%2就是当前位加完之后的数，/2就是需要进位的的数。</p>
<h4 id="代码-67"><a class="markdownIt-Anchor" href="#代码-67"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; a.charAt(i--) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                carry++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; b.charAt(j--) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                carry++;</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(carry % <span class="number">2</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-字符串加法"><a class="markdownIt-Anchor" href="#7-字符串加法"></a> 7. 字符串加法</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-strings/">https://leetcode-cn.com/problems/add-strings/</a></p>
<h4 id="思路-70"><a class="markdownIt-Anchor" href="#思路-70"></a> 思路</h4>
<p>通上题，把2进位改成10进位即可。</p>
<h4 id="代码-68"><a class="markdownIt-Anchor" href="#代码-68"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            str.append((x + y + carry) % <span class="number">10</span>);</span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-改变数组元素使所有的数组元素都相等"><a class="markdownIt-Anchor" href="#8-改变数组元素使所有的数组元素都相等"></a> 8. 改变数组元素使所有的数组元素都相等</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/">https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/</a></p>
<h4 id="思路-71"><a class="markdownIt-Anchor" href="#思路-71"></a> 思路</h4>
<p>在我们将数组排序之后，移动距离最小的方式是所有元素都移动到中位数。</p>
<h4 id="代码-69"><a class="markdownIt-Anchor" href="#代码-69"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=nums[j--]-nums[i++];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-数组中出现次数多于-n-2-的元素"><a class="markdownIt-Anchor" href="#9-数组中出现次数多于-n-2-的元素"></a> 9. 数组中出现次数多于 n / 2 的元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p>
<h4 id="思路-72"><a class="markdownIt-Anchor" href="#思路-72"></a> 思路</h4>
<p>有两种解决方式，一种是简单的，将数组排序，排序之后的中位数一定是超过半数的元素。<br />
另一种是利用数学思想，这里用到了摩尔投票算法(Moore majority vote algorithm)。<br />
摩尔投票算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">摩尔投票法的基本思想很简单，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。</span><br></pre></td></tr></table></figure>
<p>在这道题中，我们从数组头部开始遍历，用一个数来做计数器。<br />
取一个标记数，从下一个数开始遍历，如果相同，让计数器+1，来统计一下先前有多少个一样的标记数。<br />
如果不同，让计数器-1，代表我们从数组中删除了一对这样的数。<br />
如果计数器到0了，说明先前遍历的部分已经让我们删光了，我们要取一个新的标记数。<br />
最后剩下的标记数，一定是所需的目标元素。</p>
<blockquote>
<p>而且用摩尔投票法可以解决一般性的频率最高数的问题，而无需一定要大于n/2。</p>
</blockquote>
<h4 id="代码-70"><a class="markdownIt-Anchor" href="#代码-70"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=nums[<span class="number">0</span>],count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==nums[i])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=nums[i];</span><br><span class="line">                    count=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-平方数"><a class="markdownIt-Anchor" href="#10-平方数"></a> 10. 平方数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-perfect-square/">https://leetcode-cn.com/problems/valid-perfect-square/</a></p>
<h4 id="思路-73"><a class="markdownIt-Anchor" href="#思路-73"></a> 思路</h4>
<p>数学定理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完全平方数是一系列奇数之和</span><br><span class="line">1 &#x3D; 1</span><br><span class="line">4 &#x3D; 1 + 3</span><br><span class="line">9 &#x3D; 1 + 3 + 5</span><br><span class="line">16 &#x3D; 1 + 3 + 5 + 7</span><br><span class="line">25 &#x3D; 1 + 3 + 5 + 7 + 9</span><br><span class="line">36 &#x3D; 1 + 3 + 5 + 7 + 9 + 11</span><br><span class="line">....</span><br><span class="line">1+3+...+(2n-1) &#x3D; (2n-1 + 1)n&#x2F;2 &#x3D; n*n</span><br></pre></td></tr></table></figure>
<h4 id="代码-71"><a class="markdownIt-Anchor" href="#代码-71"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;num&gt;=<span class="number">0</span>;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num-=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-3-的-n-次方"><a class="markdownIt-Anchor" href="#11-3-的-n-次方"></a> 11. 3 的 n 次方</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-three/">https://leetcode-cn.com/problems/power-of-three/</a></p>
<h4 id="思路-74"><a class="markdownIt-Anchor" href="#思路-74"></a> 思路</h4>
<p>通用方法是不断地/3,看会不会到1。<br />
数学思想的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3的幂次的质因子只有3，题目整数范围内的3的最大幂次是1162261467。</span><br><span class="line">如果N是3的幂次，那么N一定是1162261467的因子，如果不是，那么也就不是因子。</span><br></pre></td></tr></table></figure>
<h4 id="代码-72"><a class="markdownIt-Anchor" href="#代码-72"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n/<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            n/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数学思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-乘积数组"><a class="markdownIt-Anchor" href="#12-乘积数组"></a> 12. 乘积数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">https://leetcode-cn.com/problems/product-of-array-except-self/</a></p>
<h4 id="思路-75"><a class="markdownIt-Anchor" href="#思路-75"></a> 思路</h4>
<p>因为不能用除法，所以不能求总乘积再除。</p>
<p>故选用一个数组，从左向右遍历一次，output[i]保存output[i]左侧所有数的乘积。<br />
从右向左遍历一次，output[i]再乘上右侧所有数的乘积。</p>
<p>两次遍历之后，output就存下了所需的内容。</p>
<h4 id="代码-73"><a class="markdownIt-Anchor" href="#代码-73"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] output=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i]=left;</span><br><span class="line">            left*=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i]*=right;</span><br><span class="line">            right*=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-找出数组中的乘积最大的三个数"><a class="markdownIt-Anchor" href="#13-找出数组中的乘积最大的三个数"></a> 13. 找出数组中的乘积最大的三个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">https://leetcode-cn.com/problems/maximum-product-of-three-numbers/</a></p>
<h4 id="思路-76"><a class="markdownIt-Anchor" href="#思路-76"></a> 思路</h4>
<p>先排序，然后最大值只会有两种情况：</p>
<ol>
<li>最大的三个正数乘积。</li>
<li>最大的一个正数和最小的两个负数乘积。</li>
</ol>
<h4 id="代码-74"><a class="markdownIt-Anchor" href="#代码-74"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[n-<span class="number">1</span>]*nums[n-<span class="number">2</span>]*nums[n-<span class="number">3</span>],nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第二部分-数据结构相关"><a class="markdownIt-Anchor" href="#第二部分-数据结构相关"></a> 第二部分 数据结构相关</h1>
<h2 id="一-链表"><a class="markdownIt-Anchor" href="#一-链表"></a> 一、链表</h2>
<h3 id="1-找出两个链表的交点"><a class="markdownIt-Anchor" href="#1-找出两个链表的交点"></a> 1. 找出两个链表的交点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
<h4 id="思路-77"><a class="markdownIt-Anchor" href="#思路-77"></a> 思路</h4>
<p>两个单链表一定有共同的尾部，所以差异只是在前面，只要找到前面差的长度，然后补全差异之后同时向后走就可以找到交点。</p>
<p>CYC用A的链表接上B，B的链表接上A，这样就不用手动寻找长度差异了。</p>
<h4 id="代码-75"><a class="markdownIt-Anchor" href="#代码-75"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Alength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Blength=<span class="number">0</span>;</span><br><span class="line">        ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">        temp=headA;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Alength++;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=headB;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Blength++;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff=Alength-Blength;</span><br><span class="line">        <span class="keyword">while</span>(diff&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            headA=headA.next;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(diff&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">            diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headA!=headB)</span><br><span class="line">        &#123;</span><br><span class="line">            headA=headA.next;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CYC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = headA, l2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-链表反转"><a class="markdownIt-Anchor" href="#2-链表反转"></a> 2. 链表反转</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<h4 id="思路-78"><a class="markdownIt-Anchor" href="#思路-78"></a> 思路</h4>
<p>头部插入</p>
<h4 id="代码-76"><a class="markdownIt-Anchor" href="#代码-76"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tail=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode temp=head;</span><br><span class="line">            head=head.next;</span><br><span class="line">            temp.next=tail;</span><br><span class="line">            tail=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-归并两个有序的链表"><a class="markdownIt-Anchor" href="#3-归并两个有序的链表"></a> 3. 归并两个有序的链表</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<h4 id="思路-79"><a class="markdownIt-Anchor" href="#思路-79"></a> 思路</h4>
<p>类似归并</p>
<h4 id="代码-77"><a class="markdownIt-Anchor" href="#代码-77"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode newlink=head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink.next=l2;</span><br><span class="line">                <span class="keyword">return</span> head.next; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    newlink.next=l1;</span><br><span class="line">                    <span class="keyword">return</span> head.next;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l1.val&gt;l2.val)</span><br><span class="line">                &#123;</span><br><span class="line">                    newlink.next=l2;</span><br><span class="line">                    newlink=newlink.next;</span><br><span class="line">                    l2=l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    newlink.next=l1;</span><br><span class="line">                    newlink=newlink.next;</span><br><span class="line">                    l1=l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-从有序链表中删除重复节点"><a class="markdownIt-Anchor" href="#4-从有序链表中删除重复节点"></a> 4. 从有序链表中删除重复节点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p>
<h4 id="思路-80"><a class="markdownIt-Anchor" href="#思路-80"></a> 思路</h4>
<p>一次遍历</p>
<h4 id="代码-78"><a class="markdownIt-Anchor" href="#代码-78"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode res=head;</span><br><span class="line">        <span class="keyword">while</span>(res!=<span class="keyword">null</span>&amp;&amp;res.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.val==res.next.val)</span><br><span class="line">                res.next=res.next.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res=res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-删除链表的倒数第-n-个节点"><a class="markdownIt-Anchor" href="#5-删除链表的倒数第-n-个节点"></a> 5. 删除链表的倒数第 n 个节点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<h4 id="思路-81"><a class="markdownIt-Anchor" href="#思路-81"></a> 思路</h4>
<p>为了不进行两次遍历，可以用快慢指针，让快指针先走N步，在快指针到结尾时慢指针即是要删除的节点。<br />
如果快指针走到了尾部，说明要删除的是头结点，直接返回head.next即可。</p>
<h4 id="代码-79"><a class="markdownIt-Anchor" href="#代码-79"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next=slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-交换链表中的相邻结点"><a class="markdownIt-Anchor" href="#6-交换链表中的相邻结点"></a> 6. 交换链表中的相邻结点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p>
<h4 id="思路-82"><a class="markdownIt-Anchor" href="#思路-82"></a> 思路</h4>
<p>两两交换，交换之后跳过一个。<br />
为了交换需要之前前一个节点的指针，故建立一个先导节点。</p>
<h4 id="代码-80"><a class="markdownIt-Anchor" href="#代码-80"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode beforehead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        beforehead.next=head;</span><br><span class="line">        ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        ListNode p=beforehead;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span>&amp;&amp;p.next.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">                p=p.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                temp=p.next.next;</span><br><span class="line">                p.next.next=p.next.next.next;</span><br><span class="line">                temp.next=p.next;</span><br><span class="line">                p.next=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beforehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-链表求和"><a class="markdownIt-Anchor" href="#7-链表求和"></a> 7. 链表求和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p>
<h4 id="思路-83"><a class="markdownIt-Anchor" href="#思路-83"></a> 思路</h4>
<p>用栈来反转链表，然后倒序计算构建新链表。</p>
<h4 id="代码-81"><a class="markdownIt-Anchor" href="#代码-81"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; l1Stack = buildStack(l1);</span><br><span class="line">        Stack&lt;Integer&gt; l2Stack = buildStack(l2);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!l1Stack.isEmpty() || !l2Stack.isEmpty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1Stack.isEmpty() ? <span class="number">0</span> : l1Stack.pop();</span><br><span class="line">            <span class="keyword">int</span> y = l2Stack.isEmpty() ? <span class="number">0</span> : l2Stack.pop();</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode l)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(l.val);</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-回文链表"><a class="markdownIt-Anchor" href="#8-回文链表"></a> 8. 回文链表</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>
<h4 id="思路-84"><a class="markdownIt-Anchor" href="#思路-84"></a> 思路</h4>
<p>快慢指针，2倍速前进，获得中点，截断反转，同步判断。</p>
<h4 id="代码-82"><a class="markdownIt-Anchor" href="#代码-82"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>&amp;&amp;fast.next.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow=reverse(slow.next);</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val!=slow.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head=head.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextNode = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-分隔链表"><a class="markdownIt-Anchor" href="#9-分隔链表"></a> 9. 分隔链表</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">https://leetcode-cn.com/problems/split-linked-list-in-parts/</a></p>
<h3 id="思路-85"><a class="markdownIt-Anchor" href="#思路-85"></a> 思路</h3>
<p>先遍历求一次链表长度N，然后因为要分隔K段，所以每段长度为N/k,多余的节点数为N%K,把这个N%K个节点给前N%K段每段的长度+1即可。</p>
<h3 id="代码-83"><a class="markdownIt-Anchor" href="#代码-83"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            N++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mod = N % k;</span><br><span class="line">        <span class="keyword">int</span> size = N / k;</span><br><span class="line">        ListNode[] ret = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur != <span class="keyword">null</span> &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            ret[i] = cur;</span><br><span class="line">            <span class="keyword">int</span> curSize = size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curSize - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-链表元素按奇偶聚集"><a class="markdownIt-Anchor" href="#10-链表元素按奇偶聚集"></a> 10. 链表元素按奇偶聚集</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">https://leetcode-cn.com/problems/odd-even-linked-list/</a></p>
<h4 id="思路-86"><a class="markdownIt-Anchor" href="#思路-86"></a> 思路</h4>
<p>奇数节点的next是偶数节点指针的next，偶数节点的next是奇数节点指针的next。</p>
<h4 id="代码-84"><a class="markdownIt-Anchor" href="#代码-84"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>||head.next.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode singlehead=head;</span><br><span class="line">        ListNode midhead=head.next;</span><br><span class="line">        ListNode doublehead=head.next;</span><br><span class="line">        <span class="keyword">while</span> (singlehead.next != <span class="keyword">null</span> &amp;&amp; doublehead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            singlehead.next = doublehead.next;</span><br><span class="line">            singlehead =singlehead.next;</span><br><span class="line">            doublehead.next = singlehead.next;</span><br><span class="line">            doublehead = doublehead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        singlehead.next=midhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-树"><a class="markdownIt-Anchor" href="#二-树"></a> 二、树</h2>
<h3 id="1-树的高度"><a class="markdownIt-Anchor" href="#1-树的高度"></a> 1. 树的高度</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/</a></p>
<h4 id="思路-87"><a class="markdownIt-Anchor" href="#思路-87"></a> 思路</h4>
<p>递归求解</p>
<h4 id="代码-85"><a class="markdownIt-Anchor" href="#代码-85"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-平衡树"><a class="markdownIt-Anchor" href="#2-平衡树"></a> 2. 平衡树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
<h4 id="思路-88"><a class="markdownIt-Anchor" href="#思路-88"></a> 思路</h4>
<p>递归查找左右子树高度，比较判断高度差。</p>
<h4 id="代码-86"><a class="markdownIt-Anchor" href="#代码-86"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> balance=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxdepth(root);</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxdepth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=maxdepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxdepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>((left-right)&gt;<span class="number">1</span>||(left-right)&lt;-<span class="number">1</span>)</span><br><span class="line">            balance=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-两节点的最长路径"><a class="markdownIt-Anchor" href="#3-两节点的最长路径"></a> 3. 两节点的最长路径</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<h4 id="思路-89"><a class="markdownIt-Anchor" href="#思路-89"></a> 思路</h4>
<p>最长长度一定是某个节点的左右子树长度之和，故只需查找左右子树高度，然后相加找最大值。</p>
<h4 id="代码-87"><a class="markdownIt-Anchor" href="#代码-87"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxdepth(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxdepth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=maxdepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxdepth(root.right);</span><br><span class="line">        max=Math.max(max,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-翻转树"><a class="markdownIt-Anchor" href="#4-翻转树"></a> 4. 翻转树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<h4 id="思路-90"><a class="markdownIt-Anchor" href="#思路-90"></a> 思路</h4>
<p>交换左右子树即可。</p>
<h4 id="代码-88"><a class="markdownIt-Anchor" href="#代码-88"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 后面的操作会改变 left 指针，因此先保存下来</span></span><br><span class="line">        TreeNode left = root.left;  </span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-归并两棵树"><a class="markdownIt-Anchor" href="#5-归并两棵树"></a> 5. 归并两棵树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">https://leetcode-cn.com/problems/merge-two-binary-trees/</a></p>
<h4 id="思路-91"><a class="markdownIt-Anchor" href="#思路-91"></a> 思路</h4>
<p>递归同时遍历两棵树，相同位置节点值相加,如果有一边已经为空，则直接返回节点。</p>
<h4 id="代码-89"><a class="markdownIt-Anchor" href="#代码-89"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val=t1.val+t2.val;</span><br><span class="line">        t1.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-判断路径和是否等于一个数"><a class="markdownIt-Anchor" href="#6-判断路径和是否等于一个数"></a> 6. 判断路径和是否等于一个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></p>
<h4 id="思路-92"><a class="markdownIt-Anchor" href="#思路-92"></a> 思路</h4>
<p>左右递归遍历，有一路为真即可，遍历时每层剪掉当前值，看是否为0。</p>
<h4 id="代码-90"><a class="markdownIt-Anchor" href="#代码-90"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-统计路径和等于一个数的路径数量"><a class="markdownIt-Anchor" href="#7-统计路径和等于一个数的路径数量"></a> 7. 统计路径和等于一个数的路径数量</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">https://leetcode-cn.com/problems/path-sum-iii/</a></p>
<h4 id="思路-93"><a class="markdownIt-Anchor" href="#思路-93"></a> 思路</h4>
<p>双重递归，一方面递归所有节点，另一方面递归从当前节点出发，是否有路径满足需求。</p>
<h4 id="代码-91"><a class="markdownIt-Anchor" href="#代码-91"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> find(root,sum)+pathSum(root.left,sum)+pathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum-=root.val;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        count+=find(root.left,sum)+find(root.right,sum);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-子树"><a class="markdownIt-Anchor" href="#8-子树"></a> 8. 子树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">https://leetcode-cn.com/problems/subtree-of-another-tree/</a></p>
<h4 id="思路-94"><a class="markdownIt-Anchor" href="#思路-94"></a> 思路</h4>
<p>双重递归，一次递归所有节点，另一次递归所有从当前节点出发的子树是否和t一样。</p>
<h4 id="代码-92"><a class="markdownIt-Anchor" href="#代码-92"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> issame=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>&amp;&amp;t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>&amp;&amp;t!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="keyword">null</span>&amp;&amp;t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(s,t)||isSubtree(s.left,t)||isSubtree(s.right,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode s,TreeNode t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>&amp;&amp;t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val!=t.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(s.left,t.left)&amp;&amp;compare(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-树的对称"><a class="markdownIt-Anchor" href="#9-树的对称"></a> 9. 树的对称</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
<h4 id="思路-95"><a class="markdownIt-Anchor" href="#思路-95"></a> 思路</h4>
<p>左右子树对称判断是否相等</p>
<h4 id="代码-93"><a class="markdownIt-Anchor" href="#代码-93"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> issame(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issame</span><span class="params">(TreeNode left,TreeNode right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> issame(left.left,right.right)&amp;&amp;issame(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-最小路径"><a class="markdownIt-Anchor" href="#10-最小路径"></a> 10. 最小路径</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p>
<h4 id="思路-96"><a class="markdownIt-Anchor" href="#思路-96"></a> 思路</h4>
<p>向两侧遍历左子树和右子树的深度，取最小值。<br />
当遍历到有子节点为空时，两侧皆空为叶子结点，返回0，一侧为空则不符合要求，还需遍历另一侧。</p>
<h4 id="代码-94"><a class="markdownIt-Anchor" href="#代码-94"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-统计左叶子节点的和"><a class="markdownIt-Anchor" href="#11-统计左叶子节点的和"></a> 11. 统计左叶子节点的和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">https://leetcode-cn.com/problems/sum-of-left-leaves/</a></p>
<h4 id="思路-97"><a class="markdownIt-Anchor" href="#思路-97"></a> 思路</h4>
<p>用一个辅助函数判断当前节点是否为叶子节点，然后遍历这棵树，对每个节点的左子节点进行一次判断，如果是叶子节点就进行累加。</p>
<h4 id="代码-95"><a class="markdownIt-Anchor" href="#代码-95"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLeaf(root.left)) </span><br><span class="line">            <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-相同节点值的最大路径长度"><a class="markdownIt-Anchor" href="#12-相同节点值的最大路径长度"></a> 12. 相同节点值的最大路径长度</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-univalue-path/comments/">https://leetcode-cn.com/problems/longest-univalue-path/comments/</a></p>
<h4 id="思路-98"><a class="markdownIt-Anchor" href="#思路-98"></a> 思路</h4>
<p>对于每个节点，分别遍历左子树与当前节点值相等的长度，右子树与当前节点值相等的长度，然后累和取得当前同值路径长度，再取最大值。</p>
<h4 id="代码-96"><a class="markdownIt-Anchor" href="#代码-96"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        findmax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findmax</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftlength=findmax(root.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightlength=findmax(root.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>||root.left.val!=root.val)</span><br><span class="line">            leftlength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="keyword">null</span>||root.right.val!=root.val)</span><br><span class="line">            rightlength=<span class="number">0</span>;</span><br><span class="line">        res=Math.max(res,leftlength+rightlength);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftlength,rightlength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-间隔遍历"><a class="markdownIt-Anchor" href="#13-间隔遍历"></a> 13. 间隔遍历</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">https://leetcode-cn.com/problems/house-robber-iii/</a></p>
<h4 id="思路-99"><a class="markdownIt-Anchor" href="#思路-99"></a> 思路</h4>
<p>对于当前节点，一共有两种打劫的选择：</p>
<ol>
<li>打劫当前节点，则收益为当前节点+当前节点的左子节点的左右子节点+当前节点的右节点的左右子节点。</li>
<li>不打劫当前节点，则收益为当前节点的左子节点收益+右子节点收益。</li>
</ol>
<h4 id="代码-97"><a class="markdownIt-Anchor" href="#代码-97"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> option1=root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            option1+=rob(root.left.left)+rob(root.left.right);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            option1+=rob(root.right.left)+rob(root.right.right);</span><br><span class="line">        <span class="keyword">int</span> option2=rob(root.left)+rob(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(option1,option2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-找出二叉树中第二小的节点"><a class="markdownIt-Anchor" href="#14-找出二叉树中第二小的节点"></a> 14. 找出二叉树中第二小的节点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/</a></p>
<h4 id="思路-100"><a class="markdownIt-Anchor" href="#思路-100"></a> 思路</h4>
<p>因为二叉树的中任何一个节点的值一定不大于其子节点，所以我们从根节点开始左右遍历，分别找到第一个不相同的值，然后比较两侧大小即可。</p>
<h4 id="代码-98"><a class="markdownIt-Anchor" href="#代码-98"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min=-<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left.val!=root.val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min==-<span class="number">1</span>)</span><br><span class="line">                    min=root.left.val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    min=Math.min(min,root.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                findSecondMinimumValue(root.left);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right.val!=root.val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min==-<span class="number">1</span>)</span><br><span class="line">                    min=root.right.val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    min=Math.min(min,root.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                findSecondMinimumValue(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-一棵树每层节点的平均数"><a class="markdownIt-Anchor" href="#15-一棵树每层节点的平均数"></a> 15. 一棵树每层节点的平均数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>
<h4 id="思路-101"><a class="markdownIt-Anchor" href="#思路-101"></a> 思路</h4>
<p>用Double的List存每层的平均值，用Int的List存每层的节点个数，然后遍历计算。</p>
<h4 id="代码-99"><a class="markdownIt-Anchor" href="#代码-99"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; res=<span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    List&lt;Integer&gt; count=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        cal(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(TreeNode root,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;=depth)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add((<span class="keyword">double</span>)root.val);</span><br><span class="line">            count.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curcount=count.get(depth);</span><br><span class="line">            <span class="keyword">double</span> curvalue=res.get(depth);</span><br><span class="line">            res.set(depth,(curvalue*curcount+root.val)/(curcount+<span class="number">1</span>));</span><br><span class="line">            count.set(depth,curcount+<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        cal(root.left,depth+<span class="number">1</span>);</span><br><span class="line">        cal(root.right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-得到左下角的节点"><a class="markdownIt-Anchor" href="#16-得到左下角的节点"></a> 16. 得到左下角的节点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>
<h4 id="思路-102"><a class="markdownIt-Anchor" href="#思路-102"></a> 思路</h4>
<p>用辅助List，存先序遍历每个深度的第一个节点即可。</p>
<h4 id="代码-100"><a class="markdownIt-Anchor" href="#代码-100"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        assist(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.get(res.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assist</span><span class="params">(TreeNode root,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;=depth)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        assist(root.left,depth+<span class="number">1</span>);</span><br><span class="line">        assist(root.right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-非递归实现二叉树的三种遍历"><a class="markdownIt-Anchor" href="#17-非递归实现二叉树的三种遍历"></a> 17. 非递归实现二叉树的三种遍历</h3>
<p>前序遍历：<br />
<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p>
<p>后序遍历：<br />
<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>
<p>中序遍历：<br />
<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>
<h4 id="思路-103"><a class="markdownIt-Anchor" href="#思路-103"></a> 思路</h4>
<p>用迭代就需要用辅助栈控制遍历顺序。<br />
前序遍历是<code>root-&gt;left-&gt;right</code>。<br />
后序遍历是<code>left-&gt;right-&gt;root</code>,其倒序是<code>root-&gt;right-&gt;left</code>。可以反向构造。<br />
中序遍历是<code>left-&gt;root-&gt;right</code>,需要先把左子树全入栈。</p>
<h4 id="代码-101"><a class="markdownIt-Anchor" href="#代码-101"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.addFirst(node.val);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-修剪二叉查找树"><a class="markdownIt-Anchor" href="#18-修剪二叉查找树"></a> 18. 修剪二叉查找树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/">https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/</a></p>
<h4 id="思路-104"><a class="markdownIt-Anchor" href="#思路-104"></a> 思路</h4>
<p>如果当前节点符合区间，左右向下递归。<br />
如果当前节点小于区间，用当前节点右子树代替当前节点，然后递归。<br />
如果当前节点大于区间，用当前节点左子树代替当前节点，然后递归。</p>
<h4 id="代码-102"><a class="markdownIt-Anchor" href="#代码-102"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;=L&amp;&amp;root.val&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left=trimBST(root.left,L,R);</span><br><span class="line">            root.right=trimBST(root.right,L,R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;L)</span><br><span class="line">            &#123;</span><br><span class="line">                root=trimBST(root.right,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root=trimBST(root.left,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-寻找二叉查找树的第-k-个元素"><a class="markdownIt-Anchor" href="#19-寻找二叉查找树的第-k-个元素"></a> 19. 寻找二叉查找树的第 k 个元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a></p>
<h4 id="思路-105"><a class="markdownIt-Anchor" href="#思路-105"></a> 思路</h4>
<p>由二叉搜索树性质可知，对其进行中序遍历就可以还原其大小顺序，所以只需进行中序遍历，第K个元素就是第K小的。</p>
<h4 id="代码-103"><a class="markdownIt-Anchor" href="#代码-103"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        kthSmallest(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        kthSmallest(root.right, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-把二叉查找树每个节点的值都加上比它大的节点的值"><a class="markdownIt-Anchor" href="#20-把二叉查找树每个节点的值都加上比它大的节点的值"></a> 20. 把二叉查找树每个节点的值都加上比它大的节点的值</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p>
<h4 id="思路-106"><a class="markdownIt-Anchor" href="#思路-106"></a> 思路</h4>
<p>因为二叉查找树的大小顺序为<code>left&lt;root&lt;right</code>,所以按照<code>right-&gt;root-&gt;left</code>的顺序来遍历，并累加上所有遍历过的值即可。</p>
<h4 id="代码-104"><a class="markdownIt-Anchor" href="#代码-104"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        root.val=sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-二叉查找树的最近公共祖先"><a class="markdownIt-Anchor" href="#21-二叉查找树的最近公共祖先"></a> 21. 二叉查找树的最近公共祖先</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<h4 id="思路-107"><a class="markdownIt-Anchor" href="#思路-107"></a> 思路</h4>
<p>由二叉搜索树的特性可知，如果p,q都小于root，说明他们都在左子树，如果都大于root，说明都在右子树。<br />
当<code>p&lt;=root.val&lt;=q</code>的时候，说明p，q分布在两侧，则Root是其最近的公共祖先。</p>
<h4 id="代码-105"><a class="markdownIt-Anchor" href="#代码-105"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val&gt;q.val)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val&lt;=root.val&amp;&amp;q.val&gt;=root.val)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(q.val&lt;root.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#22-二叉树的最近公共祖先"></a> 22. 二叉树的最近公共祖先</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<h4 id="思路-108"><a class="markdownIt-Anchor" href="#思路-108"></a> 思路</h4>
<p>对于任意P，Q如果我们递归进行寻找，直到找到P或者Q或者空，就该返回当前节点了，那么在返回之前，我们会遇到三种情况：</p>
<ol>
<li>左子树递归为空，右子树递归为空，说明两侧都没有，返回null。</li>
<li>左子树递归不为空，右子树递归不为空，说明两侧一边一个节点，那么当前节点就是最近公共祖先，返回当前节点。</li>
<li>有一边为空，说明两个节点都在另一边，递归该侧。</li>
</ol>
<h4 id="代码-106"><a class="markdownIt-Anchor" href="#代码-106"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==q||root==p)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-从有序数组中构造二叉查找树"><a class="markdownIt-Anchor" href="#23-从有序数组中构造二叉查找树"></a> 23. 从有序数组中构造二叉查找树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<h4 id="思路-109"><a class="markdownIt-Anchor" href="#思路-109"></a> 思路</h4>
<p>因为数组有序，故可以进行二分，用中值做根节点，左半部分构建左子树，右半部分构建右子树。</p>
<h4 id="代码-107"><a class="markdownIt-Anchor" href="#代码-107"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> build(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left=build(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right=build(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-根据有序链表构造平衡的二叉查找树"><a class="markdownIt-Anchor" href="#24-根据有序链表构造平衡的二叉查找树"></a> 24. 根据有序链表构造平衡的二叉查找树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/</a></p>
<h4 id="思路-110"><a class="markdownIt-Anchor" href="#思路-110"></a> 思路</h4>
<p>因为单链表有序，所以递归思想是：从单链表中部截断，取中间节点为root，两侧两段单链表分别构成左右子树，进行递归。</p>
<h4 id="代码-108"><a class="markdownIt-Anchor" href="#代码-108"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode beforeslow=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            beforeslow=slow;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;        </span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        beforeslow.next=<span class="keyword">null</span>;</span><br><span class="line">        root.left=sortedListToBST(head);</span><br><span class="line">        root.right=sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-在二叉查找树中寻找两个节点使它们的和为一个给定值"><a class="markdownIt-Anchor" href="#25-在二叉查找树中寻找两个节点使它们的和为一个给定值"></a> 25. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/</a></p>
<h4 id="思路-111"><a class="markdownIt-Anchor" href="#思路-111"></a> 思路</h4>
<p>遍历二叉树，用辅助List保存所有节点值，因为是二叉搜索树，所以使用中序遍历可以获得有序List。<br />
然后查找List即可。</p>
<h4 id="代码-109"><a class="markdownIt-Anchor" href="#代码-109"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Traversal(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=nodes.size()-<span class="number">1</span>;i&lt;j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum=nodes.get(i)+nodes.get(j);</span><br><span class="line">            <span class="keyword">if</span>(sum==k)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;k)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Traversal(root.left);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        Traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-在二叉查找树中查找两个节点之差的最小绝对值"><a class="markdownIt-Anchor" href="#26-在二叉查找树中查找两个节点之差的最小绝对值"></a> 26. 在二叉查找树中查找两个节点之差的最小绝对值</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a></p>
<h4 id="思路-112"><a class="markdownIt-Anchor" href="#思路-112"></a> 思路</h4>
<ol>
<li>构造辅助List存放所有节点，然后遍历相邻两位的差值，取最小值。</li>
<li>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。</li>
</ol>
<h4 id="代码-110"><a class="markdownIt-Anchor" href="#代码-110"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助List</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Traversal(root);</span><br><span class="line">        <span class="keyword">if</span>(nodes.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=Math.abs(nodes.get(<span class="number">0</span>)-nodes.get(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nodes.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min=Math.min(min,Math.abs(nodes.get(i)-nodes.get(i-<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Traversal(root.left);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        Traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接计算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) </span><br><span class="line">            minDiff = Math.min(minDiff, node.val - preNode.val);</span><br><span class="line">        preNode = node;</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-寻找二叉查找树中出现次数最多的值"><a class="markdownIt-Anchor" href="#27-寻找二叉查找树中出现次数最多的值"></a> 27. 寻找二叉查找树中出现次数最多的值</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p>
<h4 id="思路-113"><a class="markdownIt-Anchor" href="#思路-113"></a> 思路</h4>
<p>对二叉搜索树用中序遍历一定是有序的，故直接中序遍历，然后统计长度。</p>
<h4 id="代码-111"><a class="markdownIt-Anchor" href="#代码-111"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curcount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    TreeNode prenode=<span class="keyword">null</span>;</span><br><span class="line">    List&lt;Integer&gt; maxlist=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        Traversal(root);</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlist.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxlist.size();i++)</span><br><span class="line">            res[i]=maxlist.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Traversal(root.left);</span><br><span class="line">        <span class="keyword">if</span>(prenode!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prenode.val==root.val)</span><br><span class="line">                curcount++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curcount=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curcount&gt;count)</span><br><span class="line">        &#123;</span><br><span class="line">            maxlist.clear();</span><br><span class="line">            maxlist.add(root.val);</span><br><span class="line">            count=curcount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(curcount==count)</span><br><span class="line">                maxlist.add(root.val);</span><br><span class="line">        prenode=root;</span><br><span class="line">        Traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="28-实现一个-trie"><a class="markdownIt-Anchor" href="#28-实现一个-trie"></a> 28. 实现一个 Trie</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p>
<h4 id="思路-114"><a class="markdownIt-Anchor" href="#思路-114"></a> 思路</h4>
<p>Trie(字典树)是一种在字符串查找，前缀匹配等方面应用广泛的算法，它在查找字符串时只与被查询的字符串长度有关，所以它在查找时只有O(1)的时间复杂度，但随之而来的较大的空间复杂度。<br />
Trie的主要结构如下图所示：<br />
<img src="https://pic002.cnblogs.com/images/2012/363302/2012091115401883.jpg" alt="" /><br />
根节点不带有任何字母，然后每个节点向下都可以有26个分支(对于小写字母字典树而言，如果需要扩大范围，分支数量也会扩大)。分别对应了26个字母的选择，然后每个分支还会有26个字母，从而构建了一个从任何字母出发，可以到达任意字母的链路，从而可以用于表示任意单词。</p>
<h4 id="代码-112"><a class="markdownIt-Anchor" href="#代码-112"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">//定义字典类的数据结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="comment">//初始化节点，为当前节点赋值，并生成大小为27的数组，前26个用于存放子节点，第27个来代表是否为叶子节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">27</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//用&#x27;0&#x27;来代表当前为叶子节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts a word into the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = word.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="comment">//构造一个以字符串长度为深度的树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//如果当前还不存在该节点，构造该节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[position] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针向下层移动</span></span><br><span class="line">            node = node.children[position];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置为叶子结点</span></span><br><span class="line">        node.children[<span class="number">26</span>] = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if the word is in the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = word.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//搜索到一半树中止了，false</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向下层遍历</span></span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.children[<span class="number">26</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = prefix.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="29-实现一个-trie用来求前缀和"><a class="markdownIt-Anchor" href="#29-实现一个-trie用来求前缀和"></a> 29. 实现一个 Trie，用来求前缀和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/map-sum-pairs/">https://leetcode-cn.com/problems/map-sum-pairs/</a></p>
<h4 id="思路-115"><a class="markdownIt-Anchor" href="#思路-115"></a> 思路</h4>
<p>与上题类似，本质是构造一个字典树，本次对于每个节点都构造一个变量存放当前的sum值，父节点在遍历时与先前值进行累加，即可得到以当前父节点为前缀的总和。<br />
在插入时先检索是否有完全匹配的路径，有的话需要先剪掉当前值再累和，从而实现覆盖。</p>
<h4 id="代码-113"><a class="markdownIt-Anchor" href="#代码-113"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">//定义字典类的数据结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        <span class="keyword">int</span> cursum;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="comment">//初始化节点，为当前节点赋值，并生成大小为27的数组，前26个用于存放子节点，第27个来代表是否为叶子节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.cursum=sum;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">27</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curval=search(key);        </span><br><span class="line">        <span class="keyword">int</span> length = key.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="comment">//构造一个以字符串长度为深度的树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = key.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//如果当前还不存在该节点，构造该节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[position] = <span class="keyword">new</span> TrieNode(c,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.children[position].cursum+=val-curval;</span><br><span class="line">            <span class="comment">//指针向下层移动</span></span><br><span class="line">            node = node.children[position];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置为叶子结点</span></span><br><span class="line">        node.children[<span class="number">26</span>] = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = prefix.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.cursum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = word.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//搜索到一半树中止了，false</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向下层遍历</span></span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.children[<span class="number">26</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.cursum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈和队列"><a class="markdownIt-Anchor" href="#三-栈和队列"></a> 三、栈和队列</h2>
<h3 id="1-用栈实现队列"><a class="markdownIt-Anchor" href="#1-用栈实现队列"></a> 1. 用栈实现队列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a></p>
<h4 id="思路-116"><a class="markdownIt-Anchor" href="#思路-116"></a> 思路</h4>
<p>队列的特性是先进先出，而栈是先进后出，所以在出栈时需要先颠倒原栈顺序。</p>
<h4 id="代码-114"><a class="markdownIt-Anchor" href="#代码-114"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; que=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; sup=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sup.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reverse();</span><br><span class="line">        <span class="keyword">return</span> que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reverse();</span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty()&amp;&amp;sup.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (que.isEmpty()) &#123;</span><br><span class="line">             <span class="keyword">while</span>(!sup.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(sup.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-用队列实现栈"><a class="markdownIt-Anchor" href="#2-用队列实现栈"></a> 2. 用队列实现栈</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p>
<h4 id="思路-117"><a class="markdownIt-Anchor" href="#思路-117"></a> 思路</h4>
<p>新插入元素之后，将除了新元素之外的所有元素都出队列再入队列，即可以维护顺序。<br />
<code>就是这些函数名不太好记</code></p>
<h4 id="代码-115"><a class="markdownIt-Anchor" href="#代码-115"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; que=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursize=que.size();</span><br><span class="line">        que.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cursize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.add(que.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-最小值栈"><a class="markdownIt-Anchor" href="#3-最小值栈"></a> 3. 最小值栈</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p>
<h4 id="思路-118"><a class="markdownIt-Anchor" href="#思路-118"></a> 思路</h4>
<p>维护一个最小值栈，然后每次push的时候同步push当前最小值，pop的时候也同步pop即可。</p>
<h4 id="代码-116"><a class="markdownIt-Anchor" href="#代码-116"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.add(x);</span><br><span class="line">        min = Math.min(min, x);</span><br><span class="line">        minStack.add(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-用栈实现括号匹配"><a class="markdownIt-Anchor" href="#4-用栈实现括号匹配"></a> 4. 用栈实现括号匹配</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></p>
<h4 id="思路-119"><a class="markdownIt-Anchor" href="#思路-119"></a> 思路</h4>
<p>左括号push入栈，右括号则将元素pop出栈进行比较，能够配对则成功，不能则失败。</p>
<h4 id="代码-117"><a class="markdownIt-Anchor" href="#代码-117"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; st=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>||ch==<span class="string">&#x27;[&#x27;</span>||ch==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>||ch==<span class="string">&#x27;]&#x27;</span>||ch==<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.isEmpty())</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">char</span> cur=st.pop();</span><br><span class="line">                    <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>&amp;&amp;cur!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ch==<span class="string">&#x27;]&#x27;</span>&amp;&amp;cur!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ch==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;cur!=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-数组中元素与下一个比它大的元素之间的距离"><a class="markdownIt-Anchor" href="#5-数组中元素与下一个比它大的元素之间的距离"></a> 5. 数组中元素与下一个比它大的元素之间的距离</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">https://leetcode-cn.com/problems/daily-temperatures/</a></p>
<h4 id="思路-120"><a class="markdownIt-Anchor" href="#思路-120"></a> 思路</h4>
<p>维护一个递减栈，在遍历数组的同时进行维护，如果当前遍历的元素:</p>
<ol>
<li>小于栈顶元素，那么就入栈，从而保证了栈内元素在目前为止没有在各自的位置后面找到比他们大的数。</li>
<li>大于栈顶元素，那么就开始出栈，意味着当前所遍历的元素，对于所有因为小于他而出栈的元素而言，都是第一次遇到的比他们大的数。两者下标相减，就可以获得天数差值,最后将当前元素入栈。</li>
<li>最后的元素位置应该用0代替，遍历之后还未出栈的元素，说明没有比他大的元素，也要用0代替，但是数组初始化为0，不用再多赋值。</li>
</ol>
<h4 id="代码-118"><a class="markdownIt-Anchor" href="#代码-118"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        Stack&lt;Integer&gt; supStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(supStack.isEmpty()||T[i]&lt;=T[supStack.peek()])</span><br><span class="line">               supStack.push(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!supStack.isEmpty()&amp;&amp;T[i]&gt;T[supStack.peek()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> index=supStack.pop();</span><br><span class="line">                    res[index]=i-index;</span><br><span class="line">                &#125;</span><br><span class="line">                supStack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-循环数组中比当前元素大的下一个元素"><a class="markdownIt-Anchor" href="#6-循环数组中比当前元素大的下一个元素"></a> 6. 循环数组中比当前元素大的下一个元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-ii/">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p>
<h4 id="思路-121"><a class="markdownIt-Anchor" href="#思路-121"></a> 思路</h4>
<p>和上题类似，只是本题需要将待检测数组重复一遍用来实现循环比较，并且在数组中不再保存下标差而是实际值。</p>
<h4 id="代码-119"><a class="markdownIt-Anchor" href="#代码-119"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        Stack&lt;Integer&gt; supStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length*<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> realindex=i%nums.length;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(supStack.isEmpty()||nums[realindex]&lt;nums[supStack.peek()])</span><br><span class="line">               supStack.push(realindex);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!supStack.isEmpty()&amp;&amp;nums[realindex]&gt;nums[supStack.peek()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> index=supStack.pop();</span><br><span class="line">                    res[index]=nums[realindex];</span><br><span class="line">                &#125;</span><br><span class="line">                supStack.push(realindex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-哈希表"><a class="markdownIt-Anchor" href="#四-哈希表"></a> 四、哈希表</h2>
<h3 id="1-数组中两个数的和为给定值"><a class="markdownIt-Anchor" href="#1-数组中两个数的和为给定值"></a> 1. 数组中两个数的和为给定值</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p>
<h4 id="思路-122"><a class="markdownIt-Anchor" href="#思路-122"></a> 思路</h4>
<p>可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。</p>
<p>用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。</p>
<h4 id="代码-120"><a class="markdownIt-Anchor" href="#代码-120"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; index=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index.containsKey(target-nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,index.get(target-nums[i])&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                index.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-判断数组是否含有重复元素"><a class="markdownIt-Anchor" href="#2-判断数组是否含有重复元素"></a> 2. 判断数组是否含有重复元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p>
<h4 id="思路-123"><a class="markdownIt-Anchor" href="#思路-123"></a> 思路</h4>
<p>利用HashSet不保存重复元素的特性，每个元素都保存一次，最后看Set的大小。</p>
<h4 id="代码-121"><a class="markdownIt-Anchor" href="#代码-121"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; res=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size()==nums.length?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-最长和谐序列"><a class="markdownIt-Anchor" href="#3-最长和谐序列"></a> 3. 最长和谐序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">https://leetcode-cn.com/problems/longest-harmonious-subsequence/</a></p>
<h4 id="思路-124"><a class="markdownIt-Anchor" href="#思路-124"></a> 思路</h4>
<p>先遍历一遍数组，用HashMap保存各个数字的出现频率，然后再遍历一次，获取相邻两数的频次和，找最大值。</p>
<h4 id="代码-122"><a class="markdownIt-Anchor" href="#代码-122"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; res=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.put(nums[i],res.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> keys : res.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.containsKey(keys+<span class="number">1</span>))</span><br><span class="line">                max=Math.max(max,res.get(keys)+res.get(keys+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-最长连续序列"><a class="markdownIt-Anchor" href="#4-最长连续序列"></a> 4. 最长连续序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p>
<h4 id="思路-125"><a class="markdownIt-Anchor" href="#思路-125"></a> 思路</h4>
<p>对于O(n)的复杂度，我们遍历一次数组，然后用辅助的Hash表进行存储，对于任意遍历到的元素，会有两种情况：</p>
<ol>
<li>表中已经存在，因为题目要求的序列元素是不重复的，所以无需处理。</li>
<li>表中不存在当前元素，需要查找该元素左右相邻数的最长连续区间长度，然后现在的最长连续区间长度就是left+right+1，随后更新两边端点的长度值以及要求的最大值即可。</li>
</ol>
<h4 id="代码-123"><a class="markdownIt-Anchor" href="#代码-123"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; len=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!len.containsKey(num))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> left=len.getOrDefault(num-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> right=len.getOrDefault(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> curlength=left+right+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(res&lt;curlength)</span><br><span class="line">                    res=curlength;</span><br><span class="line">                len.put(num-left,curlength);</span><br><span class="line">                len.put(num+right,curlength);</span><br><span class="line">                len.put(num,curlength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-字符串"><a class="markdownIt-Anchor" href="#五-字符串"></a> 五、字符串</h2>
<h3 id="1-两个字符串包含的字符是否完全相同"><a class="markdownIt-Anchor" href="#1-两个字符串包含的字符是否完全相同"></a> 1. 两个字符串包含的字符是否完全相同</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram">https://leetcode-cn.com/problems/valid-anagram</a></p>
<h4 id="思路-126"><a class="markdownIt-Anchor" href="#思路-126"></a> 思路</h4>
<p>用一个字符数组，遍历两个字符串，统计各数字出现的频次，如果频次对不上则false。</p>
<h4 id="代码-124"><a class="markdownIt-Anchor" href="#代码-124"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dic[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dic[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dic[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-计算一组字符集合可以组成的回文字符串的最大长度"><a class="markdownIt-Anchor" href="#2-计算一组字符集合可以组成的回文字符串的最大长度"></a> 2. 计算一组字符集合可以组成的回文字符串的最大长度</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindrome">https://leetcode-cn.com/problems/longest-palindrome</a></p>
<h4 id="思路-127"><a class="markdownIt-Anchor" href="#思路-127"></a> 思路</h4>
<p>遍历一次字符串统计各字符个数，偶数个的直接加，奇数个的-1再加，并且在最后加上一个多余的奇数个字符放在最中间。</p>
<h4 id="代码-125"><a class="markdownIt-Anchor" href="#代码-125"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch&lt;<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                dic[ch-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dic[ch-<span class="string">&#x27;a&#x27;</span>+<span class="number">26</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hassingle=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dic.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dic[i]%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;dic[i]!=<span class="number">0</span>)</span><br><span class="line">                res+=dic[i];</span><br><span class="line">            <span class="keyword">if</span>(dic[i]%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hassingle=<span class="number">1</span>;</span><br><span class="line">                res+=dic[i]-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res+hassingle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-字符串同构"><a class="markdownIt-Anchor" href="#3-字符串同构"></a> 3. 字符串同构</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/isomorphic-strings/">https://leetcode-cn.com/problems/isomorphic-strings/</a></p>
<h4 id="思路-128"><a class="markdownIt-Anchor" href="#思路-128"></a> 思路</h4>
<p>对于每个字符记录其上一次出现的位置，然后对比两个字符串位置是否一样，不一样就false。<br />
但是保存的时候位置要+1，不然就和0重复了。</p>
<h4 id="代码-126"><a class="markdownIt-Anchor" href="#代码-126"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sdic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] tdic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> sc=s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> tc=t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(sdic[sc]!=tdic[tc])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            sdic[sc]=i+<span class="number">1</span>;</span><br><span class="line">            tdic[tc]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-回文子字符串个数"><a class="markdownIt-Anchor" href="#4-回文子字符串个数"></a> 4. 回文子字符串个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">https://leetcode-cn.com/problems/palindromic-substrings/</a></p>
<h4 id="思路-129"><a class="markdownIt-Anchor" href="#思路-129"></a> 思路</h4>
<p>遍历字符串，从每个字符开始尝试向两边扩展。</p>
<h4 id="代码-127"><a class="markdownIt-Anchor" href="#代码-127"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sup(s,i,i);</span><br><span class="line">            sup(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sup</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))</span><br><span class="line">        &#123;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-判断一个整数是否是回文数"><a class="markdownIt-Anchor" href="#5-判断一个整数是否是回文数"></a> 5. 判断一个整数是否是回文数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-number/">https://leetcode-cn.com/problems/palindrome-number/</a></p>
<h4 id="思路-130"><a class="markdownIt-Anchor" href="#思路-130"></a> 思路</h4>
<p>为了不使用字符串，我们可以取出数字的后半段然后反转进行比较。<br />
我们将数字/10取出1位，然后*10再加下一位，这样就可以把数字的尾部反转，直到反转数&gt;=剩余数，说明已经到达中点或者已经过了中点，此时对两部分数字进行比较即可。<br />
如果是回文数，比较时会有两种情况：</p>
<ol>
<li>两侧正好相等。</li>
<li>因为原数是的位数是奇数，所有反转数会比剩余数多一位，此时只要/10然后比较即可。</li>
</ol>
<h4 id="代码-128"><a class="markdownIt-Anchor" href="#代码-128"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left=x;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            right=right*<span class="number">10</span>+left%<span class="number">10</span>;</span><br><span class="line">            left/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left==right||left==right/<span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"><a class="markdownIt-Anchor" href="#6-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"></a> 6. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-binary-substrings/">https://leetcode-cn.com/problems/count-binary-substrings/</a></p>
<h4 id="思路-131"><a class="markdownIt-Anchor" href="#思路-131"></a> 思路</h4>
<p>遍历保存当前连续的0或1的个数为precount，然后遍历紧邻的相反数字的个数为curcount，那么只要precount&gt;=curcount，那么curcount每增加1，回文子串就会增加1,这样遍历下来，就会获得回文子串的数量，当数字反转时，重置状态。</p>
<h4 id="代码-129"><a class="markdownIt-Anchor" href="#代码-129"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curcount=<span class="number">1</span>,precount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(i-<span class="number">1</span>))</span><br><span class="line">                curcount++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                precount=curcount;</span><br><span class="line">                curcount=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curcount&lt;=precount)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-数组与矩阵"><a class="markdownIt-Anchor" href="#六-数组与矩阵"></a> 六、数组与矩阵</h2>
<h3 id="1-把数组中的-0-移到末尾"><a class="markdownIt-Anchor" href="#1-把数组中的-0-移到末尾"></a> 1. 把数组中的 0 移到末尾</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p>
<h4 id="思路-132"><a class="markdownIt-Anchor" href="#思路-132"></a> 思路</h4>
<p>简单位移，剩余部分填充0。</p>
<h4 id="代码-130"><a class="markdownIt-Anchor" href="#代码-130"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)</span><br><span class="line">                nums[index++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-改变矩阵维度"><a class="markdownIt-Anchor" href="#2-改变矩阵维度"></a> 2. 改变矩阵维度</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reshape-the-matrix/">https://leetcode-cn.com/problems/reshape-the-matrix/</a></p>
<h4 id="思路-133"><a class="markdownIt-Anchor" href="#思路-133"></a> 思路</h4>
<p>手动控制目标数组进位。</p>
<h4 id="代码-131"><a class="markdownIt-Anchor" href="#代码-131"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>,col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r*c!=nums.length*nums[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[<span class="number">0</span>].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[row][col++]=nums[i][j];</span><br><span class="line">                <span class="keyword">if</span>(col==c)</span><br><span class="line">                &#123;</span><br><span class="line">                    row++;</span><br><span class="line">                    col=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-找出数组中最长的连续-1"><a class="markdownIt-Anchor" href="#3-找出数组中最长的连续-1"></a> 3. 找出数组中最长的连续 1</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones/">https://leetcode-cn.com/problems/max-consecutive-ones/</a></p>
<h4 id="思路-134"><a class="markdownIt-Anchor" href="#思路-134"></a> 思路</h4>
<p>单次便利查找连续的1</p>
<h4 id="代码-132"><a class="markdownIt-Anchor" href="#代码-132"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curcount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)</span><br><span class="line">                curcount++;</span><br><span class="line">            <span class="keyword">if</span>(curcount&gt;max)</span><br><span class="line">                max=curcount;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">1</span>)</span><br><span class="line">                curcount=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-有序矩阵查找"><a class="markdownIt-Anchor" href="#4-有序矩阵查找"></a> 4. 有序矩阵查找</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>
<h4 id="思路-135"><a class="markdownIt-Anchor" href="#思路-135"></a> 思路</h4>
<p>左下角的元素是这一行中最小的元素，同时又是这一列中最大的元素。比较左下角元素和目标：</p>
<ol>
<li>若左下角元素等于目标，则找到</li>
<li>若左下角元素大于目标，则目标不可能存在于当前矩阵的最后一行，问题规模可以减小为在去掉最后一行的子矩阵中寻找目标</li>
<li>若左下角元素小于目标，则目标不可能存在于当前矩阵的第一列，问题规模可以减小为在去掉第一列的子矩阵中寻找目标</li>
<li>若最后矩阵减小为空，则说明不存在</li>
</ol>
<h4 id="代码-133"><a class="markdownIt-Anchor" href="#代码-133"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=n-<span class="number">1</span>;i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-有序矩阵的-kth-element"><a class="markdownIt-Anchor" href="#5-有序矩阵的-kth-element"></a> 5. 有序矩阵的 Kth Element</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p>
<h4 id="思路-136"><a class="markdownIt-Anchor" href="#思路-136"></a> 思路</h4>
<p>没看懂二分，很尴尬，用K个指针实现了最笨的版本，执行用时:73 ms, 在所有 Java 提交中击败了14.78%的用户。</p>
<h4 id="代码-134"><a class="markdownIt-Anchor" href="#代码-134"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] p=<span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curcol=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i]&gt;=matrix[<span class="number">0</span>].length)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(min&gt;matrix[i][p[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    min=matrix[i][p[i]];</span><br><span class="line">                    curcol=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==k)</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            p[curcol]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-一个数组元素在-1-n-之间其中一个数被替换为另一个数找出重复的数和丢失的数"><a class="markdownIt-Anchor" href="#6-一个数组元素在-1-n-之间其中一个数被替换为另一个数找出重复的数和丢失的数"></a> 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-mismatch/">https://leetcode-cn.com/problems/set-mismatch/</a></p>
<h4 id="思路-137"><a class="markdownIt-Anchor" href="#思路-137"></a> 思路</h4>
<p>遍历一次并替换，将当前元素与应该在的正确位置的元素进行替换，结束替换应该有两个条件。</p>
<ol>
<li>当前元素位置正确，向下一位移动。</li>
<li>当前元素与目标位置元素相同，向下一位移动，否则会死循环。</li>
</ol>
<h4 id="代码-135"><a class="markdownIt-Anchor" href="#代码-135"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i + <span class="number">1</span> &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">            swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-找出数组中重复的数数组值在-1-n-之间"><a class="markdownIt-Anchor" href="#7-找出数组中重复的数数组值在-1-n-之间"></a> 7. 找出数组中重复的数，数组值在 [1, n] 之间</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p>
<h4 id="思路-138"><a class="markdownIt-Anchor" href="#思路-138"></a> 思路</h4>
<p>将数组看成链表，val是结点值也是下个节点的地址。因此这个问题就可以转换成判断链表有环，且找出入口节点—使用快慢指针，一个时间复杂度为O(N)的算法。</p>
<ol>
<li>
<p>对于链表问题，使用快慢指针可以判断是否有环。</p>
</li>
<li>
<p>本题可以使用数组配合下标，抽象成链表问题。但是难点是要定位环的入口位置。<br />
举个例子：nums = [2,5, 9 ,6,9,3,8, 9 ,7,1]，构造成链表就是：2-&gt;[9]-&gt;1-&gt;5-&gt;3-&gt;6-&gt;8-&gt;7-&gt;[9]，也就是在[9]处循环。</p>
</li>
<li>
<p>快慢指针问题，会在环内的[9]-&gt;1-&gt;5-&gt;3-&gt;6-&gt;8-&gt;7-&gt;[9]任何一个节点追上，不一定是在[9]处相碰，事实上会在7处碰上。</p>
</li>
<li>
<p>必须另起一个for循环定位环入口位置[9]。假设从头节点开始，走M步可以访问到循环的入口位置，那么当快慢指针相遇时，慢指针走了N步，则快指针就走了2N步，假设从入口位置到相遇位置还要走P步，那么克制，慢指针如果再走(N-P)步，就可以到达入口节点，而N-P=M，故如果此时用一个指针从0开始与慢指针一起走，两个指针会在循环入口处相遇。</p>
</li>
</ol>
<h4 id="代码-136"><a class="markdownIt-Anchor" href="#代码-136"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-数组相邻差值的个数"><a class="markdownIt-Anchor" href="#8-数组相邻差值的个数"></a> 8. 数组相邻差值的个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/beautiful-arrangement-ii/">https://leetcode-cn.com/problems/beautiful-arrangement-ii/</a></p>
<h4 id="思路-139"><a class="markdownIt-Anchor" href="#思路-139"></a> 思路</h4>
<p>在区间<code>[0,k]</code>内，偶数下标填充<code>[1,2,3,...]</code>奇数下标填充<code>[k+1,k,k-1,...]</code>，剩下的按顺序填充。</p>
<h4 id="代码-137"><a class="markdownIt-Anchor" href="#代码-137"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArray(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> sin=<span class="number">1</span>,dou=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                res[i]=sin++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i]=dou--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            res[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-数组的度"><a class="markdownIt-Anchor" href="#9-数组的度"></a> 9. 数组的度</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/degree-of-an-array/">https://leetcode-cn.com/problems/degree-of-an-array/</a></p>
<h4 id="思路-140"><a class="markdownIt-Anchor" href="#思路-140"></a> 思路</h4>
<p>用Map来保存每个数的出现频次与左右边界，最后遍历查找频次最高且左右边界距离最近的。</p>
<h4 id="代码-138"><a class="markdownIt-Anchor" href="#代码-138"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.containsKey(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                res.put(nums[i],<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,i,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp=res.get(nums[i]);</span><br><span class="line">                temp[<span class="number">0</span>]++;</span><br><span class="line">                temp[<span class="number">2</span>]=i;</span><br><span class="line">                res.put(nums[i],temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp=res.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(max&lt;temp[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max=temp[<span class="number">0</span>];</span><br><span class="line">                left=temp[<span class="number">1</span>];</span><br><span class="line">                right=temp[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max==temp[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((right-left)&gt;(temp[<span class="number">2</span>]-temp[<span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    left=temp[<span class="number">1</span>];</span><br><span class="line">                    right=temp[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] mapSize = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mapMin = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mapMax = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (mapSize[num] == <span class="number">0</span>) &#123;</span><br><span class="line">                mapMin[num] = i;</span><br><span class="line">                mapMax[num] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapMax[num] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            maxSize = Math.max(maxSize, ++mapSize[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt;= max; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxSize == mapSize[num]) &#123;</span><br><span class="line">                ans = Math.min(ans, mapMax[num] - mapMin[num] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-对角元素相等的矩阵"><a class="markdownIt-Anchor" href="#10-对角元素相等的矩阵"></a> 10. 对角元素相等的矩阵</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/toeplitz-matrix/">https://leetcode-cn.com/problems/toeplitz-matrix/</a></p>
<h4 id="思路-141"><a class="markdownIt-Anchor" href="#思路-141"></a> 思路</h4>
<p>只需比较当前行除最后一个元素外的其他元素与下一行除第一个元素外的其他元素是否对应想等即可。</p>
<h4 id="代码-139"><a class="markdownIt-Anchor" href="#代码-139"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-<span class="number">1</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]!=matrix[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-嵌套数组"><a class="markdownIt-Anchor" href="#11-嵌套数组"></a> 11. 嵌套数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-nesting/">https://leetcode-cn.com/problems/array-nesting/</a></p>
<h4 id="思路-142"><a class="markdownIt-Anchor" href="#思路-142"></a> 思路</h4>
<p>题意可以理解为在数组中寻找最大环路，那么就从头开始遍历数组，对于每个访问到的数字都打上标记，这样一来可以在环形访问时发现形成环，二来可以在后续遍历时停止访问，因为如果先前遍历时已经访问过，那么这个数字的环路解已经被考虑过了。</p>
<h4 id="代码-140"><a class="markdownIt-Anchor" href="#代码-140"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; nums[j] != -<span class="number">1</span>; ) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">int</span> t = nums[j];</span><br><span class="line">                nums[j] = -<span class="number">1</span>; <span class="comment">// 标记该位置已经被访问</span></span><br><span class="line">                j = t;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-分隔数组"><a class="markdownIt-Anchor" href="#12-分隔数组"></a> 12. 分隔数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">https://leetcode-cn.com/problems/max-chunks-to-make-sorted/</a></p>
<h4 id="思路-143"><a class="markdownIt-Anchor" href="#思路-143"></a> 思路</h4>
<p>在任意切分点，如果想要切分，必然需要当前块元素都小于下一块的元素。<br />
那么对于如何寻找切分点，只要寻找当前块的最大值，当最大值等于遍历下标时，即满足了条件。</p>
<h4 id="代码-141"><a class="markdownIt-Anchor" href="#代码-141"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max=Math.max(max,arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(max==i)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-图"><a class="markdownIt-Anchor" href="#七-图"></a> 七、图</h2>
<p>超出了我的能力范围，题做的超级艰难。</p>
<h3 id="1-判断是否为二分图"><a class="markdownIt-Anchor" href="#1-判断是否为二分图"></a> 1. 判断是否为二分图</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p>
<h4 id="思路-144"><a class="markdownIt-Anchor" href="#思路-144"></a> 思路</h4>
<p>用辅助数组来标记每个节点染色情况，然后从头开始遍历所有节点，从当前节点出发，若已染色则无需遍历，若未染色则染A色，然后遍历所有可达节点进行查询，若节点未染色则染反色，若已染色则判断是否为反色。</p>
<h4 id="代码-142"><a class="markdownIt-Anchor" href="#代码-142"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == <span class="number">0</span> &amp;&amp; !sup(i, <span class="number">1</span>, res, graph)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sup</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> flag,<span class="keyword">int</span>[] res,<span class="keyword">int</span>[][] graph)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res[i]==flag;</span><br><span class="line">        res[i]=flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph[i].length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!sup(graph[i][j],-flag,res,graph))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-课程安排的合法性"><a class="markdownIt-Anchor" href="#2-课程安排的合法性"></a> 2. 课程安排的合法性</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p>
<h4 id="思路-145"><a class="markdownIt-Anchor" href="#思路-145"></a> 思路</h4>
<p>先遍历一次图，获得每个课程的入度(被指次数)，也就是需要的前驱课程的数量。<br />
对于入度为0的课程，他们不需要任何前驱，所以可以从这些课程作为起点，开始向后遍历，把他们指向的课程入度都-1，然后判断这些课程是否入度会变为0，如果变为0说明这些课程是可以满足需求的，故可以继续入队列作为条件向下判断。<br />
最后看是否所有课程都满足需求。</p>
<h4 id="代码-143"><a class="markdownIt-Anchor" href="#代码-143"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] in=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            in[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>) queue.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> safe=queue.remove();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>]==safe)</span><br><span class="line">                &#123;</span><br><span class="line">                    in[prerequisites[i][<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(in[prerequisites[i][<span class="number">0</span>]]==<span class="number">0</span>)</span><br><span class="line">                        queue.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-课程安排的顺序"><a class="markdownIt-Anchor" href="#3-课程安排的顺序"></a> 3. 课程安排的顺序</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">https://leetcode-cn.com/problems/course-schedule-ii/</a></p>
<h4 id="思路-146"><a class="markdownIt-Anchor" href="#思路-146"></a> 思路</h4>
<p>与上一题一致，对于入度为0的课程就是可以学习的课程，所以只需要保存我们队列中的顺序即可。</p>
<h4 id="代码-144"><a class="markdownIt-Anchor" href="#代码-144"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span> rescount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] in=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            in[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                queue.addLast(i);</span><br><span class="line">                res[rescount++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> safe=queue.remove();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>]==safe)</span><br><span class="line">                &#123;</span><br><span class="line">                    in[prerequisites[i][<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(in[prerequisites[i][<span class="number">0</span>]]==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        queue.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">                        res[rescount++]=prerequisites[i][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numCourses==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-冗余连接"><a class="markdownIt-Anchor" href="#4-冗余连接"></a> 4. 冗余连接</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">https://leetcode-cn.com/problems/redundant-connection/</a></p>
<h4 id="思路-147"><a class="markdownIt-Anchor" href="#思路-147"></a> 思路</h4>
<p>利用并查集，保存每个边的通路，寻找父节点，最后如果找到父节点相同的两个点，这条边就是多余的。</p>
<h4 id="代码-145"><a class="markdownIt-Anchor" href="#代码-145"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] father = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length+<span class="number">1</span>];		<span class="comment">//并查集</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; father.length; i++ ) </span><br><span class="line">            father[i] = i;	<span class="comment">//初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        	<span class="keyword">int</span> fIndex1 = findFather(father, edge[<span class="number">0</span>]);	<span class="comment">//找到顶点的组先</span></span><br><span class="line">        	<span class="keyword">int</span> fIndex2 = findFather(father, edge[<span class="number">1</span>]);</span><br><span class="line">        	<span class="keyword">if</span> ( fIndex1 != fIndex2 ) &#123;	</span><br><span class="line">                <span class="comment">//如果祖先不同，说明不是多余的边</span></span><br><span class="line">        		father[fIndex1] = fIndex2;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">                <span class="comment">//祖先相同，说明是多余的边</span></span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;edge[<span class="number">0</span>],edge[<span class="number">1</span>]&#125;;</span><br><span class="line">        	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">( <span class="keyword">int</span>[] father, <span class="keyword">int</span> index )</span> </span>&#123;	<span class="comment">//路径压缩</span></span><br><span class="line">		<span class="keyword">if</span> ( index == father[index] ) <span class="keyword">return</span> index;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = findFather(father, father[index]);</span><br><span class="line">			father[index] = temp;</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八-位运算"><a class="markdownIt-Anchor" href="#八-位运算"></a> 八、位运算</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java 中的位操作</span><br><span class="line"></span><br><span class="line">static int Integer.bitCount();           &#x2F;&#x2F; 统计 1 的数量</span><br><span class="line">static int Integer.highestOneBit();      &#x2F;&#x2F; 获得最高位</span><br><span class="line">static String toBinaryString(int i);     &#x2F;&#x2F; 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure>
<h3 id="1-统计两个数的二进制表示有多少位不同"><a class="markdownIt-Anchor" href="#1-统计两个数的二进制表示有多少位不同"></a> 1. 统计两个数的二进制表示有多少位不同</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">https://leetcode-cn.com/problems/hamming-distance/</a></p>
<h4 id="思路-148"><a class="markdownIt-Anchor" href="#思路-148"></a> 思路</h4>
<p>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</p>
<h4 id="代码-146"><a class="markdownIt-Anchor" href="#代码-146"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=x^y;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>((temp&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">               count++;</span><br><span class="line">            temp=temp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-数组中唯一一个不重复的元素"><a class="markdownIt-Anchor" href="#2-数组中唯一一个不重复的元素"></a> 2. 数组中唯一一个不重复的元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p>
<h4 id="思路-149"><a class="markdownIt-Anchor" href="#思路-149"></a> 思路</h4>
<p>遍历异或，相同的异或是0。</p>
<h4 id="代码-147"><a class="markdownIt-Anchor" href="#代码-147"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-找出数组中缺失的那个数"><a class="markdownIt-Anchor" href="#3-找出数组中缺失的那个数"></a> 3. 找出数组中缺失的那个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">https://leetcode-cn.com/problems/missing-number/</a></p>
<h4 id="思路-150"><a class="markdownIt-Anchor" href="#思路-150"></a> 思路</h4>
<p>如果在数组的基础上再加上0~n,就变成了找数组中不重复的元素。</p>
<h4 id="代码-148"><a class="markdownIt-Anchor" href="#代码-148"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res^=i^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res^nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-只出现一次的元素"><a class="markdownIt-Anchor" href="#4-只出现一次的元素"></a> 4. 只出现一次的元素</h3>
<h4 id="思路-151"><a class="markdownIt-Anchor" href="#思路-151"></a> 思路</h4>
<p>假设有一个数为x,那么则有如下规律：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 ^ x &#x3D; x,</span><br><span class="line">x ^ x &#x3D; 0；</span><br><span class="line">x &amp; ~x &#x3D; 0,</span><br><span class="line">x &amp; ~0 &#x3D;x;</span><br></pre></td></tr></table></figure>
<p>对于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = (a ^ num) &amp; ~b;</span><br><span class="line">b = (b ^ num) &amp; ~a;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始状态：<code>a=0,b=0</code>;</li>
<li>x第一次出现后，<code>a=(a^x)&amp;~b=(0^x)&amp;~0=x</code>,<code>b=(b^x)&amp;~a=(0^x)&amp;~x=0</code>。</li>
<li>x第二次出现：<code>a=(a^x)&amp;~b=(x^x)&amp;~0=0</code>; <code>b=(b^x)&amp;~a=(0^x)&amp;~0=x</code>;</li>
<li>x第三次出现：<code>a=(a^x)&amp;~b=(0^x)&amp;~x=0</code>; <code>b=(b^x)&amp;~a=(x^x)&amp;~0=0</code>;所以出现三次同一个数，a和b最终都变回了0.</li>
<li>只出现一次的数，按照上面x第一次出现的规律可知<code>a=x,b=0</code>;因此最后返回a.</li>
</ol>
<h4 id="代码-149"><a class="markdownIt-Anchor" href="#代码-149"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a=(a^nums[i])&amp;~b;</span><br><span class="line">            b=(b^nums[i])&amp;~a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-数组中不重复的两个元素"><a class="markdownIt-Anchor" href="#5-数组中不重复的两个元素"></a> 5. 数组中不重复的两个元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii/">https://leetcode-cn.com/problems/single-number-iii/</a></p>
<h4 id="思路-152"><a class="markdownIt-Anchor" href="#思路-152"></a> 思路</h4>
<p>先全部异或一次,得到的结果就是这两个只出现一次的两个数的异或值， 考察其的某个非0位(比如最高非0位), 那么只出现一次的两个数中, 在这个位上一个为0, 一个为1, 由此可以将数组中的元素分成两部分,重新遍历, 求两个异或值。</p>
<h4 id="代码-150"><a class="markdownIt-Anchor" href="#代码-150"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            res=res^nums[i];</span><br><span class="line">        res=res&amp;(~res+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i]&amp;res)==<span class="number">0</span>)</span><br><span class="line">                left^=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-翻转一个数的比特位"><a class="markdownIt-Anchor" href="#6-翻转一个数的比特位"></a> 6. 翻转一个数的比特位</h3>
<h4 id="思路-153"><a class="markdownIt-Anchor" href="#思路-153"></a> 思路</h4>
<p>移位进位</p>
<h4 id="代码-151"><a class="markdownIt-Anchor" href="#代码-151"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="额外内容"><a class="markdownIt-Anchor" href="#额外内容"></a> 额外内容</h4>
<p>Integer.reverse()源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HD, Figure 7-1</span></span><br><span class="line">        i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;<span class="comment">//第一步</span></span><br><span class="line">        i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;<span class="comment">//第二步</span></span><br><span class="line">        i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;<span class="comment">//第三步</span></span><br><span class="line">        i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);<span class="comment">//第四步</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-判断一个数是不是-2-的-n-次方"><a class="markdownIt-Anchor" href="#7-判断一个数是不是-2-的-n-次方"></a> 7. 判断一个数是不是 2 的 n 次方</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-two/">https://leetcode-cn.com/problems/power-of-two/</a></p>
<h4 id="思路-154"><a class="markdownIt-Anchor" href="#思路-154"></a> 思路</h4>
<p>2的幂次的二进制一定是10000…，如果-1的话就变成了1111111…</p>
<h4 id="代码-152"><a class="markdownIt-Anchor" href="#代码-152"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n&gt;<span class="number">0</span>)&amp;&amp;(n&amp;(n-<span class="number">1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-判断一个数是不是-4-的-n-次方"><a class="markdownIt-Anchor" href="#8-判断一个数是不是-4-的-n-次方"></a> 8. 判断一个数是不是 4 的 n 次方</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-four/">https://leetcode-cn.com/problems/power-of-four/</a></p>
<h4 id="代码-153"><a class="markdownIt-Anchor" href="#代码-153"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        res=num&amp;(num-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>((res==<span class="number">0</span>)&amp;&amp;(num%<span class="number">3</span>==<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-判断一个数的位级表示是否不会出现连续的-0-和-1"><a class="markdownIt-Anchor" href="#9-判断一个数的位级表示是否不会出现连续的-0-和-1"></a> 9. 判断一个数的位级表示是否不会出现连续的 0 和 1</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">https://leetcode-cn.com/problems/binary-number-with-alternating-bits/</a></p>
<h4 id="思路-155"><a class="markdownIt-Anchor" href="#思路-155"></a> 思路</h4>
<p>如果一个数是满足条件的，那么一定是1010101…，如果将其右移一位，再和原数异或，就会得到11111111，把这个数+1就会得到100000并比原数多一位，再&amp;的话就会得到0。</p>
<h4 id="代码-154"><a class="markdownIt-Anchor" href="#代码-154"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=n^(n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (res&amp;(res+<span class="number">1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-求一个数的补码"><a class="markdownIt-Anchor" href="#10-求一个数的补码"></a> 10. 求一个数的补码</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-complement/">https://leetcode-cn.com/problems/number-complement/</a></p>
<h4 id="思路-156"><a class="markdownIt-Anchor" href="#思路-156"></a> 思路</h4>
<p>加入这个数转换二进制一共有K位，那么就可以构造一个K位的111111…,然后两个数进行异或，就可以得到取反的数。</p>
<h4 id="代码-155"><a class="markdownIt-Anchor" href="#代码-155"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=num;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//注意移位优先级低于算数运算符，要套括号</span></span><br><span class="line">            res=(res&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res^n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-实现整数的加法"><a class="markdownIt-Anchor" href="#11-实现整数的加法"></a> 11. 实现整数的加法</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-two-integers/">https://leetcode-cn.com/problems/sum-of-two-integers/</a></p>
<h4 id="思路-157"><a class="markdownIt-Anchor" href="#思路-157"></a> 思路</h4>
<p>对于任意数<code>a,b</code>,<code>a^b</code>是其各位相加而不进行进位的结果，而<code>a&amp;b</code>得到了各位是否应该进位的情况。<br />
所以<code>a&amp;b&lt;&lt;1</code>就得到了各个位所需要的进位，再与<code>a^b</code>相加就完成了一轮进位，但是相加后可能还需要进位，所以一直递归调用，知道无需进位。</p>
<h4 id="代码-156"><a class="markdownIt-Anchor" href="#代码-156"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:getSum(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-字符串数组最大乘积"><a class="markdownIt-Anchor" href="#12-字符串数组最大乘积"></a> 12. 字符串数组最大乘积</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">https://leetcode-cn.com/problems/maximum-product-of-word-lengths/</a></p>
<h4 id="思路-158"><a class="markdownIt-Anchor" href="#思路-158"></a> 思路</h4>
<p>对于每一个字符串，我们用一个数二进制的26个位置来代表，如果出现了对应的字母就<code>|1&lt;&lt;(char-'a')</code>来构造一个对应位置的1。<br />
这样再遍历两个字符串，如果两个数的标志数组&amp;的结果是0，说明没有共同的位，然后再找最大值。</p>
<h4 id="代码-157"><a class="markdownIt-Anchor" href="#代码-157"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            String s=words[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] |=<span class="number">1</span>&lt;&lt;(s.charAt(j)-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;words.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((res[i]&amp;res[j])==<span class="number">0</span>)</span><br><span class="line">                    max=Math.max(max,words[i].length()*words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-统计从-0-~-n-每个数的二进制表示中-1-的个数"><a class="markdownIt-Anchor" href="#13-统计从-0-~-n-每个数的二进制表示中-1-的个数"></a> 13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">https://leetcode-cn.com/problems/counting-bits/</a></p>
<h4 id="思路-159"><a class="markdownIt-Anchor" href="#思路-159"></a> 思路</h4>
<p><code>i&amp;(i-1)</code>可以去掉i最右边的一个1（如果有），因此<code>i&amp;(i-1)</code>是比i小的，而且<code>i&amp;(i-1)</code>的1的个数已经在前面算过了，所以i的1的个数就是<code>i&amp;(i-1)</code>的1的个数加上1。<br />
所以动态转移方程为：<code>dp[i]=dp[i&amp;(i-1)]+1</code>。</p>
<h4 id="代码-158"><a class="markdownIt-Anchor" href="#代码-158"></a> 代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i]=res[i&amp;(i-<span class="number">1</span>)]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lufer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coder.lufer.cc/2019/08/12/CYC推荐LeetCode试题题解与总结/">https://coder.lufer.cc/2019/08/12/CYC推荐LeetCode试题题解与总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coder.lufer.cc">Lufer</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/25/V2ray-TLS-Websocket%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><i class="fa fa-chevron-left">  </i><span>V2ray+TLS+Websocket搭建指南</span></a></div><div class="next-post pull-right"><a href="/2019/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"><span>设计模式总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'VqMxq8YhQKdt87hjlDYA4UDq-MdYXbMMI',
  appKey:'jMbPNFw1782lMDtEz6mIwhx4',
  placeholder:'早8点-晚11点会自动发送邮件提醒',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2021 By Lufer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>