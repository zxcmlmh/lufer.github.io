<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《深入理解JVM》部分要点总结"><meta name="keywords" content="Java,JVM,读书笔记"><meta name="author" content="Lufer"><meta name="copyright" content="Lufer"><title>《深入理解JVM》部分要点总结 | Lufer</title><link rel="shortcut icon" href="https://s2.ax1x.com/2019/08/07/eI1NJH.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e2cd7e52254704223bd3b9c0461bc06e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script src="https://www.googletagmanager.com/gtag/js?id=G-T5L2KPFS29"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-T5L2KPFS29');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"D3K0O2R6F2","apiKey":"4e808ae377111360493e99d31970584c","indexName":"BLOG_LUFER","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text"> 第二章  Java内存区域与内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-text"> 一、运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%96%B9%E6%B3%95%E5%8C%BAnon-heap%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="toc-text"> 1.方法区(Non-Heap&#x2F;永久代)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text"> 2.虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text"> 3.本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%A0%86"><span class="toc-text"> 4.堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text"> 5.程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text"> 6.直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 二、创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%A3%80%E6%9F%A5"><span class="toc-text"> 1.检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text"> 2.分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 3.内存空间初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%BF%85%E8%A6%81%E8%AE%BE%E7%BD%AE"><span class="toc-text"> 4.对对象进行必要设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text"> 三、对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%86%85%E5%AD%98%E5%A4%B4"><span class="toc-text"> 1.内存头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="toc-text"> 2.示例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%E9%9D%9E%E5%BF%85%E9%A1%BB"><span class="toc-text"> 3.对齐填充(非必须)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text"> 四、对象访问定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text"> 第三章  垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97"><span class="toc-text"> 一、对象已死吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E7%8A%B6%E6%80%81%E5%88%A4%E5%AE%9A"><span class="toc-text"> 1.对象存活状态判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%BC%BA%E5%BA%A6"><span class="toc-text"> 2.对象的引用强度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2finalize"><span class="toc-text"> 2.Finalize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%9B%9E%E6%94%B6%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="toc-text"> 3.回收永久代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text"> 二、垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4mark-sweep"><span class="toc-text"> 1.标记-清除(Mark-Sweep)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%A4%8D%E5%88%B6copying"><span class="toc-text"> 2.复制(Copying)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86mark-compact"><span class="toc-text"> 3.标记-整理(Mark-Compact)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-text"> 4.分代收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-g1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text"> 三、G1收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%89%B9%E7%82%B9"><span class="toc-text"> 1.特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text"> 2.内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3g1%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-text"> 3.G1工作步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-text"> 四、内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8eden%E5%88%86%E9%85%8D"><span class="toc-text"> 1.对象优先在Eden分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text"> 2.大对象直接进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text"> 3.长期存活的对象进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="toc-text"> 4.动态对象年龄判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-text"> 5.空间分配担保</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-vm%E8%B0%83%E4%BC%98"><span class="toc-text"> 第五章  VM调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%AB%98%E6%80%A7%E8%83%BD%E7%A1%AC%E4%BB%B6%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5"><span class="toc-text"> 一、高性能硬件部署策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E9%80%9A%E8%BF%8764%E4%BD%8Djdk%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%86%85%E5%AD%98"><span class="toc-text"> 1.通过64位JDK使用大内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%94%A8%E8%8B%A5%E5%B9%B232%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BB%BA%E7%AB%8B%E9%80%BB%E8%BE%91%E9%9B%86%E7%BE%A4"><span class="toc-text"> 2.用若干32位虚拟机建立逻辑集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3jvm%E8%BF%90%E8%A1%8C%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98"><span class="toc-text"> 3.JVM运行中可能存在的若干问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text"> 二、常用优化方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text"> 第六章  类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text"> 一、Class类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%89%8D4%E5%AD%97%E8%8A%82"><span class="toc-text"> 1.前4字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-8%E5%AD%97%E8%8A%82"><span class="toc-text"> 2.5-8字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text"> 3.常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-text"> 4.访问标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%B1%BB%E7%B4%A2%E5%BC%95%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="toc-text"> 5.类索引，父类索引与接口索引集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text"> 6.字段表集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text"> 7.方法表集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text"> 8.属性表集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text"> 二、字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="toc-text"> 1.加载与存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%BF%90%E7%AE%97"><span class="toc-text"> 2.运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 3.类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 4.对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86"><span class="toc-text"> 5.操作数栈管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB"><span class="toc-text"> 6.控制转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="toc-text"> 7.方法调用与返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86athrow"><span class="toc-text"> 8.异常处理:athrow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E5%90%8C%E6%AD%A5"><span class="toc-text"> 9.同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text"> 第七章  虚拟机类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-text"> 一、类加载顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text"> 1.生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-text"> 2.加载时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8A%A0%E8%BD%BD"><span class="toc-text"> 3.加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E9%AA%8C%E8%AF%81"><span class="toc-text"> 4.验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%87%86%E5%A4%87"><span class="toc-text"> 5.准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E8%A7%A3%E6%9E%90"><span class="toc-text"> 6.解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 7.初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text"> 二、类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%B1%BB%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-text"> 1.类相等判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.双亲委派模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text"> 第八章  虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%A0%88%E5%B8%A7"><span class="toc-text"> 一、栈帧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text"> 1.局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E5%90%8E%E5%85%A5%E5%85%88%E5%87%BA"><span class="toc-text"> 2.操作数栈(后入先出)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="toc-text"> 3.动态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text"> 4.方法返回地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text"> 二、方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%A7%A3%E6%9E%90"><span class="toc-text"> 1.解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%86%E6%B4%BE"><span class="toc-text"> 2.分派</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 第十二章  Java内存模型与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 一、Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9B%AE%E6%A0%87"><span class="toc-text"> 1.内存模型目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text"> 2.工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-text"> 3.交互操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-java%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 二、Java与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text"> 1.线程实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text"> 2.线程安全的实现方式</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/08/07/eI1UWd.jpg"></div><div class="author-info__name text-center">Lufer</div><div class="author-info__description text-center">新的一天开始啦</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">17</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">大佬们</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yuque.com/grace-gu">Grace</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://1ogisk.cn/">Logik</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://legume.ltd">豆哥</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://esportnosave.cn/">EsportsNoSave</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Lufer</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">《深入理解JVM》部分要点总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 17 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="第二章-java内存区域与内存溢出异常"><a class="markdownIt-Anchor" href="#第二章-java内存区域与内存溢出异常"></a> 第二章  Java内存区域与内存溢出异常</h1>
<h2 id="一-运行时数据区域"><a class="markdownIt-Anchor" href="#一-运行时数据区域"></a> 一、运行时数据区域</h2>
<p><img src="https://s2.ax1x.com/2019/08/08/e7J4lF.png" alt="" /></p>
<h3 id="1方法区non-heap永久代"><a class="markdownIt-Anchor" href="#1方法区non-heap永久代"></a> 1.方法区(Non-Heap/永久代)</h3>
<p>方法区是个线程共享的内存区域，主要存储：已被JVM加载的类信息，常量，静态变量，即使编译器编译后的代码。<br />
不需要连续的内存，可以选择固定大小或可扩展的大小，此外还可以选择不实现GC。<br />
该区域的GC目标主要是对常量池的回收和对类型的卸载。<br />
当方法区无法满足内存分配需求时，会抛出OutOfMemoryError异常。</p>
<h3 id="2虚拟机栈"><a class="markdownIt-Anchor" href="#2虚拟机栈"></a> 2.虚拟机栈</h3>
<p>虚拟机栈是线程私有的，主要执行Java方法，描述了Java方法执行的内存模型。<br />
每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等。一个方法从调用至执行完成的过程，就对应着一个栈帧在VM Stack中从入栈到出栈的过程。</p>
<p>局部变量表：存放了编译器可知的基本数据类型、对象引用、returnAddress。该表所需的内存空间在编译器就会完成分配，运行期间不会改变大小。</p>
<p>当线程请求的栈深度超出了JVM允许的深度，会抛出StackOverflowError异常，当扩展时无法申请到足够的内存时，会抛出OutOfMemoryError异常。</p>
<h3 id="3本地方法栈"><a class="markdownIt-Anchor" href="#3本地方法栈"></a> 3.本地方法栈</h3>
<p>本地方法栈也是线程私有的，主要执行虚拟机用的Native方法。<br />
在HotSpot中，本地方法栈与虚拟机栈合二为一。</p>
<h3 id="4堆"><a class="markdownIt-Anchor" href="#4堆"></a> 4.堆</h3>
<p>堆是所有线程共享的，是JVM所管理的内存中最大的一块，几乎所有的数组/对象实例都在这里分配内存。</p>
<p>Java堆可以细分为新生代和老年代，再细分可以分为Eden、From Survivor、To Survivor空间。</p>
<p>Java堆在物理上可以是不连续的，但在逻辑上是连续的，当内存不足以完成实例分配且无法扩展时，会抛出OutOfMemoryError异常。</p>
<h3 id="5程序计数器"><a class="markdownIt-Anchor" href="#5程序计数器"></a> 5.程序计数器</h3>
<p>程序计数器是线程私有的，是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，各计数器互不影响。</p>
<ol>
<li>执行Java方法：计数器记录正在执行的虚拟机字节码指令地址</li>
<li>执行Native方法：计数器值为空</li>
</ol>
<h3 id="6直接内存"><a class="markdownIt-Anchor" href="#6直接内存"></a> 6.直接内存</h3>
<p>NIO提供了一种基于通道和缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存在堆中的DirectByteBuffer对象作为这块内存的引用。<br />
这种方法可以避免在Java堆和Native堆中来回复制从而提高性能。</p>
<h2 id="二-创建对象"><a class="markdownIt-Anchor" href="#二-创建对象"></a> 二、创建对象</h2>
<p>在遇到New指令后执行如下步骤：</p>
<h3 id="1检查"><a class="markdownIt-Anchor" href="#1检查"></a> 1.检查</h3>
<p>检查能否在常量池定位类的符号引用，并检查这个类是否被加载解析、初始化，如果没有，则先加载类，加载完成后执行第二步。</p>
<h3 id="2分配内存"><a class="markdownIt-Anchor" href="#2分配内存"></a> 2.分配内存</h3>
<p>对象所需的内存大小在类加载完成时即确定，内存分配主要有两种方式：</p>
<ol>
<li>指针碰撞：Java堆中的内存绝对规整，用过的在一边，空闲的在另一边，中间有一个作为分界点指示器的指针，分配内存只需将该指针移动一段距离。</li>
<li>空闲列表：堆中的内存不规整，已用内存与空闲内存互相交错。此时VM维护一个列表，记录哪些内存块可用，并找一块足够大的用于分配。</li>
</ol>
<p>选择哪种方式来进行内存分配取决于堆是否规整，而堆是否规整取决于GC是否带有压缩整理功能。</p>
<p>内存分配在并发的情况下不是线程安全的，有两种解决方式：</p>
<ol>
<li>内存分配操作同步处理(慢分配)<br />
将所有内存分配操作全部同步处理，VM采用CAS(Compare And Swap)+失败重试来保证更新操作的原子性。</li>
<li>本地线程分配缓冲(快分配/TLAB)<br />
为每个线程在Java堆中预先分配一小块内存，在需要分配时每个线程在自己的TLAB上进行分配，只有在TLAB用完并需要分配新TLAB时才需要同步锁定。</li>
</ol>
<h3 id="3内存空间初始化"><a class="markdownIt-Anchor" href="#3内存空间初始化"></a> 3.内存空间初始化</h3>
<p>将分配到的内存空间都初始化为二进制的零值，保证对象不赋初值也可以直接使用。</p>
<h3 id="4对对象进行必要设置"><a class="markdownIt-Anchor" href="#4对对象进行必要设置"></a> 4.对对象进行必要设置</h3>
<p>主要包括：该对象是哪个类的实例，如何找到类的元数据，对象的Hash值，对象的GC<br />
代。这些信息保存在对象头中。</p>
<h2 id="三-对象的内存布局"><a class="markdownIt-Anchor" href="#三-对象的内存布局"></a> 三、对象的内存布局</h2>
<h3 id="1内存头"><a class="markdownIt-Anchor" href="#1内存头"></a> 1.内存头</h3>
<p>包括：</p>
<ol>
<li>用于存储对象自身运行时的数据(HashCode/GC代年龄/锁标志)，数据结构不固定。</li>
<li>类型指针，指向类元数据，用于确定该对象属于哪个类。</li>
<li>若对象为数组，对象头还记录数据长度。</li>
</ol>
<h3 id="2示例数据"><a class="markdownIt-Anchor" href="#2示例数据"></a> 2.示例数据</h3>
<p>存储数据中定义的各类字段，分配策略：long/double-&gt;int-&gt;short/char-&gt;byte/boolean-&gt;OrdinaryObjectPointer<br />
相同大小的字段总是被分配到一起，在满足这个条件的前提下，父类中定义的变量会出现在子类之前。</p>
<h3 id="3对齐填充非必须"><a class="markdownIt-Anchor" href="#3对齐填充非必须"></a> 3.对齐填充(非必须)</h3>
<p>HotSpot VM要求对象起始地址是8字节的整数倍，大小也是8字节的整数倍。如果对象实例数据没有对齐，则需要对齐填充补全。</p>
<h2 id="四-对象访问定位"><a class="markdownIt-Anchor" href="#四-对象访问定位"></a> 四、对象访问定位</h2>
<p>对象的访问定位，即如何从Reference找到具体对象，有两种方式：</p>
<ol>
<li>句柄：堆中划分一块内存作为句柄池，Reference存的是对象的句柄地址，句柄中保存对象实例数据与类型数据各自的具体信息。</li>
<li>直接指针：Reference中保存的是对象实例数据的地址，实例数据中存仓指向类型数据的指针。</li>
</ol>
<p>优劣比较：</p>
<ol>
<li>句柄方式在对象呗移动时只需改变句柄保存的内容，无需改变Reference，比较稳定。</li>
<li>直接指针节省了一次指针定位的开销，速度较快(HotSpot采用该方式实现)</li>
</ol>
<h1 id="第三章-垃圾收集器与内存分配策略"><a class="markdownIt-Anchor" href="#第三章-垃圾收集器与内存分配策略"></a> 第三章  垃圾收集器与内存分配策略</h1>
<h2 id="一-对象已死吗"><a class="markdownIt-Anchor" href="#一-对象已死吗"></a> 一、对象已死吗</h2>
<h3 id="1对象存活状态判定"><a class="markdownIt-Anchor" href="#1对象存活状态判定"></a> 1.对象存活状态判定</h3>
<p>对于对象的存活状态，主要有两种方法进行判断：</p>
<ol>
<li>引用计数：给对象添加引用计数器，有引用+1，引用失效-1，为0则不可再用，但这种方法不能解决循环引用的问题。</li>
<li>可达性分析(Java采用这种方法)：从GC Roots为起点出发，向下搜索，所走的路径叫做引用链，被引用链连起来的是可用的，不可达的是不可用的。</li>
</ol>
<h3 id="2对象的引用强度"><a class="markdownIt-Anchor" href="#2对象的引用强度"></a> 2.对象的引用强度</h3>
<ol>
<li>强引用:代码中普遍存在，只要强引用还在，对象就不会被回收</li>
<li>软引用:还有用但是非必需的对象，在内存溢出之前会被回收</li>
<li>弱引用:该类对象只能生存到下一次GC前，在GC时会被回收</li>
<li>虚引用:该引用不会影响对象的生存时间，也不能用来获得对象实例。虚引用的意义是在对象被GC时收到通知。</li>
</ol>
<h3 id="2finalize"><a class="markdownIt-Anchor" href="#2finalize"></a> 2.Finalize</h3>
<p>对于不可达的对象，会进行两次标记。</p>
<ol>
<li>对象没有覆盖finalize或已经吊用过finalze–&gt;回收</li>
<li>将对象移入F-Queue,执行Finalize方法(但是不保证会等待方法结束),在finalize中仍然没有建立对对象的引用–&gt;回收</li>
<li>finalize中建立了对对象的引用，移出GC列表</li>
</ol>
<h3 id="3回收永久代"><a class="markdownIt-Anchor" href="#3回收永久代"></a> 3.回收永久代</h3>
<p>永久代主要回收：无引用的废弃常量，要被卸载的无用类</p>
<p>无用类的判断规则(需同时满足)：</p>
<ol>
<li>该类所有实例都已回收</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类对应的java.lang.class对象没有任何地方被引用，无法通过反射访问类</li>
</ol>
<p>意义：大量使用反射，动态代理，CGLib等频繁自定义ClassLoader的情况下防止永久代溢出。</p>
<h2 id="二-垃圾收集算法"><a class="markdownIt-Anchor" href="#二-垃圾收集算法"></a> 二、垃圾收集算法</h2>
<h3 id="1标记-清除mark-sweep"><a class="markdownIt-Anchor" href="#1标记-清除mark-sweep"></a> 1.标记-清除(Mark-Sweep)</h3>
<p>先用判定方法标记对象的存活状态，然后进行回收。<br />
缺点:</p>
<ol>
<li>效率低</li>
<li>回收后空间碎片多</li>
</ol>
<h3 id="2复制copying"><a class="markdownIt-Anchor" href="#2复制copying"></a> 2.复制(Copying)</h3>
<p>将内存划分为大小相等的两块，每次仅用一块，当需要GC时，将其中存活的对象复制到另一块，回收前一块。</p>
<p>优点:只需移动堆顶指针，按顺序分配内存，实现简单，效率高。<br />
缺点:可用内存减半，代价较高。<br />
改进:将内存分为一个较大的Eden和两个较小的Survivor(HotSpot中比例为8:1:1),使用时占用一个Eden和一个Survivor，GC时复制到另一个Survivor，当空间不足时，要进行分配担保。</p>
<h3 id="3标记-整理mark-compact"><a class="markdownIt-Anchor" href="#3标记-整理mark-compact"></a> 3.标记-整理(Mark-Compact)</h3>
<p>先标记，然后将存活的对象向一端移动，在清理边界以外的内存。</p>
<h3 id="4分代收集"><a class="markdownIt-Anchor" href="#4分代收集"></a> 4.分代收集</h3>
<p>对于新生代，采用“复制”的方法。<br />
对于老年代，采用“标记-清理”或者“标记-整理”的方法。</p>
<h2 id="三-g1收集器"><a class="markdownIt-Anchor" href="#三-g1收集器"></a> 三、G1收集器</h2>
<p>G1收集器是HotSpot采用的收集器</p>
<h3 id="1特点"><a class="markdownIt-Anchor" href="#1特点"></a> 1.特点</h3>
<ol>
<li>并行与并发:并行处理，缩短Stop-The-World的时间。并发处理，在查找Root的时候Java程序可以继续执行。</li>
<li>分代收集</li>
<li>空间整合:整体上看是基于“标记-整理”，局部上看是基于“复制”，不产生空间碎片。</li>
<li>可预测的停顿:可指定在M毫秒的时间段内，可用于GC的时间不得超过N毫秒。</li>
</ol>
<h3 id="2内存管理"><a class="markdownIt-Anchor" href="#2内存管理"></a> 2.内存管理</h3>
<p>将内存堆划分为多个大小相等的Region，追踪各个Region里垃圾价值大小。维护一个优先列表，每次根据允许的时间回收价值最大的Region。</p>
<h3 id="3g1工作步骤"><a class="markdownIt-Anchor" href="#3g1工作步骤"></a> 3.G1工作步骤</h3>
<ol>
<li>初始标记:标记GC Roots能直接关联的对象。这步需要停顿线程，但耗时短。</li>
<li>并发标记:进行可达性分析，寻找存活的对象。</li>
<li>最终标记:修正并发标记时由于并发操作而产生变化的部分，需要停顿线程，但可以并发执行。</li>
<li>筛选回收:对各Region回收价值与成本进行排序，根据期望时间指定回收计划。</li>
</ol>
<h2 id="四-内存分配与回收策略"><a class="markdownIt-Anchor" href="#四-内存分配与回收策略"></a> 四、内存分配与回收策略</h2>
<h3 id="1对象优先在eden分配"><a class="markdownIt-Anchor" href="#1对象优先在eden分配"></a> 1.对象优先在Eden分配</h3>
<p>大多数情况下，对象在新生代Eden区中进行分配，当Eden区没有足够的空间时，将会出发一次Minor GC。</p>
<h3 id="2大对象直接进入老年代"><a class="markdownIt-Anchor" href="#2大对象直接进入老年代"></a> 2.大对象直接进入老年代</h3>
<p>对于需要大量连续内存空间的Java对象，直接在老年代中分配内存。</p>
<h3 id="3长期存活的对象进入老年代"><a class="markdownIt-Anchor" href="#3长期存活的对象进入老年代"></a> 3.长期存活的对象进入老年代</h3>
<p>对象每活过一次GC，年龄就会+1，当年龄增加到一定程度(可在VM参数中设置)后，就会进入老年代。</p>
<h3 id="4动态对象年龄判定"><a class="markdownIt-Anchor" href="#4动态对象年龄判定"></a> 4.动态对象年龄判定</h3>
<p>如果Survivor中相同年龄的所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h3 id="5空间分配担保"><a class="markdownIt-Anchor" href="#5空间分配担保"></a> 5.空间分配担保</h3>
<p><img src="https://s2.ax1x.com/2019/08/08/e7RzjJ.png" alt="" /></p>
<p>JDK 6以后，在老年代连续空间大于新生代对象总大小或者历次晋升平均大小时进行MinorGC，否则进行FullGC<br />
</p>
<h1 id="第五章-vm调优"><a class="markdownIt-Anchor" href="#第五章-vm调优"></a> 第五章  VM调优</h1>
<h2 id="一-高性能硬件部署策略"><a class="markdownIt-Anchor" href="#一-高性能硬件部署策略"></a> 一、高性能硬件部署策略</h2>
<h3 id="1通过64位jdk使用大内存"><a class="markdownIt-Anchor" href="#1通过64位jdk使用大内存"></a> 1.通过64位JDK使用大内存</h3>
<p>缺点:</p>
<ol>
<li>内存回收导致长时间停顿</li>
<li>64位JDK性能较低</li>
<li>需要保证程序足够稳定，因为如果溢出无法转储，也不能分析</li>
<li>64位内存消耗比32位的大</li>
</ol>
<h3 id="2用若干32位虚拟机建立逻辑集群"><a class="markdownIt-Anchor" href="#2用若干32位虚拟机建立逻辑集群"></a> 2.用若干32位虚拟机建立逻辑集群</h3>
<p>缺点:</p>
<ol>
<li>需要避免竞争全局资源</li>
<li>很难高效利用某些资源池</li>
<li>受32位限制，Windows堆只能开1.5GB,Linux只能开4GB</li>
<li>每个逻辑节点上都有缓存，造成内存浪费。</li>
</ol>
<h3 id="3jvm运行中可能存在的若干问题"><a class="markdownIt-Anchor" href="#3jvm运行中可能存在的若干问题"></a> 3.JVM运行中可能存在的若干问题</h3>
<ol>
<li>集群间频繁同步导致内存溢出</li>
<li>堆外内存溢出</li>
<li>调用外部命令导致系统缓慢</li>
<li>JVM崩溃</li>
<li>不恰当的数据结构导致内存占用过大</li>
<li>由于Windows虚拟内存导致交换到页面文件中从而导致长时间停顿</li>
</ol>
<h2 id="二-常用优化方法"><a class="markdownIt-Anchor" href="#二-常用优化方法"></a> 二、常用优化方法</h2>
<ol>
<li>升级VM版本</li>
<li>-Xverify:none 禁用字节码验证</li>
<li>调整内存设置，设定恰当的新生代容量，减少GC频率</li>
<li>指定GC收集器</li>
</ol>
<h1 id="第六章-类文件结构"><a class="markdownIt-Anchor" href="#第六章-类文件结构"></a> 第六章  类文件结构</h1>
<h2 id="一-class类文件结构"><a class="markdownIt-Anchor" href="#一-class类文件结构"></a> 一、Class类文件结构</h2>
<h3 id="1前4字节"><a class="markdownIt-Anchor" href="#1前4字节"></a> 1.前4字节</h3>
<p>魔数，用于确定这个文件是否是一个能够被VM接受的class文件，class文件的前四字节为0xCAFEBABE</p>
<h3 id="25-8字节"><a class="markdownIt-Anchor" href="#25-8字节"></a> 2.5-8字节</h3>
<p>第5和第6字节为版本号，第7和第8字节为主版本号。<br />
高版本JDK只能运行以前的class文件，不能运行更高版本的class文件。</p>
<h3 id="3常量池"><a class="markdownIt-Anchor" href="#3常量池"></a> 3.常量池</h3>
<p>主要存放两大类常量：字面量，符号引用(类和接口的全限定名/字段的名称和描述符/方法的名称和描述符)。<br />
入口有一个u2类型的变量，表示池中常量的数量，随后根据常量类型标志+常量内容位来表示常量。</p>
<h3 id="4访问标志"><a class="markdownIt-Anchor" href="#4访问标志"></a> 4.访问标志</h3>
<p>用两字节表示访问标志，用于标识一些类或接口层次的访问信息。</p>
<h3 id="5类索引父类索引与接口索引集合"><a class="markdownIt-Anchor" href="#5类索引父类索引与接口索引集合"></a> 5.类索引，父类索引与接口索引集合</h3>
<h3 id="6字段表集合"><a class="markdownIt-Anchor" href="#6字段表集合"></a> 6.字段表集合</h3>
<p>用于描述接口或勒种生命的变量，包括类级变量和实例级变量，但不包括方法内部的局部变量。<br />
其中两字节用来描述字段访问性，两字节用来表示名称(常量池索引),两字节用来表示描述符(常量池索引)。</p>
<h3 id="7方法表集合"><a class="markdownIt-Anchor" href="#7方法表集合"></a> 7.方法表集合</h3>
<h3 id="8属性表集合"><a class="markdownIt-Anchor" href="#8属性表集合"></a> 8.属性表集合</h3>
<p>部分属性:</p>
<ol>
<li>Code:以字节码形式存在的Java方法体代码</li>
<li>Exceptions:列举方法中throw出的异常类型</li>
<li>LineNumberTable:描述源码行号与字节码行号之间的对应关系</li>
<li>LocalVariableTable:描述栈帧中局部变量表中的变量与源码中定义的变量之间的关系</li>
<li>SourceFile:记录生成这个Class文件的源文件名</li>
<li>ConstantValue:通知VM为静态变量赋值</li>
<li>InnerClass:记录内部类与宿主类间的关联</li>
<li>Signature:泛型类型，使反射API可以获取泛型类型。</li>
</ol>
<h2 id="二-字节码"><a class="markdownIt-Anchor" href="#二-字节码"></a> 二、字节码</h2>
<h3 id="1加载与存储"><a class="markdownIt-Anchor" href="#1加载与存储"></a> 1.加载与存储</h3>
<p>加载:load<br />
存储:store<br />
常量加载到操作数栈:push<br />
扩充局部变量表的访问索引:wide</p>
<h3 id="2运算"><a class="markdownIt-Anchor" href="#2运算"></a> 2.运算</h3>
<p>加减乘除:add/sub/mul/div<br />
取模:rem<br />
位移:shl/shr<br />
取反:neg<br />
按位或:or<br />
按位与:and<br />
按位异或:xor<br />
自增:inc<br />
比较:cmpg,cmpl</p>
<h3 id="3类型转换"><a class="markdownIt-Anchor" href="#3类型转换"></a> 3.类型转换</h3>
<p>i2b/i2c/i2s/l2i/f2i…</p>
<h3 id="4对象"><a class="markdownIt-Anchor" href="#4对象"></a> 4.对象</h3>
<p>对象创建:new  <br />
数组创建:newarray、anewarray、multianewarray<br />
访问类实例:getfield、putfield、getstatic、putstatic<br />
数组压栈:aload<br />
将栈值存到数组:astore<br />
取数组长度:arraylength<br />
检查实例类型:instanceof、checkcast</p>
<h3 id="5操作数栈管理"><a class="markdownIt-Anchor" href="#5操作数栈管理"></a> 5.操作数栈管理</h3>
<p>出栈:pop、pop2(2元素)<br />
复制栈顶并压栈:dup、dup2<br />
交换栈顶俩元素:swap</p>
<h3 id="6控制转移"><a class="markdownIt-Anchor" href="#6控制转移"></a> 6.控制转移</h3>
<h3 id="7方法调用与返回"><a class="markdownIt-Anchor" href="#7方法调用与返回"></a> 7.方法调用与返回</h3>
<p>调用方法:invokevirtual<br />
调用接口方法:invokeinterface<br />
调用特殊方法:invokespecial(初始化、私有方法、父类方法)<br />
调用静态方法:invokestatic<br />
调用在运行时动态解析出调用点限定符的方法:invokedynamic</p>
<h3 id="8异常处理athrow"><a class="markdownIt-Anchor" href="#8异常处理athrow"></a> 8.异常处理:athrow</h3>
<h3 id="9同步"><a class="markdownIt-Anchor" href="#9同步"></a> 9.同步</h3>
<p>JVM使用monitorenter和monitorexit来支持同步的加锁与释放。</p>
<h1 id="第七章-虚拟机类加载机制"><a class="markdownIt-Anchor" href="#第七章-虚拟机类加载机制"></a> 第七章  虚拟机类加载机制</h1>
<h2 id="一-类加载顺序"><a class="markdownIt-Anchor" href="#一-类加载顺序"></a> 一、类加载顺序</h2>
<h3 id="1生命周期"><a class="markdownIt-Anchor" href="#1生命周期"></a> 1.生命周期</h3>
<p>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>
<h3 id="2加载时机"><a class="markdownIt-Anchor" href="#2加载时机"></a> 2.加载时机</h3>
<p>必须进行初始化的情形(加载，验证，准备自然需要在此之前开始):</p>
<ol>
<li>遇到new(实例化对象)，getstatic(读取静态字段)，putstatic(设置静态字段)或者invokestatic(调用静态方法)这4条字节码指令时，如果类没有初始化则必须初始化。</li>
<li>使用反射</li>
<li>初始化类时，其父类还未初始化</li>
<li>VM启动时执行的主类</li>
<li>使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandler实例最后的解析结果是REF_getStatic,REF_putStatic,REF_invokeStatck方法家句柄，并且这个方法句柄对应的类没有初始化，则需要先触发其初始化</li>
</ol>
<p>接口在初始化时，并不要求其父类接口全部完成初始化，只有在使用父接口时才初始化。</p>
<h3 id="3加载"><a class="markdownIt-Anchor" href="#3加载"></a> 3.加载</h3>
<p>加载阶段的主要任务:</p>
<ol>
<li>通过一个类的全限定名获取此类的一个二进制字节流。</li>
<li>通过字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的java.lang.class对象，作为方法区的这个类各种数据访问入口。</li>
</ol>
<p>非数组类的家在阶段既可以由引导类加载器完成，也可以由自定义类加载器去完成(重写类加载器的loadClass)。</p>
<h3 id="4验证"><a class="markdownIt-Anchor" href="#4验证"></a> 4.验证</h3>
<p>确保Class文件的字节流中包含的信息符合当前VM的要求，需要验证如下内容:</p>
<ol>
<li>文件格式验证</li>
<li>元数据验证(是否有父类，是否继承了final类，是否实现了要求的方法)</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h3 id="5准备"><a class="markdownIt-Anchor" href="#5准备"></a> 5.准备</h3>
<p>为类变量分配内存并设置初始值，内存分配仅包括类变量(被static修饰的变量)，初始值也只是赋0值，但被final修饰的变量会赋具体值。</p>
<h3 id="6解析"><a class="markdownIt-Anchor" href="#6解析"></a> 6.解析</h3>
<p>将常量池中的符号引用转换为直接引用，主要完成如下解析:</p>
<ol>
<li>类或接口的解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ol>
<h3 id="7初始化"><a class="markdownIt-Anchor" href="#7初始化"></a> 7.初始化</h3>
<p><code>&lt;clinit&gt;</code>由编译器自动收集类中所有类变量赋值动作和静态语句块合并产生。VM中第一个被执行的<code>&lt;clinit&gt;()</code>方法一定是<code>java.lang.object</code>。<br />
如果各线程同时初始化一个类，只有一个线程会执行<code>&lt;clinit&gt;()</code>方法，其他线程都会阻塞。</p>
<h2 id="二-类加载器"><a class="markdownIt-Anchor" href="#二-类加载器"></a> 二、类加载器</h2>
<h3 id="1类相等判断"><a class="markdownIt-Anchor" href="#1类相等判断"></a> 1.类相等判断</h3>
<p>类由加载它的类加载器和这个类本身一同确立起在JVM中的唯一性，必须来源于同一个加载器的同样的类在相等。</p>
<h3 id="2双亲委派模型"><a class="markdownIt-Anchor" href="#2双亲委派模型"></a> 2.双亲委派模型</h3>
<p><img src="https://s2.ax1x.com/2019/08/09/eHXHw6.png" alt="" /></p>
<p>启动类加载器：使用C++实现(HotSpot)，主要加载<code>Java_Home/lib</code>,无法手动引用，如需委派，需要在ClassLoader中返回null。<br />
扩展类加载器：主要加载<code>Java_Home/lib/ext</code>。<br />
应用程序加载器：系统类加载器，也是默认加载器。</p>
<p>所有请求都会向上传递至启动类加载器，当无法完成加载请求时才会向下传递，再由子加载器进行加载。</p>
<h1 id="第八章-虚拟机字节码执行引擎"><a class="markdownIt-Anchor" href="#第八章-虚拟机字节码执行引擎"></a> 第八章  虚拟机字节码执行引擎</h1>
<h2 id="一-栈帧"><a class="markdownIt-Anchor" href="#一-栈帧"></a> 一、栈帧</h2>
<p>栈帧是VM栈中的栈元素，是一种数据结构，存储了方法的局部变量表，操作数栈等信息，具体结构如下图所示。</p>
<p><img src="https://s2.ax1x.com/2019/08/09/eHxQWF.png" alt="" /></p>
<h3 id="1局部变量表"><a class="markdownIt-Anchor" href="#1局部变量表"></a> 1.局部变量表</h3>
<p>用于存放方法内的局部变量，最小单位为slot，slot的具体大小是可变的。<br />
slot是可以服用的，这回影响GC的行为，一个变量可能已经无用了，但局部变量表中还保存着该变量的引用，这个变量就不会被回收。当手动设置为null并被其他新变量覆盖时才会GC。</p>
<h3 id="2操作数栈后入先出"><a class="markdownIt-Anchor" href="#2操作数栈后入先出"></a> 2.操作数栈(后入先出)</h3>
<p>初始为空，在方法执行时由字节码指令入/出栈。</p>
<h3 id="3动态连接"><a class="markdownIt-Anchor" href="#3动态连接"></a> 3.动态连接</h3>
<p>指向运行时常量池中该栈帧所属方法的引用。</p>
<h3 id="4方法返回地址"><a class="markdownIt-Anchor" href="#4方法返回地址"></a> 4.方法返回地址</h3>
<p>保存方法被调用的位置。</p>
<h1 id="二-方法调用"><a class="markdownIt-Anchor" href="#二-方法调用"></a> 二、方法调用</h1>
<h3 id="1解析"><a class="markdownIt-Anchor" href="#1解析"></a> 1.解析</h3>
<p>在解析阶段，会将一部分符号引用转换为直接引用。<br />
该部分替换的都是非虚方法，主要包括静态方法、私有方法、实例构造器、父类方法、Final方法。</p>
<h3 id="2分派"><a class="markdownIt-Anchor" href="#2分派"></a> 2.分派</h3>
<ol>
<li>静态分派：根据参数的静态类型来定位方法的执行版本(重载Overload)。</li>
<li>动态分派：根据实际动态类型来选择方法的执行版本(重写Override)。</li>
</ol>
<h1 id="第十二章-java内存模型与线程"><a class="markdownIt-Anchor" href="#第十二章-java内存模型与线程"></a> 第十二章  Java内存模型与线程</h1>
<h2 id="一-java内存模型"><a class="markdownIt-Anchor" href="#一-java内存模型"></a> 一、Java内存模型</h2>
<h3 id="1内存模型目标"><a class="markdownIt-Anchor" href="#1内存模型目标"></a> 1.内存模型目标</h3>
<p>Java内存模型的主要目标是定义程序中各个变量(包括实例字段、静态字段、构成数组对象的元素，但不包括局部变量与方法参数，因为是线程私有不共享的)的访问规则，即在VM中将变量存储到内存和从内存中取出变量这样的底层细节。<br />
其意义是可以屏蔽掉各种硬件和OS的内存访问差异。</p>
<h3 id="2工作模式"><a class="markdownIt-Anchor" href="#2工作模式"></a> 2.工作模式</h3>
<p>所有变量都存储在主内存中，每条线程都有自己的工作内存，工作内存中保存了主内存的拷贝。<br />
线程对变量的所有操作都必须在工作内存中进行。<br />
<img src="https://s2.ax1x.com/2019/08/09/eb9T3T.png" alt="" /></p>
<h3 id="3交互操作"><a class="markdownIt-Anchor" href="#3交互操作"></a> 3.交互操作</h3>
<ol>
<li>lock:作用与主内存，把变量标记为一条线程独占的状态</li>
<li>unlock:作用与主内存，释放一个变量的锁定</li>
<li>read:从主内存中读取</li>
<li>load:写入工作内存(与read同时出现)</li>
<li>use:将工作内存变量传递给执行引擎</li>
<li>assign:从执行引擎取值赋给工作内存</li>
<li>store:从工作内存中读取</li>
<li>write:写入主内存(与store同时出现)</li>
</ol>
<h1 id="二-java与线程"><a class="markdownIt-Anchor" href="#二-java与线程"></a> 二、Java与线程</h1>
<h3 id="1线程实现方式"><a class="markdownIt-Anchor" href="#1线程实现方式"></a> 1.线程实现方式</h3>
<ol>
<li>内核线程实现(调用接口:轻量级线程)</li>
<li>用户线程实现</li>
<li>用户线程+轻量级线程混合实现</li>
</ol>
<h3 id="2线程安全的实现方式"><a class="markdownIt-Anchor" href="#2线程安全的实现方式"></a> 2.线程安全的实现方式</h3>
<ol>
<li>互斥同步(加锁)</li>
<li>非阻塞同步(基于冲突检测的乐观并发策略)</li>
<li>无同步(可重入代码/线程本地存储)</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lufer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coder.lufer.cc/2019/08/08/《深入理解JVM》部分要点总结/">https://coder.lufer.cc/2019/08/08/《深入理解JVM》部分要点总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coder.lufer.cc">Lufer</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/09/Spring%E9%83%A8%E5%88%86%E6%A6%82%E5%BF%B5%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>Spring部分概念要点总结</span></a></div><div class="next-post pull-right"><a href="/2019/07/31/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"><span>Java编程思想部分要点总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'VqMxq8YhQKdt87hjlDYA4UDq-MdYXbMMI',
  appKey:'jMbPNFw1782lMDtEz6mIwhx4',
  placeholder:'早8点-晚11点会自动发送邮件提醒',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2021 By Lufer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>