<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java编程思想部分要点总结"><meta name="keywords" content="后端,Java"><meta name="author" content="Lufer"><meta name="copyright" content="Lufer"><title>Java编程思想部分要点总结 | Lufer</title><link rel="shortcut icon" href="https://s2.ax1x.com/2019/08/07/eI1NJH.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e2cd7e52254704223bd3b9c0461bc06e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script src="https://www.googletagmanager.com/gtag/js?id=G-T5L2KPFS29"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-T5L2KPFS29');</script><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"D3K0O2R6F2","apiKey":"4e808ae377111360493e99d31970584c","indexName":"BLOG_LUFER","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA"><span class="toc-text"> 第一章  对象导论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-text"> 1.面向对象语言的五个特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%89%8D%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A"><span class="toc-text"> 2.前期绑定与后期绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 第二章  一切都是对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8"><span class="toc-text"> 1.对象的内存存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.基本类型与包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97%E7%B1%BB"><span class="toc-text"> 3.高精度计算类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 4.变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> 5.Static关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-text"> 第五章  初始化与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 一、初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text"> 1.构造器初始化顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%9E%83%E5%9C%BE%E6%B8%85%E7%90%86"><span class="toc-text"> 二、垃圾清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1gc%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-text"> 1.GC技术原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text"> 第六章  访问权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text"> 一、访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text"> 1. 包访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2public"><span class="toc-text"> 2.Public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3private"><span class="toc-text"> 3.Private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4protected"><span class="toc-text"> 4.Protected</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-text"> 第七章  复用类（继承）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 1. 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-override"><span class="toc-text"> 2. @Override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text"> 3.组合与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4final"><span class="toc-text"> 4.Final</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-text"> 第八章  多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text"> 1.基类与派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text"> 2.初始化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 3.协变返回类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-text"> 第九章  接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1abstract%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text"> 1.Abstract抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2interface%E6%8E%A5%E5%8F%A3"><span class="toc-text"> 2.Interface接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text"> 3.多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95"><span class="toc-text"> 4.接口扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text"> 第十章  内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text"> 1.内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2this%E4%B8%8Enew"><span class="toc-text"> 2.this与new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text"> 3.匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-text"> 4.嵌套类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 第十一章  持有对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-text"> 一、容器类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 二、迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1iterator"><span class="toc-text"> 1.Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2listiterator"><span class="toc-text"> 2.ListIterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-set"><span class="toc-text"> 三、Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-map"><span class="toc-text"> 四、Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-queue"><span class="toc-text"> 五、Queue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text"> 第十二章  异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 1.异常处理模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text"> 2.自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3finally"><span class="toc-text"> 3.Finally</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text"> 第十四章  类型信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-classloader"><span class="toc-text"> 一、ClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-rtti"><span class="toc-text"> 二、RTTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E4%B8%BB%E8%A6%81%E5%BD%A2%E5%BC%8F"><span class="toc-text"> 1.主要形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%8F%8D%E5%B0%84"><span class="toc-text"> 三、反射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-text"> 第十五章  泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B"><span class="toc-text"> 一、简单泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%93%A6%E9%99%A4"><span class="toc-text"> 二、擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%BE%B9%E7%95%8C"><span class="toc-text"> 1.边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text"> 2.通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%97%AE%E9%A2%98"><span class="toc-text"> 三、问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6"><span class="toc-text"> 第十七章  容器深入研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-set"><span class="toc-text"> 一、SET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-queue"><span class="toc-text"> 二、Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-map"><span class="toc-text"> 三、Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%95%A3%E5%88%97%E7%A0%81"><span class="toc-text"> 四、散列码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-text"> 五、性能比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1list"><span class="toc-text"> 1.List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2map"><span class="toc-text"> 2.Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%8C%81%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-text"> 六、持有引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-java-io"><span class="toc-text"> 第十八章  Java I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-text"> 1.文件加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.锁的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text"> 3.对象序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%8E%A7%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text"> 4.控制序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5transient"><span class="toc-text"> 5.Transient</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E6%B3%A8%E8%A7%A3"><span class="toc-text"> 第二十章  注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text"> 一、定义注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%9E%E7%8E%B0%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text"> 二、实现注解处理器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-text"> 第二十一章  并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BB%BB%E5%8A%A1%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-text"> 一、任务定义与执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1"><span class="toc-text"> 1.定义任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2thread%E7%B1%BB"><span class="toc-text"> 2.Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3executor"><span class="toc-text"> 3.Executor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BB%BB%E5%8A%A1%E5%9B%9E%E8%B0%83"><span class="toc-text"> 二、任务回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8F%AF%E5%9B%9E%E8%B0%83%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-text"> 1.可回调的任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-text"> 2.任务调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-text"> 三、任务控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E4%BC%91%E7%9C%A0"><span class="toc-text"> 1.休眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text"> 2.优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E8%AE%A9%E6%AD%A5"><span class="toc-text"> 3.让步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 4.后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text"> 5.异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="toc-text"> 四、资源共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8A%A0%E9%94%81"><span class="toc-text"> 1.加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text"> 2.原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text"> 3.临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text"> 4.线程本地存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%AD%A2"><span class="toc-text"> 五、线程中止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text"> 1.线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%BF%9B%E5%85%A5%E9%98%BB%E5%A1%9E"><span class="toc-text"> 2.进入阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%B8%AD%E6%96%AD"><span class="toc-text"> 3.中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C"><span class="toc-text"> 六、线程协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1wait%E4%B8%8Enotify"><span class="toc-text"> 1.wait与notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2await%E4%B8%8Esignal"><span class="toc-text"> 2.await与signal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-text"> 3.同步队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%AD%BB%E9%94%81"><span class="toc-text"> 七、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6%E9%9C%80%E5%90%8C%E6%97%B6%E6%BB%A1%E8%B6%B3"><span class="toc-text"> 1.死锁条件(需同时满足)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E7%B1%BB%E5%BA%93"><span class="toc-text"> 八、类库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1countdownlatch"><span class="toc-text"> 1.CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2cyclicbarrier"><span class="toc-text"> 2.CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3delayqueue"><span class="toc-text"> 3.DelayQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4priorityblockingqueue"><span class="toc-text"> 4.PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5semaphore"><span class="toc-text"> 5.Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6exchanger"><span class="toc-text"> 6.Exchanger</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/08/07/eI1UWd.jpg"></div><div class="author-info__name text-center">Lufer</div><div class="author-info__description text-center">新的一天开始啦</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">16</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">大佬们</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yuque.com/grace-gu">Grace</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://1ogisk.cn/">Logik</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://legume.ltd">豆哥</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://esportnosave.cn/">EsportsNoSave</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Lufer</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Java编程思想部分要点总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-31</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 18 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="第一章-对象导论"><a class="markdownIt-Anchor" href="#第一章-对象导论"></a> 第一章  对象导论</h1>
<h3 id="1面向对象语言的五个特性"><a class="markdownIt-Anchor" href="#1面向对象语言的五个特性"></a> 1.面向对象语言的五个特性</h3>
<ol>
<li>万物皆为对象</li>
<li>程序是对象的集合</li>
<li>每个对象都有由其他对象所构成的存储</li>
<li>每个对象都有其类型</li>
<li>某一特定类型的对象都可以接受同种类型的消息</li>
</ol>
<h3 id="2前期绑定与后期绑定"><a class="markdownIt-Anchor" href="#2前期绑定与后期绑定"></a> 2.前期绑定与后期绑定</h3>
<p>  前期绑定：编译器产生对一个具体函数名字的调用，运行时将这个调用解析到将要被执行的绝对地址。<br />
  后期绑定：编译器确保被调用方法的存在，并对参数和返回值执行类型检查，被调用的代码直到运行时才确定。</p>
<h1 id="第二章-一切都是对象"><a class="markdownIt-Anchor" href="#第二章-一切都是对象"></a> 第二章  一切都是对象</h1>
<h3 id="1对象的内存存储"><a class="markdownIt-Anchor" href="#1对象的内存存储"></a> 1.对象的内存存储</h3>
<ol>
<li>寄存器</li>
<li>堆栈：存放对象引用</li>
<li>堆：存放所有Java对象</li>
<li>常量：常量值通常直接存放在程序代码内部</li>
<li>非RAM存储：例如流对象和持久化对象<br />
(对于基本类型，存放在堆栈中)</li>
</ol>
<h3 id="2基本类型与包装类型"><a class="markdownIt-Anchor" href="#2基本类型与包装类型"></a> 2.基本类型与包装类型</h3>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>-</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>16bit</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>8bit</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16bit</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32bit</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64bit</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32bit</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64bit</td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody>
</table>
<h3 id="3高精度计算类"><a class="markdownIt-Anchor" href="#3高精度计算类"></a> 3.高精度计算类</h3>
<ol>
<li>BigInteger：可表示任何大小整数</li>
<li>BigDecimal：可表示任何精度浮点数</li>
</ol>
<h3 id="4变量初始化"><a class="markdownIt-Anchor" href="#4变量初始化"></a> 4.变量初始化</h3>
<p>  没有初始化的数组会被指向null，引用null会抛异常。<br />
  没有初始化的局部变量会导致编译错误。<br />
  没有初始化的成员变量会被自动初始化。</p>
<h3 id="5static关键字"><a class="markdownIt-Anchor" href="#5static关键字"></a> 5.Static关键字</h3>
<p>  使用Static的两种原因：</p>
<ol>
<li>只想为特定域分配单一存储空间</li>
<li>希望某个方法不与包含它的类的任何对象关联在一起</li>
</ol>
<h1 id="第五章-初始化与清理"><a class="markdownIt-Anchor" href="#第五章-初始化与清理"></a> 第五章  初始化与清理</h1>
<h2 id="一-初始化"><a class="markdownIt-Anchor" href="#一-初始化"></a> 一、初始化</h2>
<h3 id="1构造器初始化顺序"><a class="markdownIt-Anchor" href="#1构造器初始化顺序"></a> 1.构造器初始化顺序</h3>
<p>  在类的内部，变量定义的先后顺序决定了初始化的顺序，但他们依旧会在任何方法被调用之前得到初始化。<br />
  先初始化静态对象，然后才是非静态对象。<br />
  如果类没有定义<code>toString</code>方法，<code>print</code>将会打印&quot;类名@对象地址&quot;</p>
<h2 id="二-垃圾清理"><a class="markdownIt-Anchor" href="#二-垃圾清理"></a> 二、垃圾清理</h2>
<h3 id="1gc技术原理"><a class="markdownIt-Anchor" href="#1gc技术原理"></a> 1.GC技术原理</h3>
<ol>
<li>引用计数<br />
  每个对象都有一个计数器，当有引用连接至对象时，引用计数+1，当引用离开作用域或者被置为null时，引用计数-1。<br />
  引用计数通常在数值为0时立即回收，但是如果对象间存在循环引用，则可能会出现“应该被回收，但计数不为0”的情况。<br />
  (这种方法常用来说明GC的工作方式，但是没有JVM使用这种方式)</li>
<li>停止-复制<br />
  暂停程序运行，将所有存活对象从当前堆复制到另一个堆，没有被复制的就全部是垃圾，当复制到新堆时，变量排列紧凑，所以可以直接分配新空间。<br />
  “按需从堆中分配几块较大的内存，复制动作发生在内存之间“</li>
<li>标记-清扫<br />
  从堆栈和静态区出发，遍历所有的引用，并对对象进行标记，在全部标记工作完成后，将没有标记的对象回收。<br />
  同样也需要暂停程序。</li>
</ol>
<h1 id="第六章-访问权限控制"><a class="markdownIt-Anchor" href="#第六章-访问权限控制"></a> 第六章  访问权限控制</h1>
<h2 id="一-访问权限"><a class="markdownIt-Anchor" href="#一-访问权限"></a> 一、访问权限</h2>
<h3 id="1-包访问权限"><a class="markdownIt-Anchor" href="#1-包访问权限"></a> 1. 包访问权限</h3>
<p>  没有设置访问权限的默认为包访问权限，包访问权限中同一包内的所有类成员可互相访问，但对包外的类而言则是Private的。<br />
  如果两个类处在同一目录下，并且没有设置任何包名称，Java会认为这些类处于该目录下的默认包中。</p>
<h3 id="2public"><a class="markdownIt-Anchor" href="#2public"></a> 2.Public</h3>
<p>  一个编译单元只能有一个Public类，并且类名需要与文件名完全一致。</p>
<h3 id="3private"><a class="markdownIt-Anchor" href="#3private"></a> 3.Private</h3>
<p>  用Private修饰构造器，在其他方法中return一个新对象，这样可以阻止对构造器的直接访问。</p>
<h3 id="4protected"><a class="markdownIt-Anchor" href="#4protected"></a> 4.Protected</h3>
<p>  被Protected修饰的成员可被派生类访问，同时还提供包访问权限。</p>
<h1 id="第七章-复用类继承"><a class="markdownIt-Anchor" href="#第七章-复用类继承"></a> 第七章  复用类（继承）</h1>
<h3 id="1-初始化"><a class="markdownIt-Anchor" href="#1-初始化"></a> 1. 初始化</h3>
<p>  总是先初始化基类，再初始化派生类，即使没有基类对象，也要初始化基类。<br />
  基类构造器总是会被调用。<br />
  如要调用带参的基类构造器，需要调用<code>super()</code></p>
<h3 id="2-override"><a class="markdownIt-Anchor" href="#2-override"></a> 2. @Override</h3>
<p>  该注解没有什么额外功能，只是说明该方法要进行Override，如果使用了该注解但没有进行Override，会触发编译错误。</p>
<h3 id="3组合与继承"><a class="markdownIt-Anchor" href="#3组合与继承"></a> 3.组合与继承</h3>
<ol>
<li>组合用于想在新类中使用现有类的功能。</li>
<li>继承用于使用某个现有类，并基于它开发一个特殊版本。</li>
</ol>
<h3 id="4final"><a class="markdownIt-Anchor" href="#4final"></a> 4.Final</h3>
<p>  用Final定义的基础变量类型无法被改变。<br />
  用Final定义的对象无法改变其引用指向，但是可以修改它引用的对象的值。<br />
  可以创建不赋值的空白Final，但是必须保证使用前被初始化。<br />
  方法中被Final修饰的参数只能读不能写。<br />
  用Final修饰的类无法更改，无法继承。<br />
  Final的意义：把方法锁定，以防任何继承类修改。</p>
<h1 id="第八章-多态"><a class="markdownIt-Anchor" href="#第八章-多态"></a> 第八章  多态</h1>
<h3 id="1基类与派生类"><a class="markdownIt-Anchor" href="#1基类与派生类"></a> 1.基类与派生类</h3>
<ol>
<li>基类为其所有派生类建立公共接口，但其派生类向上转型由基类引用后，仍可找到其override的接口。<br />
  但是只有非Private方法可以被覆盖，因为Private对派生类不可见，派生类中的方法相当于新方法。</li>
<li>派生类的构造器必然会调用基类的构造器，如果没有显式调用，则会自动调用基类默认构造器，如果没有默认构造器则会编译错误。<br />
  如果需要手动清理对象，则必须在派生类中覆盖清理方法，并调用基类的清理方法，销毁顺序与初始化顺序相反。</li>
</ol>
<h3 id="2初始化过程"><a class="markdownIt-Anchor" href="#2初始化过程"></a> 2.初始化过程</h3>
<ol>
<li>先给各对象分配存储空间，并初始化为二进制的0。</li>
<li>调用基类构造器</li>
<li>初始化主体</li>
<li>调用派生类构造器</li>
</ol>
<h3 id="3协变返回类型"><a class="markdownIt-Anchor" href="#3协变返回类型"></a> 3.协变返回类型</h3>
<p>  在派生类中被覆盖的方法可以返回基类的返回类型的某种派生类型。</p>
<h1 id="第九章-接口"><a class="markdownIt-Anchor" href="#第九章-接口"></a> 第九章  接口</h1>
<h3 id="1abstract抽象类"><a class="markdownIt-Anchor" href="#1abstract抽象类"></a> 1.Abstract抽象类</h3>
<p>  如果一个类包含一个或多个抽象方法，则必须被限定为抽象类，但抽象类可以没有抽象方法。<br />
  抽象类无法产生对象，继承自抽象类的类如果没有完全实现其抽象方法，则也必须用abstract修饰。</p>
<h3 id="2interface接口"><a class="markdownIt-Anchor" href="#2interface接口"></a> 2.Interface接口</h3>
<p>  用Interface修饰的接口完全由抽象方法组成，不提供任何实现。<br />
  接口中的任何域都自动是static和final的。<br />
  接口中的方法默认为Public，所以实现接口时也必须定义为Public。</p>
<h3 id="3多重继承"><a class="markdownIt-Anchor" href="#3多重继承"></a> 3.多重继承</h3>
<p>  Java是单继承，但是一个类可以继承自一个基类，同时实现多个接口。</p>
<h3 id="4接口扩展"><a class="markdownIt-Anchor" href="#4接口扩展"></a> 4.接口扩展</h3>
<p>  接口可以继承，通过继承可以在接口中添加新方法，从而扩展接口。</p>
<h1 id="第十章-内部类"><a class="markdownIt-Anchor" href="#第十章-内部类"></a> 第十章  内部类</h1>
<h3 id="1内部类"><a class="markdownIt-Anchor" href="#1内部类"></a> 1.内部类</h3>
<p>  在类的内部定义另一个类，内部类拥有其外围类的所有元素的访问权。</p>
<h3 id="2this与new"><a class="markdownIt-Anchor" href="#2this与new"></a> 2.this与new</h3>
<p>  用<code>OuterClass.this</code>可以获得一个外部类对象的引用。<br />
  用<code>OuterClassObject.new</code>可以使其创建一个内部类对象。</p>
<h3 id="3匿名内部类"><a class="markdownIt-Anchor" href="#3匿名内部类"></a> 3.匿名内部类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4嵌套类"><a class="markdownIt-Anchor" href="#4嵌套类"></a> 4.嵌套类</h3>
<p>  将内部类用static修饰</p>
<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象。</li>
<li>不能从嵌套的对象中访问非静态的外围对象。</li>
</ol>
<p>  借助嵌套类，可以在接口中实现一些代码，甚至可以实现外围接口。</p>
<h1 id="第十一章-持有对象"><a class="markdownIt-Anchor" href="#第十一章-持有对象"></a> 第十一章  持有对象</h1>
<h2 id="一-容器类"><a class="markdownIt-Anchor" href="#一-容器类"></a> 一、容器类</h2>
<ol>
<li>Collection：<br />
List/Set/Queue</li>
<li>Map</li>
</ol>
<h2 id="二-迭代器"><a class="markdownIt-Anchor" href="#二-迭代器"></a> 二、迭代器</h2>
<h3 id="1iterator"><a class="markdownIt-Anchor" href="#1iterator"></a> 1.Iterator</h3>
<p>  使用iterator()方法返回一个Iterator，包含<code>next()/hasNext()/remove()</code>方法。<br />
  迭代器不关心容器的类型，只关心容器中的变量类型。</p>
<h3 id="2listiterator"><a class="markdownIt-Anchor" href="#2listiterator"></a> 2.ListIterator</h3>
<p>  只能用于List容器，但是可以双向移动。<br />
  包含<code>next()/previous()/set()</code>等方法</p>
<h3 id="三-set"><a class="markdownIt-Anchor" href="#三-set"></a> 三、Set</h3>
<p>  Set就是Collection的一种实现，接口完全一样。</p>
<ol>
<li>HashSet使用散列结构</li>
<li>TreeSet使用红黑树</li>
<li>LinkedHashList使用散列，但看起来像是使用了链表。</li>
<li>TreeSet中保存的内容是有序的</li>
</ol>
<p>  用<code>contains()</code>可以判断Set是否包含元素。</p>
<h3 id="四-map"><a class="markdownIt-Anchor" href="#四-map"></a> 四、Map</h3>
<p>  将容器组合起来可以获得多为扩展，例如<code>Map&lt;Int,List&lt;&gt;&gt;</code>。</p>
<h3 id="五-queue"><a class="markdownIt-Anchor" href="#五-queue"></a> 五、Queue</h3>
<p>  PriorityQueue可以按优先级排序，通过构建Comparator来实现优先级比较。</p>
<h1 id="第十二章-异常处理"><a class="markdownIt-Anchor" href="#第十二章-异常处理"></a> 第十二章  异常处理</h1>
<p>  用Try包裹可能产生异常的语句块，用Catch进行捕获。<br />
  仅搜索第一个匹配的Catch块，Catch执行后即认为异常得到处理，不会再匹配其他符合要求的Catch，即便再次抛出，也只会抛给上层处理，不会再被Catch捕获。</p>
<h3 id="1异常处理模型"><a class="markdownIt-Anchor" href="#1异常处理模型"></a> 1.异常处理模型</h3>
<ol>
<li>终止模型：抛出异常，终止代码。</li>
<li>恢复模型：异常被处理后继续执行。</li>
</ol>
<h3 id="2自定义异常"><a class="markdownIt-Anchor" href="#2自定义异常"></a> 2.自定义异常</h3>
<p>  可以通过继承自异常类来创建自定义类型的异常。</p>
<h3 id="3finally"><a class="markdownIt-Anchor" href="#3finally"></a> 3.Finally</h3>
<p>  由于Java不需要进行内存回收，也不需要析构，所以Finally中主要负责将除内存之外的其他资源恢复到初始状态。</p>
<h1 id="第十四章-类型信息"><a class="markdownIt-Anchor" href="#第十四章-类型信息"></a> 第十四章  类型信息</h1>
<h2 id="一-classloader"><a class="markdownIt-Anchor" href="#一-classloader"></a> 一、ClassLoader</h2>
<p>  Java的Class是动态加载的，各个部分在必需时才会被加载。<br />
  先检查类是否加载，若尚未加载，默认的类加载器根据类名查找Class。<br />
  在加载时会验证类有没有被破坏，并且是否包含不良代码。</p>
<p>  实际工作：</p>
<ol>
<li>加载<br />
  由类加载器执行，查找字节码，并从字节码创建class对象。</li>
<li>链接<br />
  验证字节码，为静态域分配空间，如果必须的话，解析这个类创建的对其他类的所有引用。</li>
<li>初始化<br />
  如果类具有父类，则先对父类进行初始化，执行静态初始化器和静态块。</li>
</ol>
<h2 id="二-rtti"><a class="markdownIt-Anchor" href="#二-rtti"></a> 二、RTTI</h2>
<h3 id="1主要形式"><a class="markdownIt-Anchor" href="#1主要形式"></a> 1.主要形式</h3>
<ol>
<li>传统的类型转换/强制类型转换，由RTTI保证类型的正确性。</li>
<li>代表对象类型的class对象，通过查询class对象来获取运行时所需信息。</li>
<li>InstanceOf返回布尔值，判断对象类型。</li>
</ol>
<p>  用<code>InstanceOf</code>判断的是是否为该类或者其派生类，用类名<code>.class</code>搭配<code>==</code>或者<code>equals()</code>只能判断是否为该类。</p>
<h2 id="三-反射"><a class="markdownIt-Anchor" href="#三-反射"></a> 三、反射</h2>
<p>  检查可用的方法，并返回方法名。<br />
  RTTI是在编译时打开和检查class文件，而反射是在运行时打开和检查class文件。</p>
<h1 id="第十五章-泛型"><a class="markdownIt-Anchor" href="#第十五章-泛型"></a> 第十五章  泛型</h1>
<h2 id="一-简单泛型"><a class="markdownIt-Anchor" href="#一-简单泛型"></a> 一、简单泛型</h2>
<p>  用<code>&lt;&gt;</code>括住类型参数跟在类名后，括号内可以为多元组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class ClassName&lt;T&gt;() &#123;&#125;</span><br><span class="line">Class ClassName&lt;A,B,C&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  不能使用基本类型作为参数，需要使用包装类型。<br />
  如果使用泛型方法可以取代将整个类泛型化，那就应该只使用泛型方法。</p>
<h2 id="二-擦除"><a class="markdownIt-Anchor" href="#二-擦除"></a> 二、擦除</h2>
<p>  在泛型内部，无法获得任何有关泛型参数类型的信息，任何具体信息都将被消除，但是擦除只会擦除到第一个边界，</p>
<h3 id="1边界"><a class="markdownIt-Anchor" href="#1边界"></a> 1.边界</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T extends ClassA&amp;ClassB&gt; </span><br></pre></td></tr></table></figure>
<h3 id="2通配符"><a class="markdownIt-Anchor" href="#2通配符"></a> 2.通配符</h3>
<p>  <code>List&lt;? extends BaseClass&gt;</code><br />
  超类型通配符：<code>List&lt;? super SuperClass&gt;</code><br />
  无界通配符：<code>List&lt;?&gt;</code></p>
<h2 id="三-问题"><a class="markdownIt-Anchor" href="#三-问题"></a> 三、问题</h2>
<ol>
<li>基本类型不能用作类型参数，要使用包装器。</li>
<li>一个类不能实现同一泛型接口的两种变体，因为会被擦除。</li>
<li>使用带有泛型类型参数的转型或InstanceOf不会有任何结果。</li>
<li>由于擦除，不能产生唯一的参数列表，所以不能重载。</li>
<li>基类会劫持接口，使得实现接口后就不能再接受其他类。</li>
</ol>
<h1 id="第十七章-容器深入研究"><a class="markdownIt-Anchor" href="#第十七章-容器深入研究"></a> 第十七章  容器深入研究</h1>
<p><img src="https://s2.ax1x.com/2019/08/08/eTh5zF.gif" alt="" /></p>
<h2 id="一-set"><a class="markdownIt-Anchor" href="#一-set"></a> 一、SET</h2>
<p>  如果没有其他限制，则应该使用HashSet，因为HashSet在速度上进行了优化。<br />
  必须为类创建equals方法，在使用HashSet或LinkedHashSet时还要实现hasCode方法。<br />
  SortedSet：按比较函数排序的Set<br />
  LinkedHashSet：按插入顺序排序的Set</p>
<h2 id="二-queue"><a class="markdownIt-Anchor" href="#二-queue"></a> 二、Queue</h2>
<p>  两种实现(LinkedList/PriorityQueue)的差异在于排序行为而不在于性能。<br />
  LinkedList包含支持双向队列的方法，但是没有显式的接口。</p>
<h2 id="三-map"><a class="markdownIt-Anchor" href="#三-map"></a> 三、Map</h2>
<ol>
<li>HashMap</li>
<li>LinkedHashMap：按插入顺序排序</li>
<li>TreeMap：基于红黑树，有序排列，比HashMap慢</li>
<li>WeakHashMap：当没有引用指向某个Key时，该Key可以被回收</li>
<li>ConcurrentHashMap：线程安全的Map，但是没有同步锁</li>
<li>IdentityHashMap：内部用==代替了equals，所以具有完全不同的性能</li>
</ol>
<h2 id="四-散列码"><a class="markdownIt-Anchor" href="#四-散列码"></a> 四、散列码</h2>
<p>  步骤：</p>
<ol>
<li>对对象进行散列，得到一个值</li>
<li>将该值作为数组下标</li>
<li>在该下表下的数组元素存在值得List</li>
<li>查找时根据下标找到List，再在List中进行线性查找</li>
</ol>
<p>  散列码的生成必须要块，而且有意义，必须基于对象内容生成，保证对于同样的内容生成的散列码相同，但是不需要独一无二，不同内容也可生成相同的散列码，好的散列函数应该生成相对较为分散的散列码。</p>
<h2 id="五-性能比较"><a class="markdownIt-Anchor" href="#五-性能比较"></a> 五、性能比较</h2>
<h3 id="1list"><a class="markdownIt-Anchor" href="#1list"></a> 1.List</h3>
<p>  ArrayList在数据量大的时候访问比较快，但是插入新数据会比较慢。<br />
  LinkedList插入删除较快。</p>
<h3 id="2map"><a class="markdownIt-Anchor" href="#2map"></a> 2.Map</h3>
<p>  HashMap与HashTable速度相当，都比较快。<br />
  LinkedHashMap会慢一点，因为在插入时还要维护顺序。</p>
<h2 id="六-持有引用"><a class="markdownIt-Anchor" href="#六-持有引用"></a> 六、持有引用</h2>
<p>  用Reference对象可以使我们持有该对象，但是在需要GC时回收该对象，在存在可能会耗尽内存的大对象时特别有用。</p>
<h1 id="第十八章-java-io"><a class="markdownIt-Anchor" href="#第十八章-java-io"></a> 第十八章  Java I/O</h1>
<h3 id="1文件加锁"><a class="markdownIt-Anchor" href="#1文件加锁"></a> 1.文件加锁</h3>
<p>  对FileChannel调用trylock或lock可以对文件加锁。<br />
  文件锁对其他进程是可见的，因为Java的文件锁直接映射在系统加锁工具上。</p>
<ol>
<li>TryLock：非阻塞式加锁，若不能加锁则返回。</li>
<li>Lock：阻塞式加锁，会阻塞进程直至锁可以获得，或者调用Lock的线程中断/通道关闭。</li>
</ol>
<p>  <code>Filelock.release()</code>可以释放锁。<br />
  trylock或lock可以带参数来指定加锁范围，只会锁定固定区域，不带参的锁将根据文件尺寸变化而变化。</p>
<h3 id="2锁的类型"><a class="markdownIt-Anchor" href="#2锁的类型"></a> 2.锁的类型</h3>
<ol>
<li>独占锁：锁定的资源只允许加锁的程序使用。</li>
<li>共享锁：锁定的资源可被其他程序读取，但不能更改。</li>
</ol>
<p>  锁的类型由操作系统底层提供，如果不支持共享锁，调用时会返回独占锁。<br />
  锁的类型可以通过<code>Filelock.isShared()</code>查询。</p>
<h3 id="3对象序列化"><a class="markdownIt-Anchor" href="#3对象序列化"></a> 3.对象序列化</h3>
<p>  对于实现了Seriallized接口的对象，可以使用writeObject将其序列化，序列化可以将对象的关系网全部保存，可以借助readObject读取。</p>
<p>序列化的意义：</p>
<ol>
<li>支持远程方法调用(RMI),可以在本机上使用远程计算机上的对象。</li>
<li>支持JavaBeans。</li>
</ol>
<h3 id="4控制序列化"><a class="markdownIt-Anchor" href="#4控制序列化"></a> 4.控制序列化</h3>
<p>  让类实现接口Externalizable，并实现writeExternal和readExternal方法，但该类的默认构造器需为public，因为所有的默认构造器都会被调用。</p>
<h3 id="5transient"><a class="markdownIt-Anchor" href="#5transient"></a> 5.Transient</h3>
<p>  被transient修饰的变量在被序列化时不会被处理，可以防止敏感部分被序列化。</p>
<h1 id="第二十章-注解"><a class="markdownIt-Anchor" href="#第二十章-注解"></a> 第二十章  注解</h1>
<h2 id="一-定义注解"><a class="markdownIt-Anchor" href="#一-定义注解"></a> 一、定义注解</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义注解用在什么地方</span></span><br><span class="line"><span class="meta">@Target(ElementType.CONSTRUCTOR)</span>     <span class="comment">//构造器</span></span><br><span class="line">        ElementType.FIELD            <span class="comment">//域</span></span><br><span class="line">        ElementType.LOCAL_VARIABLE   <span class="comment">//局部变量</span></span><br><span class="line">        ElementType.METHOD           <span class="comment">//方法</span></span><br><span class="line">        ElementType.PACKAGE          <span class="comment">//包</span></span><br><span class="line">        ElementType.PARAMETER        <span class="comment">//参数</span></span><br><span class="line">        ElementType.TYPE             <span class="comment">//类，接口</span></span><br><span class="line"><span class="comment">//定义在什么级别保存注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span>   <span class="comment">//源码级别，被编译器丢弃</span></span><br><span class="line">           RetentionPolicy.CLASS     <span class="comment">//class文件级别，被VM丢弃</span></span><br><span class="line">           RetentionPolicy.RUNTIME   <span class="comment">//运行时级别，可通过反射读取</span></span><br><span class="line"><span class="comment">//注解会被包含在JavaDoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//子类可继承父类注解</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test() &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二-实现注解处理器"><a class="markdownIt-Anchor" href="#二-实现注解处理器"></a> 二、实现注解处理器</h2>
<p>  通过<code>method.getAnnotation(ClassName.class)</code>来判断方法上是否有指定类型的注解，并进行后续处理。</p>
<h1 id="第二十一章-并发"><a class="markdownIt-Anchor" href="#第二十一章-并发"></a> 第二十一章  并发</h1>
<h2 id="一-任务定义与执行"><a class="markdownIt-Anchor" href="#一-任务定义与执行"></a> 一、任务定义与执行</h2>
<h3 id="1定义任务"><a class="markdownIt-Anchor" href="#1定义任务"></a> 1.定义任务</h3>
<p>  实现Runable接口并编写run()方法，并在run中实现所需业务操作。</p>
<h3 id="2thread类"><a class="markdownIt-Anchor" href="#2thread类"></a> 2.Thread类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ClassA());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>  为Thread构造器传入一个Runable对象，再调用Thread的<code>start()</code>方法，此时会创建一个新线程。</p>
<h3 id="3executor"><a class="markdownIt-Anchor" href="#3executor"></a> 3.Executor</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">exec.execute(<span class="keyword">new</span> ClassA());</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure>
<p>  通过<code>exec.execute</code>提交任务，<code>exec.shutdown</code>可以防止新任务被提交，但是已提交的任务会继续执行，将在所有任务完成后退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Executors在线程有可能的情况下都会被复用</span></span><br><span class="line">Executors.newCachedThreadPool()</span><br><span class="line">Executors.newFixedThreadPool(Count)  <span class="comment">//数量有限的线程池，一次完成所有线程创建</span></span><br><span class="line">Executors.newSingleThreadPool()      <span class="comment">//只有1个线程，若提交多个任务会排队执行</span></span><br></pre></td></tr></table></figure>
<h2 id="二-任务回调"><a class="markdownIt-Anchor" href="#二-任务回调"></a> 二、任务回调</h2>
<h3 id="1可回调的任务"><a class="markdownIt-Anchor" href="#1可回调的任务"></a> 1.可回调的任务</h3>
<p>  Runable只可执行，不能回调。<br />
  需要实现Callable接口，类型参数为call()方法的返回值。</p>
<h3 id="2任务调用"><a class="markdownIt-Anchor" href="#2任务调用"></a> 2.任务调用</h3>
<p>  须用<code>exec.submit(new ClassA())</code>来调用，submit方法会返回Future对象，Future是泛型的，其参数类型是回调函数返回值的类型。<br />
  可以用isDone()方法来查询Future是否完成，任务完成时，会产生结果，可用get()方法进行获取，如果在未完成时即调用get()方法，则会一致阻塞到有结果产生。</p>
<h2 id="三-任务控制"><a class="markdownIt-Anchor" href="#三-任务控制"></a> 三、任务控制</h2>
<h3 id="1休眠"><a class="markdownIt-Anchor" href="#1休眠"></a> 1.休眠</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep()                  (老方式)  </span><br><span class="line">TimeUnit.MILLISECONDS.sleep()   (Java SE5/<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2优先级"><a class="markdownIt-Anchor" href="#2优先级"></a> 2.优先级</h3>
<p>  在任务内部，调用<code>Thread.currentThread().getPriority()</code>来获取优先级。调用<code>Thread.currentThread().setPriority()</code>来修改优先级。</p>
<p>  建议的优先级：</p>
<ol>
<li>MAX_PRIORITY</li>
<li>NORMAL_PRIORITY</li>
<li>MIN_PRIORITY</li>
</ol>
<h3 id="3让步"><a class="markdownIt-Anchor" href="#3让步"></a> 3.让步</h3>
<p>  使用yield方法可以暗示建议其他具有相同优先级的线程先运行，但是不保证效果。</p>
<h3 id="4后台线程"><a class="markdownIt-Anchor" href="#4后台线程"></a> 4.后台线程</h3>
<p>  在<code>Thread.start()</code>之前先<code>Thread.setDaemo(true)</code>将线程设置为后台线程，在程序的非后台线程结束时，程序会中指运行，并杀死所有的后台线程。</p>
<h3 id="5异常处理"><a class="markdownIt-Anchor" href="#5异常处理"></a> 5.异常处理</h3>
<p>  无法直接用try-catch从线程中捕获异常，但是可以在每一个Thread对象上附着一个异常处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler())</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyUncaughtExceptionHandler实现接口与方法</span></span><br><span class="line">Class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t,Throwable e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-资源共享"><a class="markdownIt-Anchor" href="#四-资源共享"></a> 四、资源共享</h2>
<h3 id="1加锁"><a class="markdownIt-Anchor" href="#1加锁"></a> 1.加锁</h3>
<p>  用<code>synchronized</code>修饰的方法或代码片段，会在执行时检查-&gt;获取锁-&gt;执行-&gt;释放锁。<br />
  一个对象中的所有同步方法共享一个锁，若某个任务调用了其中一个加锁方法，则只有等其结束并释放后，其他任务才能调用其中的任何一个同步方法。</p>
<h3 id="2原子性"><a class="markdownIt-Anchor" href="#2原子性"></a> 2.原子性</h3>
<p>  Java中，所有出了long和double以外的基本类型进行读写都是原子性的，但JVM对于64位的long和double会拆分成两个32位的操作，破坏原子性。<br />
  可以用volatile修饰long和double来获取原子性简单操作，此外，Java还提供AtomicLong，AtomicInteger，AtomicReference等原子类。</p>
<h3 id="3临界区"><a class="markdownIt-Anchor" href="#3临界区"></a> 3.临界区</h3>
<p>  可用<code>synchronized(ObjectA)&#123; 代码块 &#125;</code>来对ObjectA的某个代码块加同步锁，在进入该代码块之前必须获得该对象的锁。</p>
<h3 id="4线程本地存储"><a class="markdownIt-Anchor" href="#4线程本地存储"></a> 4.线程本地存储</h3>
<p>  使用<code>ThreadLocal</code>创建本地存储的副本，用<code>get()</code>可以获得与该线程关联的副本，用<code>set()</code>可以将参数写入线程的存储对象中。</p>
<h2 id="五-线程中止"><a class="markdownIt-Anchor" href="#五-线程中止"></a> 五、线程中止</h2>
<h3 id="1线程的状态"><a class="markdownIt-Anchor" href="#1线程的状态"></a> 1.线程的状态</h3>
<ol>
<li>新建(new)<br />
  创建进程时会短暂处于该状态，此时已分配了必须的系统资源，并执行了初始化，之后会变为可运行/阻塞状态。</li>
<li>就绪(Runable)<br />
  此时只要调度器把时间片分配给线程，线程就可以运行，运行不运行完全取决于是否获得CPU时间。</li>
<li>阻塞(Blocked)<br />
  线程虽能运行，但有条件阻止其运行。调度器不会分配时间，直至线程重新回到就绪状态。</li>
<li>死亡(Dead)<br />
  不可调度，也不会获得时间，通常从run()中返回，但可被中断。</li>
</ol>
<h3 id="2进入阻塞"><a class="markdownIt-Anchor" href="#2进入阻塞"></a> 2.进入阻塞</h3>
<ol>
<li>调用<code>sleep()</code></li>
<li>调用<code>wait()</code>，直到线程得到<code>notify()/notifyAll()/signal()/signalAll()</code>才会进入就绪状态</li>
<li>等待某个输入/输出完成</li>
<li>任务试图在对象上调用其同步方法，但是无法获取对象锁</li>
</ol>
<h3 id="3中断"><a class="markdownIt-Anchor" href="#3中断"></a> 3.中断</h3>
<p>  Thread类包含<code>interrupt()</code>方法，可以打断被阻塞的方法。</p>
<h2 id="六-线程协作"><a class="markdownIt-Anchor" href="#六-线程协作"></a> 六、线程协作</h2>
<h3 id="1wait与notify"><a class="markdownIt-Anchor" href="#1wait与notify"></a> 1.wait与notify</h3>
<p>  sleep与yield并不会释放锁，只有wait才会使线程挂起，并释放锁，其他synchronized方法才能继续调用。</p>
<p>  wait有两种形式:</p>
<ol>
<li>带毫秒参数，在时间到期后会恢复执行</li>
<li>不带参，将会无限等待</li>
</ol>
<p>  该方法是基类Object的一部分，而不属于Thread，所以可放在任何同步方法中。</p>
<p>  notify()会唤醒一个任务，notifyAll()会唤醒在等待某个特定锁的任务。</p>
<h3 id="2await与signal"><a class="markdownIt-Anchor" href="#2await与signal"></a> 2.await与signal</h3>
<p>  <code>Condition.await()</code>挂起任务，调用signal或signalAll可以唤醒Condition上被其自身挂起的任务。</p>
<h3 id="3同步队列"><a class="markdownIt-Anchor" href="#3同步队列"></a> 3.同步队列</h3>
<p>  向同步队列中插入或移除元素，如果队列为空但试图从队列中获取对象，就会被挂起，直到队列中有对象可用。</p>
<p>  LinkedBlockingQueue是无届队列。<br />
  ArrayBlockingQueue有固定尺寸。</p>
<p>  高级封装：管道(PipedWriter/PipedReader)。</p>
<p>  写入类实现一个PipedWriter对象，然后<code>writer.write()</code>。<br />
  读取类要先获取写入类的writer，并以此为参数构建Reader，再调用<code>reader.read()</code>。</p>
<h2 id="七-死锁"><a class="markdownIt-Anchor" href="#七-死锁"></a> 七、死锁</h2>
<h3 id="1死锁条件需同时满足"><a class="markdownIt-Anchor" href="#1死锁条件需同时满足"></a> 1.死锁条件(需同时满足)</h3>
<ol>
<li>任务互斥，两个任务请求同一个不能共享的资源</li>
<li>一个任务已持有一个资源，并在等待一个被其他任务占有的资源</li>
<li>资源不能被抢占，必须等待释放</li>
<li>存在循环等待</li>
</ol>
<h2 id="八-类库"><a class="markdownIt-Anchor" href="#八-类库"></a> 八、类库</h2>
<h3 id="1countdownlatch"><a class="markdownIt-Anchor" href="#1countdownlatch"></a> 1.CountDownLatch</h3>
<p>  构造时指定一个计数值，该值通过调用<code>countDown()</code>来递减1，在调用await()后对象会被阻塞，当计数器到0之后会恢复运行。</p>
<h3 id="2cyclicbarrier"><a class="markdownIt-Anchor" href="#2cyclicbarrier"></a> 2.CyclicBarrier</h3>
<p>  与CountDownLatch类似，但是CountDownLatch是一个线程在等待多个线程，而CyclicBarrier是多个线程await之后都在等待计数器，到0之后会一起恢复运行。</p>
<h3 id="3delayqueue"><a class="markdownIt-Anchor" href="#3delayqueue"></a> 3.DelayQueue</h3>
<p>  一个无界的BlockingQueue，内部放置的是实现了Delayed接口的对象，对象有一个到期时间，在到期之后才可以被取走。<br />
  该队列是有序的，队首元素是到期时间最长的元素，如果没有对象到期，试图poll会返回null。</p>
<h3 id="4priorityblockingqueue"><a class="markdownIt-Anchor" href="#4priorityblockingqueue"></a> 4.PriorityBlockingQueue</h3>
<p>  线程安全的优先级队列，总是先执行优先级最高的任务。</p>
<h3 id="5semaphore"><a class="markdownIt-Anchor" href="#5semaphore"></a> 5.Semaphore</h3>
<p>  技术信号量(有点类似池的概念)，管理有限的对象。</p>
<h3 id="6exchanger"><a class="markdownIt-Anchor" href="#6exchanger"></a> 6.Exchanger</h3>
<p>  双向同步队列，其中一个线程被调用时会唤醒另一个调用此方法的线程，两者交换数据。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lufer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coder.lufer.cc/2019/07/31/Java编程思想部分要点总结/">https://coder.lufer.cc/2019/07/31/Java编程思想部分要点总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coder.lufer.cc">Lufer</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/08/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E3%80%8B%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>《深入理解JVM》部分要点总结</span></a></div><div class="next-post pull-right"><a href="/2019/07/21/%E7%BD%91%E6%98%93Mumu%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"><span>网易Mumu代理设置</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'VqMxq8YhQKdt87hjlDYA4UDq-MdYXbMMI',
  appKey:'jMbPNFw1782lMDtEz6mIwhx4',
  placeholder:'早8点-晚11点会自动发送邮件提醒',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/08/07/eI1dSA.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2021 By Lufer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>